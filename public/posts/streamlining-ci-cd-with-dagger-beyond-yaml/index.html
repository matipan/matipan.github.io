<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Streamlining CI/CD with Dagger: Beyond YAML | Matias Pan's blog</title>
<meta name=keywords content="pulumi,go,aws,dagger,ci/cd"><meta name=description content="Dagger is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the supported SDKs. I&rsquo;m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me would be useful.
NOTE: Dagger is in very active development so by the time you read this blog post it might already be deprecated."><meta name=author content="matipan"><link rel=canonical href=https://blog.matiaspan.dev/posts/streamlining-ci-cd-with-dagger-beyond-yaml/><link crossorigin=anonymous href=/assets/css/stylesheet.a801c217e3c96db9c9df36cb1d2216a9bc5d9fa77b72e2afcdf47fb847f8f015.css integrity="sha256-qAHCF+PJbbnJ3zbLHSIWqbxdn6d7cuKvzfR/uEf48BU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Streamlining CI/CD with Dagger: Beyond YAML"><meta property="og:description" content="Dagger is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the supported SDKs. I&rsquo;m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me would be useful.
NOTE: Dagger is in very active development so by the time you read this blog post it might already be deprecated."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.matiaspan.dev/posts/streamlining-ci-cd-with-dagger-beyond-yaml/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-07T00:00:00-03:00"><meta property="article:modified_time" content="2023-11-07T00:00:00-03:00"><meta property="og:site_name" content="Matias Pan's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Streamlining CI/CD with Dagger: Beyond YAML"><meta name=twitter:description content="Dagger is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the supported SDKs. I&rsquo;m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me would be useful.
NOTE: Dagger is in very active development so by the time you read this blog post it might already be deprecated."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.matiaspan.dev/posts/"},{"@type":"ListItem","position":2,"name":"Streamlining CI/CD with Dagger: Beyond YAML","item":"https://blog.matiaspan.dev/posts/streamlining-ci-cd-with-dagger-beyond-yaml/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Streamlining CI/CD with Dagger: Beyond YAML","name":"Streamlining CI\/CD with Dagger: Beyond YAML","description":"Dagger is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the supported SDKs. I\u0026rsquo;m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me would be useful.\nNOTE: Dagger is in very active development so by the time you read this blog post it might already be deprecated.","keywords":["pulumi","go","aws","dagger","ci/cd"],"articleBody":"Dagger is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the supported SDKs. I’m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me would be useful.\nNOTE: Dagger is in very active development so by the time you read this blog post it might already be deprecated.\nBackground We have a repository that holds all of our infrastructure in a declarative way using Pulumi’s Go SDK. Every time we want to provision, change or delete some infrastructure we need to:\nCreate a pull request with the necessary changes Wait for CI to show what changes will be applied by posting a comment to the PR Merge it Wait for CI on the main branch to apply those changes to the given environment This process will utilize two operations pulumi provides:\npreview: show a diff of the changes that would be applied. up: apply the requested changes. We are going to build this workflow using Dagger and Pulumi’s CLI and show how this differentiates from a traditional pipeline built with a CI specific tool such as Github actions. I will explore both the “traditional” dagger client as well as the use of dagger modules.\nUsing the Dagger client As was mentioned previously our CI process will have two separate workflows for:\nPreviewing changes: used when a PR is created against main to execute pulumi preview and show the diff as a comment on the pull request. Applying changes: used when a commit is pushed to main to run pulumi up and apply the desired changes. Since our infrastructure is built with Go we will use Dagger’s Go SDK as well. To start building this pipeline we will add a ci folder to the root folder of our project with a main.go that instantiates a Dagger client:\npackage main import ( \"context\" \"dagger.io/dagger\" ) func main() { ctx := context.Background() client, err := dagger.Connect(ctx) if err != nil { log.Fatal(err) } // ... The Dagger client is used to interact with the Dagger engine. It provides a code-generated SDK that performs GraphQL queries that in the end perform operations inside containers by leveraging bulidkit. You could use this SDK to replace Dockerfiles completely but today we’ll focus on using it to execute the pulumi CLI in a containerized environment.\nNow, given that we need to support two operations (and both need the same flag) we need this program to manage arguments and execute different code based on those:\n// ... var stack = flag.Parse(\"stack\", \"prod\", \"pulumi stack to use\") func main() { flag.Parse() // ... if len(os.Args) == 0 { log.Fatal(\"specify an operation. Possible values: preview,up\") } switch os.Args[1] { case \"preview\": // Run `pulumi preview --stack ` case \"up\": // Run `pulumi up --stack ` } } Since with Dagger is containers all the way we can re-use existing images that have the dependencies we need. In this case all we need is pulumi, so we’ll use the official image to build a Container that has the necessary go dependencies, code and secrets to run:\nfunc baseContainer(client *dagger.Client) *dagger.Container { pulumiToken := client.SetSecret(\"pulumi_token\", os.Getenv(\"PULUMI_ACCESS_TOKEN\")) awsAccessKey := client.SetSecret(\"aws_access_key\", os.Getenv(\"AWS_ACCESS_KEY_ID\")) awsSecretKey := client.SetSecret(\"aws_secret_key\", os.Getenv(\"AWS_SECRET_ACCESS_KEY\")) return client. Container(). From(\"pulumi/pulumi:latest\"). WithSecretVariable(\"PULUMI_ACCESS_TOKEN\", pulumiToken). WithSecretVariable(\"AWS_ACCESS_KEY_ID\", awsAccessKey). WithSecretVariable(\"AWS_SECRET_ACCESS_KEY\", awsSecretKey). WithMountedDirectory(\"/infra\", client.Host().Directory(\".\")). WithWorkdir(\"/infra\"). WithEntrypoint([]string{\"/bin/bash\"}). WithExec([]string{\"-c\", \"go mod tidy\"}) } In this baseContainer function we are building and returning a container that:\nStarts from pulumi’s oficial image pulumi/pulumi:latest Has the credentials necessary to communicate with Pulumi and AWS obtained from the environment but stored in a secure way using Dagger secrets. Has the infrastructure code mounted in the working directory /infra and has all the go dependencies that our pulumi code requires. This container can now be used to execute pulumi commands. To run the preview operation we can:\n// ... func main() { // ... switch os.Args[1] { case \"preview\": out, err := baseContainer(client). WithExec([]string{\"-c\", fmt.Sprintf(\"pulumi preview --stack %s --non-interactive --diff\", *stack)}). Stdout(ctx) if err != nil { log.Fatal(err) } fmt.Println(out) case \"up\": // Run `pulumi up` } } We are now ready to try it out! To run Dagger you can either: i) use Dagger’s CLI to get a pretty output of what dagger is doing exactly (dagger run go run ./ci preview --stack prod); ii) or run go directly and get a silent output (go run ./ci preview --stack prod). Running this locally using Dagger’s CLI shows a lot of output, so I’ll show here only the relevant pulumi bits:\n┃ @ Previewing update..... ┃ @ Previewing update..... ┃ pulumi:pulumi:Stack: (same) ┃ [urn=urn:pulumi:prod::networking::pulumi:pulumi:Stack::networking-prod] ┃ ~ aws:ecs/service:Service: (update) ┃ [id=arn:aws:ecs:us-west-2:831445021348:service/services-0187c44/ninjas] ┃ [urn=urn:pulumi:prod::networking::awsx:ecs:FargateService$aws:ecs/service:Service::ninjas] ┃ [provider=urn:pulumi:prod::networking::pulumi:providers:aws::default_5_35_0::321a9293-c7af-42be-a9fd-061afc82e317] ┃ ~ networkConfiguration: { ┃ ~ securityGroups: [ ┃ ~ [0]: \"sg-0b2ee5e5403c1ca86\" =\u003e \"sg-0cf0cbf24b1e39535\" ┃ ] ┃ } ┃ - aws:ec2/securityGroup:SecurityGroup: (delete) ┃ [id=sg-0b2ee5e5403c1ca86] ┃ [urn=urn:pulumi:prod::networking::aws:ec2/securityGroup:SecurityGroup::svc-sg] ┃ description : \"Allow TCP traffic on port 8080 from the VPC\" ┃ egress : [ ┃ [0]: { ┃ cidrBlocks: [ ┃ [0]: \"0.0.0.0/0\" ┃ ] ┃ fromPort : 0 ┃ protocol : \"-1\" ┃ self : false ┃ toPort : 0 ┃ } ┃ ] ┃ ingress : [ ┃ [0]: { ┃ cidrBlocks : [ ┃ [0]: \"10.1.0.0/16\" ┃ ] ┃ description: \"allow TCP traffic on 8080 from the VPC\" ┃ fromPort : 8080 ┃ protocol : \"tcp\" ┃ self : false ┃ toPort : 8080 ┃ } ┃ ] ┃ name : \"svc-sg-6648e89\" ┃ revokeRulesOnDelete: false ┃ vpcId : \"vpc-0ec0d8d2118fc95c5\" ┃ Resources: ┃ ~ 1 to update ┃ - 1 to delete ┃ 2 changes. 59 unchanged So far we’ve run this locally, but we wanted this to be automated on a workflow. What changes do we need to make in order to adapt this to work in a CI environment? Nothing! We use Dagger so that we write code once and then run everywhere. The only CI-specific yaml we have yet to write is the workflow itself that offloads all of the heavy lifting to Dagger. Here is what a Github Actions workflow looks like for this preview functionality:\nname: 'preview' on: pull_request: branches: - main jobs: dagger: runs-on: ubuntu-latest permissions: write-all steps: - name: Checkout uses: actions/checkout@v3 - name: Setup Go uses: actions/setup-go@v4 with: go-version: '\u003e=1.21' - name: Install Dagger CLI run: cd /usr/local \u0026\u0026 { curl -L https://dl.dagger.io/dagger/install.sh | sh; cd -; } - name: Preview infrastructure changes env: PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }} AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY }} AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }} AWS_REGION: \"us-west-2\" run: dagger run go run ./ci preview -stack=ninjastructure/prod Other than “plugging” things together (env variables in this case) there is nothing special about this pipeline, all the important logic is hidden away inside our Dagger program.\nNow we want to make the pipeline a bit more interesting. The diff that was calculated previously should be posted to the PR as a comment so that whoever is reviewing it can look at the PR comments and see what is being changed. This is where Dagger, being a code-first solution, really shines. We can extend our Go program using Github’s SDK to communicate with it’s API and post the comment with the output of the command. Lets change our preview code to include this:\n// ... switch os.Args[1] { case \"preview\": out, err := baseContainer(client). WithExec([]string{\"-c\", fmt.Sprintf(\"pulumi preview --stack %s --non-interactive --diff\", *stack)}). Stdout(ctx) if err != nil { log.Fatal(err) } // if the token is not specified we won't post anything token := os.Getenv(\"GITHUB_TOKEN\") if token == \"\" { return } // GITHUB_REPOSITORY is in the format: `:owner/:repo` repo := strings.Split(os.Getenv(\"GITHUB_REPOSITORY\"), \"/\") // On pull requests GITHUB_REF has the format: `refs/pull/:prNumber/merge` ref, err := strconv.Atoi(strings.Split(os.Getenv(\"GITHUB_REF\"), \"/\")[2]) if err != nil { log.Fatal(err) } return postComment(ctx, out, token, repo[0], repo[1], ref) } func postComment(ctx context.Context, content, githubToken, owner, repo string, pr int) error { body := fmt.Sprintf(\"```\\n%s\\n```\", content) client := github.NewClient(nil).WithAuthToken(githubToken) _, _, err := client.Issues.CreateComment(ctx, owner, repo, pr, \u0026github.IssueComment{ Body: \u0026body, }) return err } If you want to test this changes locally you would have to provide github credentials.\nHere is a sample of this working at my repository:\nI think it’s interesting how dagger allows us to “tap” into the ecosystem of the language we are using in the same place where we are defining our CI process. While this example in particular is rather simple, imagine how this processes get complicated when you want to run more complicated process such as integration tests that require multiple containers running. I’m doing some exploration on this part that I hope to post soon, but in the meantime you can refer to this YouTube video to see an example of a more complicated CI process being implemented with Dagger.\nTo finish off our CI, all we have to do is write the up operation using the baseContainer and specifying the up command:\ncase \"up\": out, err := baseContainer(client). WithExec([]string{\"-c\", fmt.Sprintf(\"pulumi up --stack %s --yes --skip-preview\", *stack)}). Stdout(ctx) if err != nil { return err } fmt.Println(out) And the up workflow looks very similar to the previous one:\nname: 'up' on: push: branches: - main jobs: dagger: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 - name: Setup Go uses: actions/setup-go@v4 with: go-version: '\u003e=1.21' - name: Install Dagger CLI run: cd /usr/local \u0026\u0026 { curl -L https://dl.dagger.io/dagger/install.sh | sh; cd -; } - name: Preview infrastructure changes env: PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }} AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY }} AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }} AWS_REGION: \"us-west-2\" GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} run: dagger run go run ./ci up -stack=ninjastructure/prod And we are done! We now have a pipeline that performs preview operations on PRs and leaves a comment showing the diff of what is going to be changed and an up operation on new commits in the main branch that will be apply changes to the infra directly. If you want to integrate this process with more tools, for example sending a message on Slack after changes have been applied you could use Slack’s SDK or communicate with Slack’s API directly using Go’s standard library.\nUsing Dagger modules Using the Dagger client was quite straightforward, however, we had to manually build some form of “CLI”. Parse arguments and flags and manage the logic of what the user is trying to call. The way I built it is not very “expressive” either, in order to understand what this CLI can do you would have to read the code. It wasn’t that big of a deal given how simple the process is. But as this processes get more complicated (for example orchestrating apply commands on multiple environments based on specific conditions and files changed) the CLI will get more complicated and more parameterized and become less expressive overtime.\nThe process we built is also not reusable. If somebody else is using pulumi as well and wants to apply this or a similar process they have to rebuild the whole thing from scratch. If you were building this using github actions, you would probably reuse an action that somebody else developed that has the functionality you need. So, how can we achieve this with Dagger? This is where Dagger modules come in. Dagger modules allow us to encapsulate specific tasks (and even entire workflows) into functions that are written in one of the supported programming languages. The interesting bit is that Dagger then packages this functions into a GraphQL API that can be queried from any other language. This means that with modules you can essentially build a cross-language ecosystem of tasks and workflows that can be used by anybody. All you have to do is browse the daggerverse, find the module you are interested it and call those functions from your code base. This is all very exciting, now lets implement this same process using modules. We are still going to use Go’s SDK because here we love Go. We first have to initialize the module, same as before we’ll use the CI folder:\ncd ci/ dagger mod init --sdk go --name pulumi This will generate, among other stuff, a dagger.json file that contains the specification of the module:\n{ \"name\": \"infra\", \"sdk\": \"go\" } In this same file we could potentially add dependencies. If somebody already developed a feature-rich pulumi module we could call dagger mod use and specify the URL, those dependencies would be added to dagger.json and from our code we call that module. Lets say the pulumi module did not support commenting on Github, well we could add the code to post those comments to our module using the output that the Pulumi module gave us. But, there is no pulumi module so we’ll write everything from scratch. We can reuse everything that we built before with a small caveat: when using modules we do not use the dagger client as before. This is because Dagger generates code for us, this code contains the entire dagger SDK and any additional modules we referenced. So, lets refactor our pipeline to use this new generated code:\npackage main import ( \"context\" \"fmt\" \"strconv\" \"strings\" \"github.com/google/go-github/v56/github\" ) type Infra struct{} func (m *Infra) Up(ctx context.Context, src *Directory, stack string, pulumiToken, awsAccessKey, awsSecretKey *Secret) (string, error) { return container(src, pulumiToken, awsAccessKey, awsSecretKey). WithExec([]string{\"-c\", fmt.Sprintf(\"pulumi preview --stack %s --non-interactive --diff\", stack)}). Stdout(ctx) } func (m *Infra) Preview(ctx context.Context, src *Directory, stack string, pulumiToken, awsAccessKey, awsSecretKey *Secret, githubToken Optional[*Secret], repository, ghRef Optional[string]) (string, error) { out, err := container(src, pulumiToken, awsAccessKey, awsSecretKey). WithExec([]string{\"-c\", fmt.Sprintf(\"pulumi preview --stack %s --non-interactive --diff\", stack)}). Stdout(ctx) if err != nil { return \"\", err } token, tokenSet := githubToken.Get() repoValue, repoSet := repository.Get() refValue, refSet := ghRef.Get() if !tokenSet || !repoSet || !refSet { return out, nil } // repository is in the format: `:owner/:repo` repo := strings.Split(repoValue, \"/\") // ref has the format `refs/pull/:prNumber/merge` ref, err := strconv.Atoi(strings.Split(refValue, \"/\")[2]) if err != nil { return out, err } return out, postGithubComment(ctx, token, out, repo[0], repo[1], ref) } func postGithubComment(ctx context.Context, token *Secret, content, owner, repo string, pr int) error { githubToken, err := token.Plaintext(ctx) if err != nil { return err } body := fmt.Sprintf(\"```\\n%s\\n```\", content) client := github.NewClient(nil).WithAuthToken(githubToken) _, _, err = client.Issues.CreateComment(ctx, owner, repo, pr, \u0026github.IssueComment{ Body: \u0026body, }) return err } func container(src *Directory, pulumiToken, awsAccessKey, awsSecretKey *Secret) *Container { return dag. Container(). From(\"pulumi/pulumi:latest\"). WithSecretVariable(\"PULUMI_ACCESS_TOKEN\", pulumiToken). WithSecretVariable(\"AWS_ACCESS_KEY_ID\", awsAccessKey). WithSecretVariable(\"AWS_SECRET_ACCESS_KEY\", awsSecretKey). WithMountedDirectory(\"/infra\", src). WithWorkdir(\"/infra\"). WithEntrypoint([]string{\"/bin/bash\"}). WithExec([]string{\"-c\", \"go mod tidy\"}) } As you can see in the container function, we are using the dag variable that it is not really declared anywhere in this file. And there are not dependencies to Dagger either. The variable is part of dagger.gen.go:\ndagger generated code Using dagger’s tooling we can now easily understand what this API is capable of. We can use dagger functions to understand what operations it supports:\n$ dagger -m ./ci functions ✔ dagger functions [0.00s] ┃ object name function name description return type ┃ *Infra up String! ┃ *Infra preview String! • Engine: 03801e21c26e (version v0.9.3) ⧗ 2.77s ✔ 23 ∅ 2 And what arguments a given operation requires:\n$ dagger -m ./ci call preview --help ✔ dagger call preview [0.00s] ┃ Usage: ┃ dagger call preview [flags] ┃ ┃ Flags: ┃ --aws-access-key Secret ┃ --aws-secret-key Secret ┃ --gh-ref string ┃ --github-token Secret ┃ -h, --help help for preview ┃ --pulumi-token Secret ┃ --repository string ┃ --src Directory ┃ --stack string Now, anybody that joins this project can easily understand what our CI process does and test it locally. Now, you may have noticed that we now have a huge list of arguments compared to before. On our previous iteration we were relying on the host’s environment variables for every single credential we required. This is how traditional CI processes work. However, Dagger functions run in a sandboxed environment. This means that everything you have in the host will not be automatically available in the execution context of the function. We have to explicitly provide the credentials as arguments now:\n$ dagger -m ./ci call preview --src \".\" --stack \"ninjastructure/prod\" --repository $GITHUB_REPOSITORY --gh-ref $GITHUB_REF --github-token $GITHUB_TOKEN --pulumi-token $PULUMI_TOKEN --aws-access-key $AWS_ACCESS_KEY_ID --aws-secret-key $AWS_SECRET_ACCESS_KEY ✔ dagger call preview [1m47.6s] ┃ Previewing update (ninjastructure/prod) ┃ ┃ View Live: https://app.pulumi.com/ninjastructure/networking/prod/previews/81831d41-5ed0-4476-8bfa-cfa9c79f5b4f ┃ ┃ go: downloading github.com/hashicorp/hcl v1.0.0 ┃ ┃ go: downloading google.golang.org/genproto v0.0.0-20230726155614-23370e0ffb3e ┃ ┃ @ Previewing update...... ┃ pulumi:pulumi:Stack: (same) ┃ [urn=urn:pulumi:prod::networking::pulumi:pulumi:Stack::networking-prod] ┃ ~ aws:ecs/service:Service: (update) ┃ [id=arn:aws:ecs:us-west-2:831445021348:service/services-0187c44/ninjas] ┃ [urn=urn:pulumi:prod::networking::awsx:ecs:FargateService$aws:ecs/service:Service::ninjas] ┃ [provider=urn:pulumi:prod::networking::pulumi:providers:aws::default_5_35_0::321a9293-c7af-42be-a9fd-061afc82e317] ┃ ~ networkConfiguration: { ┃ ~ securityGroups: [ ┃ ~ [0]: \"sg-0b2ee5e5403c1ca86\" =\u003e \"sg-0cf0cbf24b1e39535\" ┃ ] ┃ } ┃ - aws:ec2/securityGroup:SecurityGroup: (delete) ┃ [id=sg-0b2ee5e5403c1ca86] ┃ [urn=urn:pulumi:prod::networking::aws:ec2/securityGroup:SecurityGroup::svc-sg] ┃ description : \"Allow TCP traffic on port 8080 from the VPC\" ┃ egress : [ ┃ [0]: { ┃ cidrBlocks: [ ┃ [0]: \"0.0.0.0/0\" ┃ ] ┃ fromPort : 0 ┃ protocol : \"-1\" ┃ self : false ┃ toPort : 0 ┃ } ┃ ] ┃ ingress : [ ┃ [0]: { ┃ cidrBlocks : [ ┃ [0]: \"10.1.0.0/16\" ┃ ] ┃ description: \"allow TCP traffic on 8080 from the VPC\" ┃ fromPort : 8080 ┃ protocol : \"tcp\" ┃ self : false ┃ toPort : 8080 ┃ } ┃ ] ┃ name : \"svc-sg-6648e89\" ┃ revokeRulesOnDelete: false ┃ vpcId : \"vpc-0ec0d8d2118fc95c5\" ┃ Resources: ┃ ~ 1 to update ┃ - 1 to delete ┃ 2 changes. 59 unchanged • Engine: 03801e21c26e (version v0.9.3) ⧗ 1m50.1s ✔ 64 ∅ 8 Running this in the CI process requires us to modify the github workflow and execute this exact same command specifying the credentials and environment variables available on the CI runner.\nI believe this is a more expressive way of building CI systems. In the next section we will build this using native github actions and do a comparison of Dagger vs traditional CIs.\nComparing Dagger to traditional CI solutions To have a better understanding of whether Dagger gave us a better experience and how it conceptually differentiates from traditional CIs we have to at least implement this process using github actions. We could have leveraged a github action implemented by the Pulumi team to do this preview/up process with github comments included:\nname: Pulumi on: - pull_request jobs: preview: name: Preview runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: actions/setup-go@v3 with: go-version: 'stable' - name: Configure AWS Credentials uses: aws-actions/configure-aws-credentials@v1 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-region: ${{ secrets.AWS_REGION }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} - run: go mod download - uses: pulumi/actions@v3 with: command: preview stack-name: org-name/stack-name comment-on-pr: true github-token: ${{ secrets.GITHUB_TOKEN }} env: PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }} There are two main differences that I see with this implementation. First of all, this is not easily testable and extensible. We could leverage something like arc or gale to run this process locally, but when it comes to extending we would either have to build custom actions or do some setup magic and run custom scripts on top of this yaml. Again, this is a simple process, but CI/CD often gets more complicated as time goes on. And while right now this may not seem like an obvious problem, it always ends up becoming that critical yaml file that nobody wants to touch. The second main difference is more “conceptual” but it is important to point out because it requires a mindset shift when it comes to building CI. In the traditional pipeline, we can see a “statefull” approach, where each of the steps that are being executed are doing explicit things on the host (i.e the runner) that the subsequent action then reuses:\nCheckout the code of the repository Install the latest stable version of Go Configure AWS’s credentials (technically not needed, we could use env variables directly…) Download go dependencies that pulumi’s code uses. Run pulumi preview Every single one of those actions changed the underlying host in some way and left a state that the subsequent action would then use. This means that when you build a workflow you always operate directly on the host instead of “chaining” inputs/outputs like you do when building a dag, for example an Airflow dag. I don’t particularly like this approach, it is one of the main things that makes this processed hard to test and more importantly very hard to understand.\nWith dagger modules we saw a different approach. When we were calling the function of the module, we had to explicitly provide all the required resources to perform the preview or up operation. This is because, as we mentioned previously, dagger functions run in a sandboxed environment that could even be executed on a different host! This, in my opinion, opens up interesting possibilities for building CI pipelines using reusable APIs that are deployed once and used everywhere. There might be occasions where this stateless approach falls short, but this new approach is only getting started. I think there is a lot of similarity with how the data world works. When you build data pipelines using tools like Airflow, the worker where the operator code gets executed usually only performs HTTP calls. For example, if you build a data pipeline that performs some data transformation using spark on EMR and then ingests that data on a datasource like clickhouse, your Airflow DAG will probably look something like this:\nUse EMR Operator to execute some spark code. Airflow’s worker will call AWS’s API, ask for a given script to be executed and then wait for completion. Use an ECS task or similar to run code that reads the data from S3 and ingest it into clickhouse. Conclusion Dagger offers a compelling alternative to yaml and custom scripts in CI/CD pipelines. By leveraging code, we gain expressiveness, reusability, and the ability to integrate with a wide range of tools and services. As Dagger matures, I’m excited to see how it will continue to evolve and improve CI/CD practices.\n","wordCount":"3622","inLanguage":"en","datePublished":"2023-11-07T00:00:00-03:00","dateModified":"2023-11-07T00:00:00-03:00","author":{"@type":"Person","name":"matipan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.matiaspan.dev/posts/streamlining-ci-cd-with-dagger-beyond-yaml/"},"publisher":{"@type":"Organization","name":"Matias Pan's blog","logo":{"@type":"ImageObject","url":"https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.matiaspan.dev/ accesskey=h title="Home (Alt + H)"><img src=https://blog.matiaspan.dev/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.matiaspan.dev/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.matiaspan.dev/search/ title=Search><span>Search</span></a></li><li><a href=https://blog.matiaspan.dev/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.matiaspan.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Streamlining CI/CD with Dagger: Beyond YAML</h1><div class=post-meta><span title='2023-11-07 00:00:00 -0300 -03'>November 7, 2023</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;matipan&nbsp;|&nbsp;<a href=https://github.com/matipan/matipan.github.io/tree/main/content/posts/streamlining-ci-cd-with-dagger-beyond-yaml.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#using-the-dagger-client>Using the Dagger client</a></li><li><a href=#using-dagger-modules>Using Dagger modules</a></li><li><a href=#comparing-dagger-to-traditional-ci-solutions>Comparing Dagger to traditional CI solutions</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p><a href=https://dagger.io/>Dagger</a> is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the <a href=https://docs.dagger.io/>supported SDKs</a>. I&rsquo;m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me would be useful.</p><p><strong>NOTE</strong>: Dagger is in very active development so by the time you read this blog post it might already be deprecated.</p><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><p>We have a repository that holds all of our infrastructure in a declarative way using <a href=https://www.pulumi.com/>Pulumi&rsquo;s</a> Go SDK. Every time we want to provision, change or delete some infrastructure we need to:</p><ol><li>Create a pull request with the necessary changes</li><li>Wait for CI to show what changes will be applied by posting a comment to the PR</li><li>Merge it</li><li>Wait for CI on the main branch to apply those changes to the given environment</li></ol><p>This process will utilize two operations pulumi provides:</p><ul><li><code>preview</code>: show a diff of the changes that <em>would</em> be applied.</li><li><code>up</code>: apply the requested changes.</li></ul><p>We are going to build this workflow using Dagger and Pulumi&rsquo;s CLI and show how this differentiates from a traditional pipeline built with a CI specific tool such as Github actions. I will explore both the <a href=#using-the-dagger-client>&ldquo;traditional&rdquo; dagger client</a> as well as the use of <a href=#using-dagger-modules>dagger modules</a>.</p><h2 id=using-the-dagger-client>Using the Dagger client<a hidden class=anchor aria-hidden=true href=#using-the-dagger-client>#</a></h2><p>As was mentioned previously our CI process will have two separate workflows for:</p><ul><li><strong>Previewing changes</strong>: used when a PR is created against <code>main</code> to execute <code>pulumi preview</code> and show the diff as a comment on the pull request.</li><li><strong>Applying changes</strong>: used when a commit is pushed to <code>main</code> to run <code>pulumi up</code> and apply the desired changes.</li></ul><p>Since our infrastructure is built with Go we will use Dagger&rsquo;s Go SDK as well. To start building this pipeline we will add a <code>ci</code> folder to the root folder of our project with a <code>main.go</code> that instantiates a Dagger client:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;dagger.io/dagger&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>client</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dagger</span><span class=p>.</span><span class=nf>Connect</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span></code></pre></div><p>The Dagger client is used to interact with the Dagger engine. It provides a code-generated SDK that performs GraphQL queries that in the end perform operations inside containers by leveraging <a href=https://github.com/moby/buildkit>bulidkit</a>. You could use this SDK to replace Dockerfiles completely but today we&rsquo;ll focus on using it to execute the <code>pulumi</code> CLI in a containerized environment.</p><p>Now, given that we need to support two operations (and both need the same flag) we need this program to manage arguments and execute different code based on those:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>stack</span> <span class=p>=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>Parse</span><span class=p>(</span><span class=s>&#34;stack&#34;</span><span class=p>,</span> <span class=s>&#34;prod&#34;</span><span class=p>,</span> <span class=s>&#34;pulumi stack to use&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>flag</span><span class=p>.</span><span class=nf>Parse</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=s>&#34;specify an operation. Possible values: preview,up&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;preview&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Run `pulumi preview --stack &lt;stack&gt;`
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>case</span> <span class=s>&#34;up&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Run `pulumi up --stack &lt;stack&gt;`
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Since with Dagger is containers all the way we can re-use existing images that have the dependencies we need. In this case all we need is pulumi, so we&rsquo;ll use the <a href=https://hub.docker.com/r/pulumi/pulumi>official image</a> to build a <code>Container</code> that has the necessary go dependencies, code and secrets to run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>baseContainer</span><span class=p>(</span><span class=nx>client</span> <span class=o>*</span><span class=nx>dagger</span><span class=p>.</span><span class=nx>Client</span><span class=p>)</span> <span class=o>*</span><span class=nx>dagger</span><span class=p>.</span><span class=nx>Container</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>pulumiToken</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>SetSecret</span><span class=p>(</span><span class=s>&#34;pulumi_token&#34;</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;PULUMI_ACCESS_TOKEN&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>awsAccessKey</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>SetSecret</span><span class=p>(</span><span class=s>&#34;aws_access_key&#34;</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;AWS_ACCESS_KEY_ID&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>awsSecretKey</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>SetSecret</span><span class=p>(</span><span class=s>&#34;aws_secret_key&#34;</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;AWS_SECRET_ACCESS_KEY&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>client</span><span class=p>.</span>
</span></span><span class=line><span class=cl>		<span class=nf>Container</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>From</span><span class=p>(</span><span class=s>&#34;pulumi/pulumi:latest&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;PULUMI_ACCESS_TOKEN&#34;</span><span class=p>,</span> <span class=nx>pulumiToken</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;AWS_ACCESS_KEY_ID&#34;</span><span class=p>,</span> <span class=nx>awsAccessKey</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;AWS_SECRET_ACCESS_KEY&#34;</span><span class=p>,</span> <span class=nx>awsSecretKey</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithMountedDirectory</span><span class=p>(</span><span class=s>&#34;/infra&#34;</span><span class=p>,</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Host</span><span class=p>().</span><span class=nf>Directory</span><span class=p>(</span><span class=s>&#34;.&#34;</span><span class=p>)).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithWorkdir</span><span class=p>(</span><span class=s>&#34;/infra&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithEntrypoint</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;/bin/bash&#34;</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=s>&#34;go mod tidy&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In this <code>baseContainer</code> function we are building and returning a container that:</p><ul><li>Starts from pulumi&rsquo;s oficial image <a href=https://hub.docker.com/r/pulumi/pulumi>pulumi/pulumi:latest</a></li><li>Has the credentials necessary to communicate with Pulumi and AWS obtained from the environment but stored in a secure way using <a href=https://docs.dagger.io/723462/use-secrets/>Dagger secrets</a>.</li><li>Has the infrastructure code mounted in the working directory <code>/infra</code> and</li><li>has all the go dependencies that our pulumi code requires.</li></ul><p>This container can now be used to execute pulumi commands. To run the preview operation we can:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>switch</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;preview&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>out</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>baseContainer</span><span class=p>(</span><span class=nx>client</span><span class=p>).</span>
</span></span><span class=line><span class=cl>			<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;pulumi preview --stack %s --non-interactive --diff&#34;</span><span class=p>,</span> <span class=o>*</span><span class=nx>stack</span><span class=p>)}).</span>
</span></span><span class=line><span class=cl>			<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;up&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Run `pulumi up`
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We are now ready to try it out! To run Dagger you can either: i) use Dagger&rsquo;s CLI to get a pretty output of what dagger is doing exactly (<code>dagger run go run ./ci preview --stack prod</code>); ii) or run go directly and get a silent output (<code>go run ./ci preview --stack prod</code>). Running this locally using Dagger&rsquo;s CLI shows a lot of output, so I&rsquo;ll show here only the relevant pulumi bits:</p><pre tabindex=0><code>┃ @ Previewing update.....
┃ @ Previewing update.....
┃   pulumi:pulumi:Stack: (same)
┃     [urn=urn:pulumi:prod::networking::pulumi:pulumi:Stack::networking-prod]
┃         ~ aws:ecs/service:Service: (update)
┃             [id=arn:aws:ecs:us-west-2:831445021348:service/services-0187c44/ninjas]
┃             [urn=urn:pulumi:prod::networking::awsx:ecs:FargateService$aws:ecs/service:Service::ninjas]
┃             [provider=urn:pulumi:prod::networking::pulumi:providers:aws::default_5_35_0::321a9293-c7af-42be-a9fd-061afc82e317]
┃           ~ networkConfiguration: {
┃               ~ securityGroups: [
┃                   ~ [0]: &#34;sg-0b2ee5e5403c1ca86&#34; =&gt; &#34;sg-0cf0cbf24b1e39535&#34;
┃                 ]
┃             }
┃     - aws:ec2/securityGroup:SecurityGroup: (delete)
┃         [id=sg-0b2ee5e5403c1ca86]
┃         [urn=urn:pulumi:prod::networking::aws:ec2/securityGroup:SecurityGroup::svc-sg]
┃         description        : &#34;Allow TCP traffic on port 8080 from the VPC&#34;
┃         egress             : [
┃             [0]: {
┃                 cidrBlocks: [
┃                     [0]: &#34;0.0.0.0/0&#34;
┃                 ]
┃                 fromPort  : 0
┃                 protocol  : &#34;-1&#34;
┃                 self      : false
┃                 toPort    : 0
┃             }
┃         ]
┃         ingress            : [
┃             [0]: {
┃                 cidrBlocks : [
┃                     [0]: &#34;10.1.0.0/16&#34;
┃                 ]
┃                 description: &#34;allow TCP traffic on 8080 from the VPC&#34;
┃                 fromPort   : 8080
┃                 protocol   : &#34;tcp&#34;
┃                 self       : false
┃                 toPort     : 8080
┃             }
┃         ]
┃         name               : &#34;svc-sg-6648e89&#34;
┃         revokeRulesOnDelete: false
┃         vpcId              : &#34;vpc-0ec0d8d2118fc95c5&#34;
┃ Resources:
┃     ~ 1 to update
┃     - 1 to delete
┃     2 changes. 59 unchanged
</code></pre><p>So far we&rsquo;ve run this locally, but we wanted this to be automated on a workflow. What changes do we need to make in order to adapt this to work in a CI environment? Nothing! We use Dagger so that we write code once and then run everywhere. The only CI-specific yaml we have yet to write is the workflow itself that offloads all of the heavy lifting to Dagger. Here is what a Github Actions workflow looks like for this preview functionality:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;preview&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>pull_request</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>dagger</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>permissions</span><span class=p>:</span><span class=w> </span><span class=l>write-all</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Setup Go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/setup-go@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>go-version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;&gt;=1.21&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install Dagger CLI</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>cd /usr/local &amp;&amp; { curl -L https://dl.dagger.io/dagger/install.sh | sh; cd -; }</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Preview infrastructure changes</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>PULUMI_ACCESS_TOKEN</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.PULUMI_ACCESS_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_ACCESS_KEY_ID</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_ACCESS_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_SECRET_ACCESS_KEY</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_SECRET_ACCESS_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_REGION</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;us-west-2&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>dagger run go run ./ci preview -stack=ninjastructure/prod</span><span class=w>
</span></span></span></code></pre></div><p>Other than &ldquo;plugging&rdquo; things together (env variables in this case) there is nothing special about this pipeline, all the important logic is hidden away inside our Dagger program.</p><p>Now we want to make the pipeline a bit more interesting. The diff that was calculated previously should be posted to the PR as a comment so that whoever is reviewing it can look at the PR comments and see what is being changed. This is where Dagger, being a code-first solution, really shines. We can extend our Go program using Github&rsquo;s SDK to communicate with it&rsquo;s API and post the comment with the output of the command. Lets change our <code>preview</code> code to include this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>switch</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;preview&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>out</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>baseContainer</span><span class=p>(</span><span class=nx>client</span><span class=p>).</span>
</span></span><span class=line><span class=cl>			<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;pulumi preview --stack %s --non-interactive --diff&#34;</span><span class=p>,</span> <span class=o>*</span><span class=nx>stack</span><span class=p>)}).</span>
</span></span><span class=line><span class=cl>			<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// if the token is not specified we won&#39;t post anything
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>token</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;GITHUB_TOKEN&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>token</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// GITHUB_REPOSITORY is in the format: `:owner/:repo`
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>repo</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;GITHUB_REPOSITORY&#34;</span><span class=p>),</span> <span class=s>&#34;/&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// On pull requests GITHUB_REF has the format: `refs/pull/:prNumber/merge`
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>ref</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;GITHUB_REF&#34;</span><span class=p>),</span> <span class=s>&#34;/&#34;</span><span class=p>)[</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nf>postComment</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>out</span><span class=p>,</span> <span class=nx>token</span><span class=p>,</span> <span class=nx>repo</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>repo</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nx>ref</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>postComment</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>content</span><span class=p>,</span> <span class=nx>githubToken</span><span class=p>,</span> <span class=nx>owner</span><span class=p>,</span> <span class=nx>repo</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>pr</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>body</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;```\n%s\n```&#34;</span><span class=p>,</span> <span class=nx>content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>client</span> <span class=o>:=</span> <span class=nx>github</span><span class=p>.</span><span class=nf>NewClient</span><span class=p>(</span><span class=kc>nil</span><span class=p>).</span><span class=nf>WithAuthToken</span><span class=p>(</span><span class=nx>githubToken</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nx>Issues</span><span class=p>.</span><span class=nf>CreateComment</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>owner</span><span class=p>,</span> <span class=nx>repo</span><span class=p>,</span> <span class=nx>pr</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>github</span><span class=p>.</span><span class=nx>IssueComment</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Body</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If you want to test this changes locally you would have to provide github credentials.</p><p>Here is a sample of this working at my repository:</p><p><img loading=lazy src=/images/dagger-pr-comment.png alt="image that shows a comment in a Github PR containing a Pulumi diff that explains the infrastructure changes that want to be applied"></p><p>I think it&rsquo;s interesting how dagger allows us to &ldquo;tap&rdquo; into the ecosystem of the language we are using in the same place where we are defining our CI process. While this example in particular is rather simple, imagine how this processes get complicated when you want to run more complicated process such as integration tests that require multiple containers running. I&rsquo;m doing some exploration on this part that I hope to post soon, but in the meantime you can refer to <a href="https://www.youtube.com/watch?v=NjABt0owEeI">this YouTube video</a> to see an example of a more complicated CI process being implemented with Dagger.</p><p>To finish off our CI, all we have to do is write the <code>up</code> operation using the <code>baseContainer</code> and specifying the <code>up</code> command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;up&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>out</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>baseContainer</span><span class=p>(</span><span class=nx>client</span><span class=p>).</span>
</span></span><span class=line><span class=cl>			<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;pulumi up --stack %s --yes --skip-preview&#34;</span><span class=p>,</span> <span class=o>*</span><span class=nx>stack</span><span class=p>)}).</span>
</span></span><span class=line><span class=cl>			<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>out</span><span class=p>)</span>
</span></span></code></pre></div><p>And the <code>up</code> workflow looks very similar to the previous one:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;up&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>push</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>dagger</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Setup Go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/setup-go@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>go-version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;&gt;=1.21&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install Dagger CLI</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>cd /usr/local &amp;&amp; { curl -L https://dl.dagger.io/dagger/install.sh | sh; cd -; }</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Preview infrastructure changes</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>PULUMI_ACCESS_TOKEN</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.PULUMI_ACCESS_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_ACCESS_KEY_ID</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_ACCESS_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_SECRET_ACCESS_KEY</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_SECRET_ACCESS_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_REGION</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;us-west-2&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>GITHUB_TOKEN</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.GITHUB_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>dagger run go run ./ci up -stack=ninjastructure/prod</span><span class=w>
</span></span></span></code></pre></div><p>And we are done! We now have a pipeline that performs <code>preview</code> operations on PRs and leaves a comment showing the diff of what is going to be changed and an <code>up</code> operation on new commits in the main branch that will be apply changes to the infra directly. If you want to integrate this process with more tools, for example sending a message on Slack after changes have been applied you could use Slack&rsquo;s SDK or communicate with Slack&rsquo;s API directly using Go&rsquo;s standard library.</p><h2 id=using-dagger-modules>Using Dagger modules<a hidden class=anchor aria-hidden=true href=#using-dagger-modules>#</a></h2><p>Using the Dagger client was quite straightforward, however, we had to manually build some form of &ldquo;CLI&rdquo;. Parse arguments and flags and manage the logic of what the user is trying to call. The way I built it is not very &ldquo;expressive&rdquo; either, in order to understand what this CLI can do you would have to read the code. It wasn&rsquo;t that big of a deal given how simple the process is. But as this processes get more complicated (for example orchestrating apply commands on multiple environments based on specific conditions and files changed) the CLI will get more complicated and more parameterized and become less expressive overtime.</p><p>The process we built is also not reusable. If somebody else is using pulumi as well and wants to apply this or a similar process they have to rebuild the whole thing from scratch. If you were building this using github actions, you would probably reuse an action that somebody else developed that has the functionality you need. So, how can we achieve this with Dagger? This is where <a href=https://daggerverse.dev>Dagger modules</a> come in. Dagger modules allow us to encapsulate specific tasks (and even entire workflows) into functions that are written in one of the supported programming languages. The interesting bit is that Dagger then packages this functions into a GraphQL API that can be queried from any other language. This means that with modules you can essentially build a cross-language ecosystem of tasks and workflows that can be used by anybody. All you have to do is browse the <a href=https://daggerverse.dev>daggerverse</a>, find the module you are interested it and call those functions from your code base. This is all very exciting, now lets implement this same process using modules. We are still going to use Go&rsquo;s SDK because here we love Go. We first have to initialize the module, same as before we&rsquo;ll use the CI folder:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>cd</span> ci/
</span></span><span class=line><span class=cl>dagger mod init --sdk go --name pulumi
</span></span></code></pre></div><p>This will generate, among other stuff, a <code>dagger.json</code> file that contains the specification of the module:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;infra&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;sdk&#34;</span><span class=p>:</span> <span class=s2>&#34;go&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In this same file we could potentially add dependencies. If somebody already developed a feature-rich <code>pulumi</code> module we could call <code>dagger mod use</code> and specify the URL, those dependencies would be added to <code>dagger.json</code> and from our code we call that module. Lets say the pulumi module did not support commenting on Github, well we could add the code to post those comments to our module using the output that the Pulumi module gave us. But, there is no pulumi module so we&rsquo;ll write everything from scratch. We can reuse everything that we built before with a small caveat: when using modules we do not use the dagger client as before. This is because Dagger generates code for us, this code contains the entire dagger SDK and any additional modules we referenced. So, lets refactor our pipeline to use this new generated code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;strconv&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;strings&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;github.com/google/go-github/v56/github&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Infra</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Infra</span><span class=p>)</span> <span class=nf>Up</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>src</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>,</span> <span class=nx>stack</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>pulumiToken</span><span class=p>,</span> <span class=nx>awsAccessKey</span><span class=p>,</span> <span class=nx>awsSecretKey</span> <span class=o>*</span><span class=nx>Secret</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>container</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=nx>pulumiToken</span><span class=p>,</span> <span class=nx>awsAccessKey</span><span class=p>,</span> <span class=nx>awsSecretKey</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;pulumi preview --stack %s --non-interactive --diff&#34;</span><span class=p>,</span> <span class=nx>stack</span><span class=p>)}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Infra</span><span class=p>)</span> <span class=nf>Preview</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>src</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>,</span> <span class=nx>stack</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>pulumiToken</span><span class=p>,</span> <span class=nx>awsAccessKey</span><span class=p>,</span> <span class=nx>awsSecretKey</span> <span class=o>*</span><span class=nx>Secret</span><span class=p>,</span> <span class=nx>githubToken</span> <span class=nx>Optional</span><span class=p>[</span><span class=o>*</span><span class=nx>Secret</span><span class=p>],</span> <span class=nx>repository</span><span class=p>,</span> <span class=nx>ghRef</span> <span class=nx>Optional</span><span class=p>[</span><span class=kt>string</span><span class=p>])</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>out</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>container</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=nx>pulumiToken</span><span class=p>,</span> <span class=nx>awsAccessKey</span><span class=p>,</span> <span class=nx>awsSecretKey</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;pulumi preview --stack %s --non-interactive --diff&#34;</span><span class=p>,</span> <span class=nx>stack</span><span class=p>)}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>token</span><span class=p>,</span> <span class=nx>tokenSet</span> <span class=o>:=</span> <span class=nx>githubToken</span><span class=p>.</span><span class=nf>Get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>repoValue</span><span class=p>,</span> <span class=nx>repoSet</span> <span class=o>:=</span> <span class=nx>repository</span><span class=p>.</span><span class=nf>Get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>refValue</span><span class=p>,</span> <span class=nx>refSet</span> <span class=o>:=</span> <span class=nx>ghRef</span><span class=p>.</span><span class=nf>Get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>tokenSet</span> <span class=o>||</span> <span class=p>!</span><span class=nx>repoSet</span> <span class=o>||</span> <span class=p>!</span><span class=nx>refSet</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>out</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// repository is in the format: `:owner/:repo`
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>repo</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>repoValue</span><span class=p>,</span> <span class=s>&#34;/&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ref has the format `refs/pull/:prNumber/merge`
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>ref</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>refValue</span><span class=p>,</span> <span class=s>&#34;/&#34;</span><span class=p>)[</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>out</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>out</span><span class=p>,</span> <span class=nf>postGithubComment</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>token</span><span class=p>,</span> <span class=nx>out</span><span class=p>,</span> <span class=nx>repo</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>repo</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nx>ref</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>postGithubComment</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>token</span> <span class=o>*</span><span class=nx>Secret</span><span class=p>,</span> <span class=nx>content</span><span class=p>,</span> <span class=nx>owner</span><span class=p>,</span> <span class=nx>repo</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>pr</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>githubToken</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>token</span><span class=p>.</span><span class=nf>Plaintext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>body</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;```\n%s\n```&#34;</span><span class=p>,</span> <span class=nx>content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>client</span> <span class=o>:=</span> <span class=nx>github</span><span class=p>.</span><span class=nf>NewClient</span><span class=p>(</span><span class=kc>nil</span><span class=p>).</span><span class=nf>WithAuthToken</span><span class=p>(</span><span class=nx>githubToken</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>client</span><span class=p>.</span><span class=nx>Issues</span><span class=p>.</span><span class=nf>CreateComment</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>owner</span><span class=p>,</span> <span class=nx>repo</span><span class=p>,</span> <span class=nx>pr</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>github</span><span class=p>.</span><span class=nx>IssueComment</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Body</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>container</span><span class=p>(</span><span class=nx>src</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>,</span> <span class=nx>pulumiToken</span><span class=p>,</span> <span class=nx>awsAccessKey</span><span class=p>,</span> <span class=nx>awsSecretKey</span> <span class=o>*</span><span class=nx>Secret</span><span class=p>)</span> <span class=o>*</span><span class=nx>Container</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>dag</span><span class=p>.</span>
</span></span><span class=line><span class=cl>		<span class=nf>Container</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>From</span><span class=p>(</span><span class=s>&#34;pulumi/pulumi:latest&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;PULUMI_ACCESS_TOKEN&#34;</span><span class=p>,</span> <span class=nx>pulumiToken</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;AWS_ACCESS_KEY_ID&#34;</span><span class=p>,</span> <span class=nx>awsAccessKey</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;AWS_SECRET_ACCESS_KEY&#34;</span><span class=p>,</span> <span class=nx>awsSecretKey</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithMountedDirectory</span><span class=p>(</span><span class=s>&#34;/infra&#34;</span><span class=p>,</span> <span class=nx>src</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithWorkdir</span><span class=p>(</span><span class=s>&#34;/infra&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithEntrypoint</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;/bin/bash&#34;</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=s>&#34;go mod tidy&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As you can see in the <code>container</code> function, we are using the <code>dag</code> variable that it is not really declared anywhere in this file. And there are not dependencies to Dagger either. The variable is part of <code>dagger.gen.go</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>dagger</span> <span class=nx>generated</span> <span class=nx>code</span>
</span></span></code></pre></div><p>Using dagger&rsquo;s tooling we can now easily understand what this API is capable of. We can use <code>dagger functions</code> to understand what operations it supports:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ dagger -m ./ci functions
</span></span><span class=line><span class=cl>✔ dagger functions <span class=o>[</span>0.00s<span class=o>]</span>
</span></span><span class=line><span class=cl>┃ object name   <span class=k>function</span> name   description   <span class=k>return</span> <span class=nb>type</span>
</span></span><span class=line><span class=cl>┃ *Infra        up                            String!
</span></span><span class=line><span class=cl>┃ *Infra        preview                       String!
</span></span><span class=line><span class=cl>• Engine: 03801e21c26e <span class=o>(</span>version v0.9.3<span class=o>)</span>
</span></span><span class=line><span class=cl>⧗ 2.77s ✔ <span class=m>23</span> ∅ <span class=m>2</span>
</span></span></code></pre></div><p>And what arguments a given operation requires:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ dagger -m ./ci call preview --help
</span></span><span class=line><span class=cl>✔ dagger call preview <span class=o>[</span>0.00s<span class=o>]</span>
</span></span><span class=line><span class=cl>┃ Usage:
</span></span><span class=line><span class=cl>┃   dagger call preview <span class=o>[</span>flags<span class=o>]</span>
</span></span><span class=line><span class=cl>┃
</span></span><span class=line><span class=cl>┃ Flags:
</span></span><span class=line><span class=cl>┃       --aws-access-key Secret
</span></span><span class=line><span class=cl>┃       --aws-secret-key Secret
</span></span><span class=line><span class=cl>┃       --gh-ref string
</span></span><span class=line><span class=cl>┃       --github-token Secret
</span></span><span class=line><span class=cl>┃   -h, --help                    <span class=nb>help</span> <span class=k>for</span> preview
</span></span><span class=line><span class=cl>┃       --pulumi-token Secret
</span></span><span class=line><span class=cl>┃       --repository string
</span></span><span class=line><span class=cl>┃       --src Directory
</span></span><span class=line><span class=cl>┃       --stack string
</span></span></code></pre></div><p>Now, anybody that joins this project can easily understand what our CI process does and test it locally. Now, you may have noticed that we now have a huge list of arguments compared to before. On our previous iteration we were relying on the host&rsquo;s environment variables for every single credential we required. This is how traditional CI processes work. However, Dagger functions run in a sandboxed environment. This means that everything you have in the host will not be automatically available in the execution context of the function. We have to explicitly provide the credentials as arguments now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ dagger -m ./ci call preview --src <span class=s2>&#34;.&#34;</span> --stack <span class=s2>&#34;ninjastructure/prod&#34;</span> --repository <span class=nv>$GITHUB_REPOSITORY</span> --gh-ref <span class=nv>$GITHUB_REF</span> --github-token <span class=nv>$GITHUB_TOKEN</span> --pulumi-token <span class=nv>$PULUMI_TOKEN</span> --aws-access-key <span class=nv>$AWS_ACCESS_KEY_ID</span> --aws-secret-key <span class=nv>$AWS_SECRET_ACCESS_KEY</span>
</span></span><span class=line><span class=cl>✔ dagger call preview <span class=o>[</span>1m47.6s<span class=o>]</span>
</span></span><span class=line><span class=cl>┃ Previewing update <span class=o>(</span>ninjastructure/prod<span class=o>)</span>
</span></span><span class=line><span class=cl>┃
</span></span><span class=line><span class=cl>┃ View Live: https://app.pulumi.com/ninjastructure/networking/prod/previews/81831d41-5ed0-4476-8bfa-cfa9c79f5b4f
</span></span><span class=line><span class=cl>┃
</span></span><span class=line><span class=cl>┃ go: downloading github.com/hashicorp/hcl v1.0.0
</span></span><span class=line><span class=cl>┃
</span></span><span class=line><span class=cl>┃ go: downloading google.golang.org/genproto v0.0.0-20230726155614-23370e0ffb3e
</span></span><span class=line><span class=cl>┃
</span></span><span class=line><span class=cl>┃ @ Previewing update......
</span></span><span class=line><span class=cl>┃   pulumi:pulumi:Stack: <span class=o>(</span>same<span class=o>)</span>
</span></span><span class=line><span class=cl>┃     <span class=o>[</span><span class=nv>urn</span><span class=o>=</span>urn:pulumi:prod::networking::pulumi:pulumi:Stack::networking-prod<span class=o>]</span>
</span></span><span class=line><span class=cl>┃         ~ aws:ecs/service:Service: <span class=o>(</span>update<span class=o>)</span>
</span></span><span class=line><span class=cl>┃             <span class=o>[</span><span class=nv>id</span><span class=o>=</span>arn:aws:ecs:us-west-2:831445021348:service/services-0187c44/ninjas<span class=o>]</span>
</span></span><span class=line><span class=cl>┃             <span class=o>[</span><span class=nv>urn</span><span class=o>=</span>urn:pulumi:prod::networking::awsx:ecs:FargateService<span class=nv>$aws</span>:ecs/service:Service::ninjas<span class=o>]</span>
</span></span><span class=line><span class=cl>┃             <span class=o>[</span><span class=nv>provider</span><span class=o>=</span>urn:pulumi:prod::networking::pulumi:providers:aws::default_5_35_0::321a9293-c7af-42be-a9fd-061afc82e317<span class=o>]</span>
</span></span><span class=line><span class=cl>┃           ~ networkConfiguration: <span class=o>{</span>
</span></span><span class=line><span class=cl>┃               ~ securityGroups: <span class=o>[</span>
</span></span><span class=line><span class=cl>┃                   ~ <span class=o>[</span>0<span class=o>]</span>: <span class=s2>&#34;sg-0b2ee5e5403c1ca86&#34;</span> <span class=o>=</span>&gt; <span class=s2>&#34;sg-0cf0cbf24b1e39535&#34;</span>
</span></span><span class=line><span class=cl>┃                 <span class=o>]</span>
</span></span><span class=line><span class=cl>┃             <span class=o>}</span>
</span></span><span class=line><span class=cl>┃     - aws:ec2/securityGroup:SecurityGroup: <span class=o>(</span>delete<span class=o>)</span>
</span></span><span class=line><span class=cl>┃         <span class=o>[</span><span class=nv>id</span><span class=o>=</span>sg-0b2ee5e5403c1ca86<span class=o>]</span>
</span></span><span class=line><span class=cl>┃         <span class=o>[</span><span class=nv>urn</span><span class=o>=</span>urn:pulumi:prod::networking::aws:ec2/securityGroup:SecurityGroup::svc-sg<span class=o>]</span>
</span></span><span class=line><span class=cl>┃         description        : <span class=s2>&#34;Allow TCP traffic on port 8080 from the VPC&#34;</span>
</span></span><span class=line><span class=cl>┃         egress             : <span class=o>[</span>
</span></span><span class=line><span class=cl>┃             <span class=o>[</span>0<span class=o>]</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>┃                 cidrBlocks: <span class=o>[</span>
</span></span><span class=line><span class=cl>┃                     <span class=o>[</span>0<span class=o>]</span>: <span class=s2>&#34;0.0.0.0/0&#34;</span>
</span></span><span class=line><span class=cl>┃                 <span class=o>]</span>
</span></span><span class=line><span class=cl>┃                 fromPort  : <span class=m>0</span>
</span></span><span class=line><span class=cl>┃                 protocol  : <span class=s2>&#34;-1&#34;</span>
</span></span><span class=line><span class=cl>┃                 self      : <span class=nb>false</span>
</span></span><span class=line><span class=cl>┃                 toPort    : <span class=m>0</span>
</span></span><span class=line><span class=cl>┃             <span class=o>}</span>
</span></span><span class=line><span class=cl>┃         <span class=o>]</span>
</span></span><span class=line><span class=cl>┃         ingress            : <span class=o>[</span>
</span></span><span class=line><span class=cl>┃             <span class=o>[</span>0<span class=o>]</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>┃                 cidrBlocks : <span class=o>[</span>
</span></span><span class=line><span class=cl>┃                     <span class=o>[</span>0<span class=o>]</span>: <span class=s2>&#34;10.1.0.0/16&#34;</span>
</span></span><span class=line><span class=cl>┃                 <span class=o>]</span>
</span></span><span class=line><span class=cl>┃                 description: <span class=s2>&#34;allow TCP traffic on 8080 from the VPC&#34;</span>
</span></span><span class=line><span class=cl>┃                 fromPort   : <span class=m>8080</span>
</span></span><span class=line><span class=cl>┃                 protocol   : <span class=s2>&#34;tcp&#34;</span>
</span></span><span class=line><span class=cl>┃                 self       : <span class=nb>false</span>
</span></span><span class=line><span class=cl>┃                 toPort     : <span class=m>8080</span>
</span></span><span class=line><span class=cl>┃             <span class=o>}</span>
</span></span><span class=line><span class=cl>┃         <span class=o>]</span>
</span></span><span class=line><span class=cl>┃         name               : <span class=s2>&#34;svc-sg-6648e89&#34;</span>
</span></span><span class=line><span class=cl>┃         revokeRulesOnDelete: <span class=nb>false</span>
</span></span><span class=line><span class=cl>┃         vpcId              : <span class=s2>&#34;vpc-0ec0d8d2118fc95c5&#34;</span>
</span></span><span class=line><span class=cl>┃ Resources:
</span></span><span class=line><span class=cl>┃     ~ <span class=m>1</span> to update
</span></span><span class=line><span class=cl>┃     - <span class=m>1</span> to delete
</span></span><span class=line><span class=cl>┃     <span class=m>2</span> changes. <span class=m>59</span> unchanged
</span></span><span class=line><span class=cl>• Engine: 03801e21c26e <span class=o>(</span>version v0.9.3<span class=o>)</span>
</span></span><span class=line><span class=cl>⧗ 1m50.1s ✔ <span class=m>64</span> ∅ <span class=m>8</span>
</span></span></code></pre></div><p>Running this in the CI process requires us to modify the github workflow and execute this exact same command specifying the credentials and environment variables available on the CI runner.</p><p>I believe this is a more expressive way of building CI systems. In the next section we will build this using native github actions and do a comparison of Dagger vs traditional CIs.</p><h2 id=comparing-dagger-to-traditional-ci-solutions>Comparing Dagger to traditional CI solutions<a hidden class=anchor aria-hidden=true href=#comparing-dagger-to-traditional-ci-solutions>#</a></h2><p>To have a better understanding of whether Dagger gave us a better experience and how it conceptually differentiates from traditional CIs we have to at least implement this process using github actions. We could have leveraged a github action implemented by the Pulumi team to do this preview/up process with github comments included:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Pulumi</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>pull_request</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>preview</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Preview</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/setup-go@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>go-version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;stable&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Configure AWS Credentials</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>aws-actions/configure-aws-credentials@v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>aws-access-key-id</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_ACCESS_KEY_ID }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>aws-region</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_REGION }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>aws-secret-access-key</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_SECRET_ACCESS_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>go mod download</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>pulumi/actions@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=l>preview</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>stack-name</span><span class=p>:</span><span class=w> </span><span class=l>org-name/stack-name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>comment-on-pr</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>github-token</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.GITHUB_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>PULUMI_ACCESS_TOKEN</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.PULUMI_ACCESS_TOKEN }}</span><span class=w>
</span></span></span></code></pre></div><p>There are two main differences that I see with this implementation. First of all, this is not easily testable and extensible. We could leverage something like <a href>arc</a> or <a href>gale</a> to run this process locally, but when it comes to extending we would either have to build custom actions or do some setup magic and run custom scripts on top of this yaml. Again, this is a simple process, but CI/CD often gets more complicated as time goes on. And while right now this may not seem like an obvious problem, it always ends up becoming that critical yaml file that nobody wants to touch. The second main difference is more &ldquo;conceptual&rdquo; but it is important to point out because it requires a mindset shift when it comes to building CI. In the traditional pipeline, we can see a &ldquo;statefull&rdquo; approach, where each of the steps that are being executed are doing explicit things on the host (i.e the runner) that the subsequent action then reuses:</p><ol><li>Checkout the code of the repository</li><li>Install the latest stable version of Go</li><li>Configure AWS&rsquo;s credentials (technically not needed, we could use env variables directly&mldr;)</li><li>Download go dependencies that pulumi&rsquo;s code uses.</li><li>Run pulumi preview</li></ol><p>Every single one of those actions changed the underlying host in some way and left a state that the subsequent action would then use. This means that when you build a workflow you always operate directly on the host instead of &ldquo;chaining&rdquo; inputs/outputs like you do when building a dag, for example an Airflow dag. I don&rsquo;t particularly like this approach, it is one of the main things that makes this processed hard to test and more importantly very hard to understand.</p><p>With dagger modules we saw a different approach. When we were calling the function of the module, we had to explicitly provide all the required resources to perform the <code>preview</code> or <code>up</code> operation. This is because, as we mentioned previously, dagger functions run in a sandboxed environment that could even be executed on a different host! This, in my opinion, opens up interesting possibilities for building CI pipelines using reusable APIs that are deployed once and used everywhere. There might be occasions where this stateless approach falls short, but this new approach is only getting started. I think there is a lot of similarity with how the data world works. When you build data pipelines using tools like Airflow, the worker where the operator code gets executed usually only performs HTTP calls. For example, if you build a data pipeline that performs some data transformation using spark on EMR and then ingests that data on a datasource like clickhouse, your Airflow DAG will probably look something like this:</p><ol><li>Use EMR Operator to execute some spark code. Airflow&rsquo;s worker will call AWS&rsquo;s API, ask for a given script to be executed and then wait for completion.</li><li>Use an ECS task or similar to run code that reads the data from S3 and ingest it into clickhouse.</li></ol><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Dagger offers a compelling alternative to yaml and custom scripts in CI/CD pipelines. By leveraging code, we gain expressiveness, reusability, and the ability to integrate with a wide range of tools and services. As Dagger matures, I&rsquo;m excited to see how it will continue to evolve and improve CI/CD practices.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.matiaspan.dev/tags/pulumi/>pulumi</a></li><li><a href=https://blog.matiaspan.dev/tags/go/>go</a></li><li><a href=https://blog.matiaspan.dev/tags/aws/>aws</a></li><li><a href=https://blog.matiaspan.dev/tags/dagger/>dagger</a></li><li><a href=https://blog.matiaspan.dev/tags/ci/cd/>ci/cd</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Streamlining CI/CD with Dagger: Beyond YAML on x" href="https://x.com/intent/tweet/?text=Streamlining%20CI%2fCD%20with%20Dagger%3a%20Beyond%20YAML&amp;url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fstreamlining-ci-cd-with-dagger-beyond-yaml%2f&amp;hashtags=pulumi%2cgo%2caws%2cdagger%2cci%2fcd"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Streamlining CI/CD with Dagger: Beyond YAML on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fstreamlining-ci-cd-with-dagger-beyond-yaml%2f&title=Streamlining%20CI%2fCD%20with%20Dagger%3a%20Beyond%20YAML"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Streamlining CI/CD with Dagger: Beyond YAML on ycombinator" href="https://news.ycombinator.com/submitlink?t=Streamlining%20CI%2fCD%20with%20Dagger%3a%20Beyond%20YAML&u=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fstreamlining-ci-cd-with-dagger-beyond-yaml%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.matiaspan.dev/>Matias Pan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>