<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Exploring Dagger: Streamlining CI/CD Pipelines with Code ‚Äì A Developer's Guide | Matias Pan's blog</title>
<meta name=keywords content="go,dagger,ci/cd,exploring-dagger"><meta name=description content="This is the second post in a series of blog posts that look at Dagger from different perspectives. In this post we do a deep dive on how to leverage Dagger as a developer that is tasked with implementing the CI process of a Java-Gradle service. In this CI process we need to: build, run integration tests with external dependencies and package the service. We will leave the CD part for a future blog post that looks at Dagger from the perspective of a Platform Engineer/SRE."><meta name=author content="matipan"><link rel=canonical href=https://blog.matiaspan.dev/posts/exploring-dagger-streamlining-ci-cd-pipelines-with-code/><link crossorigin=anonymous href=/assets/css/stylesheet.a801c217e3c96db9c9df36cb1d2216a9bc5d9fa77b72e2afcdf47fb847f8f015.css integrity="sha256-qAHCF+PJbbnJ3zbLHSIWqbxdn6d7cuKvzfR/uEf48BU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Exploring Dagger: Streamlining CI/CD Pipelines with Code ‚Äì A Developer's Guide"><meta property="og:description" content="This is the second post in a series of blog posts that look at Dagger from different perspectives. In this post we do a deep dive on how to leverage Dagger as a developer that is tasked with implementing the CI process of a Java-Gradle service. In this CI process we need to: build, run integration tests with external dependencies and package the service. We will leave the CD part for a future blog post that looks at Dagger from the perspective of a Platform Engineer/SRE."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.matiaspan.dev/posts/exploring-dagger-streamlining-ci-cd-pipelines-with-code/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-19T00:00:00-03:00"><meta property="article:modified_time" content="2023-11-19T00:00:00-03:00"><meta property="og:site_name" content="Matias Pan's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Exploring Dagger: Streamlining CI/CD Pipelines with Code ‚Äì A Developer's Guide"><meta name=twitter:description content="This is the second post in a series of blog posts that look at Dagger from different perspectives. In this post we do a deep dive on how to leverage Dagger as a developer that is tasked with implementing the CI process of a Java-Gradle service. In this CI process we need to: build, run integration tests with external dependencies and package the service. We will leave the CD part for a future blog post that looks at Dagger from the perspective of a Platform Engineer/SRE."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.matiaspan.dev/posts/"},{"@type":"ListItem","position":2,"name":"Exploring Dagger: Streamlining CI/CD Pipelines with Code ‚Äì A Developer's Guide","item":"https://blog.matiaspan.dev/posts/exploring-dagger-streamlining-ci-cd-pipelines-with-code/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Exploring Dagger: Streamlining CI/CD Pipelines with Code ‚Äì A Developer's Guide","name":"Exploring Dagger: Streamlining CI\/CD Pipelines with Code ‚Äì A Developer\u0027s Guide","description":"This is the second post in a series of blog posts that look at Dagger from different perspectives. In this post we do a deep dive on how to leverage Dagger as a developer that is tasked with implementing the CI process of a Java-Gradle service. In this CI process we need to: build, run integration tests with external dependencies and package the service. We will leave the CD part for a future blog post that looks at Dagger from the perspective of a Platform Engineer/SRE.","keywords":["go","dagger","ci/cd","exploring-dagger"],"articleBody":"This is the second post in a series of blog posts that look at Dagger from different perspectives. In this post we do a deep dive on how to leverage Dagger as a developer that is tasked with implementing the CI process of a Java-Gradle service. In this CI process we need to: build, run integration tests with external dependencies and package the service. We will leave the CD part for a future blog post that looks at Dagger from the perspective of a Platform Engineer/SRE. We are going to build this with traditional tools like docker-compose and with Dagger modules and then compare the two approaches.\nNOTE: Dagger is in very active development so by the time you read this blog post some things might have changed.\nBackground We suddenly land on a team that is the owner of a Spring-Boot service that uses gradle as its build tool and we are tasked to build the CI process for this service. The first we think about when we look at this codebase is that we should rewrite it in Go. But we are going to decide to push that thought aside for a bit and be productive ü§µ. This service is part of an E-Commerce system and is used primarily for filtering orders that are stored inside a MySQL database. It exposes one important endpoint that accepts a list of filters and returns the orders that match those filters. For example:\nGET /orders?page=1\u0026status=open\u0026shipping_method=43123 { \"orders\": [ { \"id\": 1234, \"status\": \"open\", \"shipping_method\": 43123, \"payment_status\": \"pending\", \"fulfillment_status\": \"unfulfilled\" }, { \"id\": 1235, \"status\": \"open\", \"shipping_method\": 43123, \"payment_status\": \"paid\", \"fulfillment_status\": \"fulfilled\" } ] } The service has not yet reached production but we know this endpoint will be very critical. It has to be consistent, meaning that if I specify status=open as a filter, it should only return orders that match that status. If we break this constraint we are going to be in big trouble. To guarantee that we never merge or deploy code that breaks this constraint we decide is best to build a few black-box integration tests that validate the behavior of the entire system. We are going to start our service and its dependencies and execute a program that makes HTTP requests with different filters and validates that the responses match what we expect. We want developers to be able to run this tests locally but we also want to make them a hard constraint on our CI, so we need to run them there as well. For the sake of keeping this blog post focused on the CI part, I‚Äôll share just a snippet of what this integration tests look like. In our repository we created a tests folder and wrote a main.go file that does what we just mentioned. Here is a snippet of what this program looks like:\nvar endpoint = flag.String(\"endpoint\", \"localhost:8080\", \"service endpoint\") func main() { flag.Parse() if err := OrdersList(*endpoint); err != nil { log.Fatalf(\"tests failed: %s\", err) } } func OrdersList(endpoint string) error { tests := []struct { name string filters Filters }{ { name: \"open\", filters: Filters{ Status: OrderStatusOpen, }, }, { name: \"open paid\", filters: Filters{ Status: OrderStatusOpen, PaymentStatus: PaymentStatusPaid, }, }, // more test cases } errs := []error{} for _, test := range tests { name := test.name filters := test.filters // create HTTP request and send it using Go's standard library // validate the response if err = validateResponse(filters, response.Orders); err != nil { errs = append(errs, testErr(name, fmt.Errorf(\"response for filters is invalid: %v.\\n\\tResponse: %+v\\n\\tFilters: %+v\", err, response.Orders, filters))) continue } } if len(errs) == 0 { return nil } rerr := errors.New(\"tests have failed\") for _, err := range errs { rerr = fmt.Errorf(\"%s\\n\\t%s\", rerr, err.Error()) } return rerr } func testErr(name string, err error) error { return fmt.Errorf(\"‚ùå test %s failed. Error: %w\", name, err) } func validateResponse(filters Filters, orders []*Order) error { for _, order := range orders { // validate that the orders respect the filters that were specified // if it is not the case then we return an error } return nil } With this program developers can start their local environment and run go run ./tests/main.go -endpoint=localhost:.\nIn summary, we want to build a reproducible way to:\nbuild and package our service run unit tests run integration tests that require the service and its dependencies to be running So that we can then build a CI process that integrates all of it.\nUsing docker and docker-compose Let‚Äôs start building this using the tools you are probably already familiar with: docker and docker-compose. To build and package our service we first write a Dockerfile that:\nStarts from an image with the Java version we require already installed. Copies all of our required files and folders. Performs a gradle build using the gradle wrapper. Starts a new stage from an image with Java installed. Installs critical dependencies that are often used to troubleshoot. Copies over the .jar generated in the previous stage. Defines a command for running the service. FROM amazoncorretto:21.0.1-alpine3.18 AS base WORKDIR /app COPY src src COPY gradlew gradlew COPY gradle gradle COPY build.gradle.kts build.gradle.kts COPY settings.gradle.kts settings.gradle.kts FROM base AS build RUN [\"./gradlew\", \"clean\", \"build\", \"--no-daemon\"] FROM amazoncorretto:21.0.1-alpine3.18 AS runtime RUN apk update \u0026\u0026 apk --no-cache add ca-certificates curl tcpdump procps bind-tools RUN mkdir -p /var/log/spring WORKDIR /app COPY --from=build /app/build/libs/gradle-service-0.0.1-SNAPSHOT.jar app.jar ENV APP_PROFILE=\"default\" ENV JAVA_OPTS=\"\" CMD java $JAVA_OPTS -jar app.jar --server.port=80 --spring.profiles.active=$APP_PROFILE In this Dockerfile we are leveraging Docker‚Äôs multi stage capabilities to reduce the final size of our image and only ship the things that we need.\nWith this defined developers can now build and run the service locally without having to install java, gradle and such:\ndocker build -t gradle-service . docker run -p 8080:8080 -e APP_PROFILE=local gradle-service How about running unit tests? Well, in our Dockerfile you probably saw that we first defined a stage called base were we mounted the code of our application. This was done to re-use the Dockerfile for running our unit tests. We can do this by leveraging BuildKit‚Äôs ability to target specific stages like so:\ndocker build -t gradle-service-base --target base . docker run -e APP_PROFILE=test gradle-service-base ./gradlew clean test With this approach we were able to containerize our build and test so that these processes run in the exact same way on all machines. Something I‚Äôve seen quite frequently, specially in the Java ecosystem, is that developers usually run build and test commands in their CI workflows by re-using whatever abstraction the CI runtime provides. For example, in the case of Github workflows I‚Äôve seen people often use the gradle action to run gradle commands directly in their CI. What usually ends up happening is that the action sets things up in a different way and then tests end up failing in the CI but not in the local environment of the developer. Leaving people confused and forced to ignore the tests in that PR because who has time to debug the CI?\nNow for the interesting part: integration tests. We mentioned previously that our service uses MySQL to store and retrieve the orders it is requested. To be able to run this integration tests we need to have MySQL running and the service connected to it. Since we want this to be reproducible and run in our CI as well we will leverage docker-compose:\nversion: '3.9' services: mysql: image: mysql:8.2.0 container_name: mysql environment: - MYSQL_ROOT_PASSWORD=password - MYSQL_DATABASE=database volumes: - ./db/db.sql:/docker-entrypoint-initdb.d/db.sql ports: - 3306:3306 healthcheck: test: [\"CMD\", \"mysqladmin\" ,\"ping\", \"-h\", \"localhost\"] timeout: 5s retries: 10 networks: [\"service\"] service: build: . container_name: service environment: - \"DB_HOST=mysql\" - \"DB_PORT=3306\" - \"APP_PROFILE=default\" ports: - 8080:80 depends_on: mysql: condition: service_healthy links: - \"mysql:mysql\" networks: [\"service\"] networks: service: Let‚Äôs quickly go over what this docker-compose file has:\nservice: the definition of our service that will trigger a build when we run it (this is because we specified the build: . to docker-compose). We added a depends_on to MySQL with a service_healthy condition so that the service is only started once MySQL is up and accepting connections. mysql: a service that runs a MySQL 8 server with an SQL file mounted to seed some data for our tests. We specified a healthcheck that uses mysqladmin so that the service connects to it only once MySQL is ready for connections. We can now start our services locally and in any other environment by running docker-compose up.\nTime to add our integration tests. We also want these tests to be able to run in any host without requiring that host to have dependencies installed (other than the ability to run containers of course). For this reason we start writing a Dockerfile inside our tests folder:\nFROM golang:1.21-alpine WORKDIR /app COPY main.go main.go CMD go run main.go -endpoint $ENDPOINT Quite simple: we want Go and we want to execute our tests. We don‚Äôt care about publishing this image so no need to optimize it with multi-stage builds.\nWith this new dockerfile and our docker-compose we can now execute our tests. However, since everything is dockerized we need to run the container for our tests in the same network as the service is running so that it can access its endpoint. We also need to wait a bit until the service is running before triggering our tests:\n$ docker-compose up -d # You should wait for the service to be up and running $ cd tests \u0026\u0026 docker build -t tests . $ docker run --network dagger-developer-perspective_service -e \"ENDPOINT=service:80\" --rm --name tests tests 2023/11/19 14:22:37 running validation for: open 2023/11/19 14:22:37 running validation for: open paid 2023/11/19 14:22:37 running validation for: open pending 2023/11/19 14:22:37 running validation for: open paid unpacked 2023/11/19 14:22:37 running validation for: open paid unpacked shippingMethod:table 2023/11/19 14:22:37 running validation for: open paid unpacked completedAtFrom completedAtTo 2023/11/19 14:22:37 running validation for: open paid and pending We are now ready to build our Github workflow that re-uses what we built here.\nBuilding our CI workflow I won‚Äôt go over too much detail here on the syntax for Github workflows. We want our workflow to run only on pull requests that are made against our main branch and we want it to:\nRun unit tests Build the service Run integration tests As we saw previously, building the sevice already happens when we do a docker-compose up so we only need to take care of the other two:\nname: 'pull request' on: pull_request: branches: - main jobs: build-and-test: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 - name: Build the base image run: docker build -t gradle-service-base --target base . - name: Run unit tests run: docker run gradle-service-base ./gradlew clean test - name: Start services run: docker-compose up -d - name: Check service health run: ./tests/check_health.sh - name: Run integration tests working-directory: tests run: docker build -t tests . \u0026\u0026 docker run --network dagger-developer-perspective_service -e \"ENDPOINT=service:80\" --rm --name tests tests - name: Tear down run: docker-compose down In this CI workflow we are:\nBuilding the base image that we can then use to run our tests Using the base image to run our tests Starting the service and database with docker-compose Running a script that checks the health of the service so that we run our integration tests once the service is up Building the container image for our tests and running them in the same network as the service Tearing down our service and database You can see that we added a new step that previously was done manually: service healthcheck. This is so that the integration tests only run once the service is ready:\n#!/bin/bash max_attempts=5 for (( i=1; i\u003c=max_attempts; i++ )) do response=$(curl -o /dev/null -s -w \"%{http_code}\\n\" http://localhost:8080/health) if [ \"$response\" -eq 200 ]; then echo \"Server is up and running.\" exit 0 else echo \"Attempt $i: Server not responding, retrying in 5 seconds...\" sleep 5 fi done echo \"All attempts failed, exiting with code 1.\" exit 1 Now we can push our branch, create a pull request and see that our CI workflow is running successfully: Thoughts There were quite a few things we had to build in order to make this happen, and they were all a bit scattered:\nA Dockerfile for the service A Dockerfile for the integration tests A docker-compose.yaml to run the services in a reproducible way A check_health.sh to check the health of the service before running our integration tests The .github/workflows/pr.yaml that glues everything together. Developing this wasn‚Äôt as ‚Äúsmooth‚Äù as I wrote it here. There were many mistakes I made in the middle that forced me to iterate a bit on how things would run locally and how they would run in the CI, for example the check_health.sh was only necessary in the CI. Having to define 3 stages in order to be able to run the tests in a dockerized way is also something that I haven‚Äôt seen people often do, they just rely on their CI runtime to also install dependencies and pray it does not break. I also had to play around with how to connect containers together so that our integraion tests can actually access the service. My developer experience here, in my opinion, wasn‚Äôt great. Probably no developer in the team will do a docker build \u0026\u0026 docker run locally to run their tests, it requires more effort and steps than simply using their tool of choice (in this case gradle). If the CI ever breaks, it will probably go ignored until someone decides to be unhappy for a bit and fix it.\nUsing Dagger modules Can Dagger provide a better experience for building this? Let‚Äôs give it a try!\nQuick intro: Dagger allows you to define the entire lifecycle of your application (building, testing, packaging, etc) using code with one of the supported languages. Instead of having to write Dockerfiles and docker-compose files, you write everything in a Dagger module with your programming language of choice. Internally, Dagger leverages BuildKit and containers to make sure that the code you are writing runs anywhere in the exact the same way.\nSo, what do we do first? We initialize a Dagger module in our repository that will hold all the code required to build what we built before. Lets start by creating a ci folder and create a new Dagger module that will use Go:\nmkdir ci \u0026\u0026 cd ci dagger module init --name gradle-service --sdk go Quickly inspecting the contents of the program that dagger generated we can see that it is using an object called dag to create containers and perform actions on them:\npackage main import ( \"context\" ) type GradleService struct {} // example usage: \"dagger call container-echo --string-arg yo\" func (m *GradleService) ContainerEcho(stringArg string) *Container { return dag.Container().From(\"alpine:latest\").WithExec([]string{\"echo\", stringArg}) } // example usage: \"dagger call grep-dir --directory-arg . --pattern GrepDir\" func (m *GradleService) GrepDir(ctx context.Context, directoryArg *Directory, pattern string) (string, error) { return dag.Container(). From(\"alpine:latest\"). WithMountedDirectory(\"/mnt\", directoryArg). WithWorkdir(\"/mnt\"). WithExec([]string{\"grep\", \"-R\", pattern, \".\"}). Stdout(ctx) } We can leverage dagger‚Äôs CLI to explore what the module can actually do, from the root of the repository we can run dagger -m ./ci functions and then try some of the already provided examples:\nLet‚Äôs start re-writing our module to build and test our service.Now, the interesting thing about Dagger is that modules can be published and re-used by others no matter what programming language was used to write the module, this means you can use a Go module from within a Python one. At the time of this writing modules are published at the daggerverse. If we look in the Daggerverse we can see that someone already developed a module to running gradle commands: We can leverage this module to execute the build and test commands. To use it we simply have to import it by running dagger mod use github.com/matipan/daggerverse/gradle. If you inspect the module with dagger -m github.com/matipan/daggerverse/gradle functions you‚Äôll see, among other things, that we can define what version of the gradle image to start from. In our case we are using the JDK 21. Let‚Äôs write our Build and Test functions with this in mind:\npackage main import ( \"context\" \"fmt\" \"log\" ) var GradleVersion = \"jdk21-alpine\" type GradleService struct { Source *Directory gradle *Gradle } func (m *GradleService) WithSource(src *Directory) *GradleService { m.Source = src return m } func (m *GradleService) Build(ctx context.Context) *Container { return m.getGradle(m.Source).Build() } func (m *GradleService) Test(ctx context.Context) *Container { return m.getGradle(m.Source).Test() } func (m *GradleService) getGradle(src *Directory) *Gradle { if m.gradle != nil { return m.gradle } m.gradle = dag.Gradle(). FromVersion(GradleVersion). WithDirectory(src). WithWrapper() return m.gradle } Let‚Äôs go over what we did here:\nWithSource: all Dagger calls run inside a sandboxed environment, so we need to explicitly provide things such as folders and env variables to the commands. getGradle: this function creates a reference to the Gradle module, specifying the version and configuring it to use the gradle wrapper. Build and Test: in this functions we simply obtain a reference to the Gradle module with our src directory mounted and run the specific operation there. We can now try our build function by running dagger -m ./ci call with-source --src \".\" build:\nIn the Build function we are only executing a ./gradlew clean build, we can‚Äôt really build a final image from the output of this command. With Dockerfiles we created a multi-stage build to separate our runtime from our build. With Dagger we can do the same thing:\nfunc (m *GradleService) BuildRuntime(ctx context.Context) *Container { ctr, err := m.Build(ctx).Sync(ctx) if err != nil { log.Fatalf(\"build failed: %s\", err) } return dag.Container(). From(\"amazoncorretto:21.0.1-alpine3.18\"). WithExec([]string{\"apk\", \"update\", \"\u0026\u0026\", \"apk\", \"--no-cache\", \"add\", \"ca-certificates\", \"curl\", \"tcpdump\", \"procps\", \"bind-tools\"}). WithWorkdir(\"/app\"). WithFile(\"app.jar\", ctr.File(\"build/libs/gradle-service-0.0.1-SNAPSHOT.jar\")). WithEntrypoint([]string{\"sh\", \"-c\", \"java $JAVA_OPTS -jar app.jar --server.port=80 --spring.profiles.active=default\"}) } You can see that from BuildRuntime we are calling the Build function defined previously. We then generate a new container that starts from amazoncorretto:21.0.1-alpine3.18 and mounts the application jar found in the container returned by build.\nSo far we‚Äôve only done Build, BuildRuntime and Test. But we also want to run integration tests and have everything integrated into Dagger. To do this we need a way to run the service and a MySQL server. Well, we are in luck. Dagger has native support for Services. With Dagger, we can define a container as a service and then use the dagger up command to start the service and its dependencies. All we have to do is write functions that return the *Service type:\nfunc (m *GradleService) Service(ctx context.Context, sqlInitDB *File) *Service { runtime := m.BuildRuntime(ctx) return runtime. WithEnvVariable(\"DB_HOST\", \"mysql\"). WithEnvVariable(\"DB_PORT\", \"3306\"). WithServiceBinding(\"mysql\", m.Mysql(ctx, sqlInitDB)). WithExposedPort(80). WithExec([]string{\"sh\", \"-c\", \"java $JAVA_OPTS -jar app.jar --server.port=80 --spring.profiles.active=default\"}). AsService() } func (m *GradleService) Mysql(ctx context.Context, sqlInitDB *File) *Service { return dag.Container(). From(\"mysql:8.2.0\"). WithEnvVariable(\"MYSQL_ROOT_PASSWORD\", \"password\"). WithEnvVariable(\"MYSQL_DATABASE\", \"database\"). WithFile(\"/docker-entrypoint-initdb.d/db.sql\", sqlInitDB). WithExposedPort(3306). AsService() } Lets break this code down:\nIn the Service function we first call the BuildRuntime to generate a container that has our jar ready to be executed. We then create a new container that defines a mysql ServiceBinding to whatever Service the Mysql function returns. The Mysql function returns MySQL 8 container with our seed file ready to populate the DB when it starts. Now we can use the up command to start the service and its dependencies locally dagger -m ./ci up with-source --src \".\" service --sql-init-db \"db/db.sql\":\nDagger makes sure that the services are healthy before they connect to each other. All this runs in containers isolated in their own environments. This means that we can run this same command in other machines and expect it will work correctly.\nTo run the integration tests we can create a function that leverages the concept of services and the fact that the entire definition of the containers are in this same codebase. We can create a container from a specific go version and create a service binding to the service itself:\nfunc (m *GradleService) IntegrationTests(ctx context.Context, tests *Directory, sqlInitDB *File) (string, error) { return dag.Go(). FromVersion(\"1.21-alpine\"). WithSource(tests). Container(). WithServiceBinding(\"service\", m.Service(ctx, sqlInitDB)). WithExec([]string{\"go\", \"run\", \"main.go\", \"--endpoint\", \"service:80\"}). Stdout(ctx) } In this function we expect to receive the directory that holds the tests, the database file used to seed the db and we return the output that the command generates. We can now use dagger‚Äôs CLI to call this function and run the integration tests, all containerized and defined within a single codebase:\nBuilding our CI workflow Let‚Äôs put all of this together in our CI workflow. This is where Dagger shines in my opinion. We don‚Äôt have to do anything special to make sure this works in our CI environment. We just need to install the dagger CLI and run the exact same command developers run locally:\nname: 'pull request' on: pull_request: branches: - master - main - develop jobs: build-and-test: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 - name: Install Dagger CLI run: cd /usr/local \u0026\u0026 { curl -L https://dl.dagger.io/dagger/install.sh | sh; cd -; } - name: Test run: dagger -m ./ci call with-source --src \".\" test - name: Integration test run: dagger -m ./ci call with-source --src \".\" integration-tests --tests \"./tests\" --sql-init-db \"./db/db.sql\" And we are done! Less YAML and no surprises. Here is the pipeline working as we expected:\nThoughts Through the use of code and Dagger‚Äôs capabilities for running containerized services and commands we were able to build our entire CI workflow in a programmatic way inside a single Go file. Here is an overview of what we needed to write in order to make this work:\nNotice how we wrote all the important bits directly in code, no need for YAML and config files like Dockerfiles. Even though there are a few rough edges in Dagger (mainly due to how new it is) I personally believe this is a much better experience than what we had before. We wrote the entire definition of our CI using code and we were able to validate every single part of it locally. If we compare to how we could run the tests before, we now have an DX that developers can definitely use: dagger -m ./ci call with-source --src \".\" test.\nConclusion In this blog post we compared the experience of using traditional tools like docker-compose with Dagger for building a CI workflow that builds and tests a Java-Gradle service. We saw how with docker and docker-compose we had to write a lot of configuration files and YAML to glue things together in a way that was not easily reproducible. Meaning that developers would run things locally in a way that would be different to how the CI would work. However, with Dagger we saw that it was no longer necessary to write this config and YAMl files. Instead, we built everything using Go code, we leveraged Dagger‚Äôs native support for running services and we glued everything together in a programmatic but still declarative way. We were then able to run this code in the CI in the exact same way that we run it locally.\nI personally believe there is still a bit of a learning curve to Dagger. It requires a mindset shift in order to stop thinking that this processes should be written and defined with configuration ‚Äúlanguages‚Äù such as YAML and dockerfile. However, I think Dagger provides a lot of power with it‚Äôs code-first approach and its ecosystem that will only get bigger and better. It‚Äôs interesting how easily it integrates with existing CI systems and gives a developer experience that allows us to treat pipelines as software and write them using our editors and IDEs.\n","wordCount":"3916","inLanguage":"en","datePublished":"2023-11-19T00:00:00-03:00","dateModified":"2023-11-19T00:00:00-03:00","author":{"@type":"Person","name":"matipan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.matiaspan.dev/posts/exploring-dagger-streamlining-ci-cd-pipelines-with-code/"},"publisher":{"@type":"Organization","name":"Matias Pan's blog","logo":{"@type":"ImageObject","url":"https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.matiaspan.dev/ accesskey=h title="Home (Alt + H)"><img src=https://blog.matiaspan.dev/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.matiaspan.dev/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.matiaspan.dev/search/ title=Search><span>Search</span></a></li><li><a href=https://blog.matiaspan.dev/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.matiaspan.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Exploring Dagger: Streamlining CI/CD Pipelines with Code ‚Äì A Developer's Guide</h1><div class=post-meta><span title='2023-11-19 00:00:00 -0300 -03'>November 19, 2023</span>&nbsp;¬∑&nbsp;19 min&nbsp;¬∑&nbsp;matipan&nbsp;|&nbsp;<a href=https://github.com/matipan/matipan.github.io/tree/main/content/posts/exploring-dagger-streamlining-ci-cd-pipelines-with-code.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#using-docker-and-docker-compose>Using docker and docker-compose</a><ul><li><a href=#building-our-ci-workflow>Building our CI workflow</a></li><li><a href=#thoughts>Thoughts</a></li></ul></li><li><a href=#using-dagger-modules>Using Dagger modules</a><ul><li><a href=#building-our-ci-workflow-1>Building our CI workflow</a></li><li><a href=#thoughts-1>Thoughts</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p>This is the second post in a <a href=https://blog.matiaspan.dev/tags/exploring-dagger/>series of blog posts</a> that look at Dagger from different perspectives. In this post we do a deep dive on how to leverage Dagger as a developer that is tasked with implementing the CI process of a Java-Gradle service. In this CI process we need to: build, run integration tests with external dependencies and package the service. We will leave the CD part for a future blog post that looks at Dagger from the perspective of a Platform Engineer/SRE. We are going to build this with traditional tools like docker-compose and with Dagger modules and then compare the two approaches.</p><p><strong>NOTE</strong>: Dagger is in very active development so by the time you read this blog post some things might have changed.</p><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><p>We suddenly land on a team that is the owner of a Spring-Boot service that uses gradle as its build tool and we are tasked to build the CI process for this service. The first we think about when we look at this codebase is that we should rewrite it in Go. But we are going to decide to push that thought aside for a bit and be productive ü§µ. This service is part of an E-Commerce system and is used primarily for filtering orders that are stored inside a MySQL database. It exposes one important endpoint that accepts a list of filters and returns the orders that match those filters. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=err>GET</span> <span class=err>/orders?page=</span><span class=mi>1</span><span class=err>&amp;status=open&amp;shipping_method=</span><span class=mi>43123</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;orders&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=mi>1234</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;open&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;shipping_method&#34;</span><span class=p>:</span> <span class=mi>43123</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;payment_status&#34;</span><span class=p>:</span> <span class=s2>&#34;pending&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;fulfillment_status&#34;</span><span class=p>:</span> <span class=s2>&#34;unfulfilled&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=mi>1235</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;open&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;shipping_method&#34;</span><span class=p>:</span> <span class=mi>43123</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;payment_status&#34;</span><span class=p>:</span> <span class=s2>&#34;paid&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;fulfillment_status&#34;</span><span class=p>:</span> <span class=s2>&#34;fulfilled&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The service has not yet reached production but we know this endpoint will be very critical. It has to be consistent, meaning that if I specify <code>status=open</code> as a filter, it should only return orders that match that status. If we break this constraint we are going to be in big trouble. To guarantee that we never merge or deploy code that breaks this constraint we decide is best to build a few black-box integration tests that validate the behavior of the entire system. We are going to start our service and its dependencies and execute a program that makes HTTP requests with different filters and validates that the responses match what we expect. We want developers to be able to run this tests locally but we also want to make them a hard constraint on our CI, so we need to run them there as well. For the sake of keeping this blog post focused on the CI part, I&rsquo;ll share just a snippet of what this integration tests look like. In our repository we created a <code>tests</code> folder and wrote a <code>main.go</code> file that does what we just mentioned. Here is a snippet of what this program looks like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>endpoint</span> <span class=p>=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>String</span><span class=p>(</span><span class=s>&#34;endpoint&#34;</span><span class=p>,</span> <span class=s>&#34;localhost:8080&#34;</span><span class=p>,</span> <span class=s>&#34;service endpoint&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>flag</span><span class=p>.</span><span class=nf>Parse</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>OrdersList</span><span class=p>(</span><span class=o>*</span><span class=nx>endpoint</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;tests failed: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>OrdersList</span><span class=p>(</span><span class=nx>endpoint</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>tests</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>name</span>    <span class=kt>string</span>
</span></span><span class=line><span class=cl>		<span class=nx>filters</span> <span class=nx>Filters</span>
</span></span><span class=line><span class=cl>	<span class=p>}{</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>name</span><span class=p>:</span> <span class=s>&#34;open&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>filters</span><span class=p>:</span> <span class=nx>Filters</span><span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>Status</span><span class=p>:</span> <span class=nx>OrderStatusOpen</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=p>},</span>
</span></span><span class=line><span class=cl>		<span class=p>},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>name</span><span class=p>:</span> <span class=s>&#34;open paid&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>filters</span><span class=p>:</span> <span class=nx>Filters</span><span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>Status</span><span class=p>:</span>        <span class=nx>OrderStatusOpen</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nx>PaymentStatus</span><span class=p>:</span> <span class=nx>PaymentStatusPaid</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=p>},</span>
</span></span><span class=line><span class=cl>		<span class=p>},</span>
</span></span><span class=line><span class=cl>		<span class=c1>// more test cases
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>errs</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>error</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>test</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>tests</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>name</span> <span class=o>:=</span> <span class=nx>test</span><span class=p>.</span><span class=nx>name</span>
</span></span><span class=line><span class=cl>		<span class=nx>filters</span> <span class=o>:=</span> <span class=nx>test</span><span class=p>.</span><span class=nx>filters</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// create HTTP request and send it using Go&#39;s standard library
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=c1>// validate the response
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nf>validateResponse</span><span class=p>(</span><span class=nx>filters</span><span class=p>,</span> <span class=nx>response</span><span class=p>.</span><span class=nx>Orders</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>errs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>errs</span><span class=p>,</span> <span class=nf>testErr</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;response for filters is invalid: %v.\n\tResponse: %+v\n\tFilters: %+v&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>,</span> <span class=nx>response</span><span class=p>.</span><span class=nx>Orders</span><span class=p>,</span> <span class=nx>filters</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>errs</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>rerr</span> <span class=o>:=</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;tests have failed&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>errs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>rerr</span> <span class=p>=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;%s\n\t%s&#34;</span><span class=p>,</span> <span class=nx>rerr</span><span class=p>,</span> <span class=nx>err</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>rerr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>testErr</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;‚ùå test %s failed. Error: %w&#34;</span><span class=p>,</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>validateResponse</span><span class=p>(</span><span class=nx>filters</span> <span class=nx>Filters</span><span class=p>,</span> <span class=nx>orders</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Order</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>order</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>orders</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// validate that the orders respect the filters that were specified
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// if it is not the case then we return an error
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>With this program developers can start their local environment and run <code>go run ./tests/main.go -endpoint=localhost:&lt;PORT></code>.</p><p>In summary, we want to build a reproducible way to:</p><ul><li>build and package our service</li><li>run unit tests</li><li>run integration tests that require the service and its dependencies to be running</li></ul><p>So that we can then build a CI process that integrates all of it.</p><h2 id=using-docker-and-docker-compose>Using docker and docker-compose<a hidden class=anchor aria-hidden=true href=#using-docker-and-docker-compose>#</a></h2><p>Let&rsquo;s start building this using the tools you are probably already familiar with: docker and docker-compose. To build and package our service we first write a Dockerfile that:</p><ul><li>Starts from an image with the Java version we require already installed.</li><li>Copies all of our required files and folders.</li><li>Performs a gradle build using the gradle wrapper.</li><li>Starts a new stage from an image with Java installed.</li><li>Installs critical dependencies that are often used to troubleshoot.</li><li>Copies over the .jar generated in the previous stage.</li><li>Defines a command for running the service.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> amazoncorretto:21.0.1-alpine3.18 AS base</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> src src<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> gradlew gradlew<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> gradle gradle<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> build.gradle.kts build.gradle.kts<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> settings.gradle.kts settings.gradle.kts<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> base AS build</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=o>[</span><span class=s2>&#34;./gradlew&#34;</span>, <span class=s2>&#34;clean&#34;</span>, <span class=s2>&#34;build&#34;</span>, <span class=s2>&#34;--no-daemon&#34;</span><span class=o>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> amazoncorretto:21.0.1-alpine3.18 AS runtime</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apk update <span class=o>&amp;&amp;</span> apk --no-cache add ca-certificates curl tcpdump procps bind-tools<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> mkdir -p /var/log/spring<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>build /app/build/libs/gradle-service-0.0.1-SNAPSHOT.jar app.jar<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>APP_PROFILE</span><span class=o>=</span><span class=s2>&#34;default&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>JAVA_OPTS</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> java <span class=nv>$JAVA_OPTS</span> -jar app.jar --server.port<span class=o>=</span><span class=m>80</span> --spring.profiles.active<span class=o>=</span><span class=nv>$APP_PROFILE</span><span class=err>
</span></span></span></code></pre></div><p>In this Dockerfile we are leveraging Docker&rsquo;s multi stage capabilities to reduce the final size of our image and only ship the things that we need.</p><p>With this defined developers can now build and run the service locally without having to install java, gradle and such:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>docker build -t gradle-service .
</span></span><span class=line><span class=cl>docker run -p 8080:8080 -e <span class=nv>APP_PROFILE</span><span class=o>=</span><span class=nb>local</span> gradle-service
</span></span></code></pre></div><p>How about running unit tests? Well, in our Dockerfile you probably saw that we first defined a stage called <code>base</code> were we mounted the code of our application. This was done to re-use the <code>Dockerfile</code> for running our unit tests. We can do this by leveraging BuildKit&rsquo;s ability to target specific stages like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>docker build -t gradle-service-base --target base .
</span></span><span class=line><span class=cl>docker run -e <span class=nv>APP_PROFILE</span><span class=o>=</span><span class=nb>test</span> gradle-service-base ./gradlew clean <span class=nb>test</span>
</span></span></code></pre></div><p>With this approach we were able to containerize our build and test so that these processes run in the exact same way on all machines. Something I&rsquo;ve seen quite frequently, specially in the Java ecosystem, is that developers usually run build and test commands in their CI workflows by re-using whatever abstraction the CI runtime provides. For example, in the case of Github workflows I&rsquo;ve seen people often use the <a href=https://github.com/gradle/gradle-build-action>gradle action</a> to run gradle commands directly in their CI. What usually ends up happening is that the action sets things up in a different way and then tests end up failing in the CI but not in the local environment of the developer. Leaving people confused and forced to ignore the tests in that PR because who has time to debug the CI?</p><p>Now for the interesting part: integration tests. We mentioned previously that our service uses MySQL to store and retrieve the orders it is requested. To be able to run this integration tests we need to have MySQL running and the service connected to it. Since we want this to be reproducible and run in our CI as well we will leverage docker-compose:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;3.9&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>mysql</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>mysql:8.2.0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>MYSQL_ROOT_PASSWORD=password</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>MYSQL_DATABASE=database</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>./db/db.sql:/docker-entrypoint-initdb.d/db.sql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=m>3306</span><span class=p>:</span><span class=m>3306</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>healthcheck</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>test</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;CMD&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;mysqladmin&#34;</span><span class=w> </span><span class=p>,</span><span class=s2>&#34;ping&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;-h&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;localhost&#34;</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>timeout</span><span class=p>:</span><span class=w> </span><span class=l>5s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>retries</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>networks</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;service&#34;</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>service</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>build</span><span class=p>:</span><span class=w> </span><span class=l>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;DB_HOST=mysql&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;DB_PORT=3306&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;APP_PROFILE=default&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=m>8080</span><span class=p>:</span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>depends_on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>mysql</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>condition</span><span class=p>:</span><span class=w> </span><span class=l>service_healthy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>links</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;mysql:mysql&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>networks</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;service&#34;</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>networks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>service</span><span class=p>:</span><span class=w>
</span></span></span></code></pre></div><p>Let&rsquo;s quickly go over what this docker-compose file has:</p><ul><li>service: the definition of our service that will trigger a <code>build</code> when we run it (this is because we specified the <code>build: .</code> to docker-compose). We added a <code>depends_on</code> to MySQL with a <code>service_healthy</code> condition so that the service is only started once MySQL is up and accepting connections.</li><li>mysql: a service that runs a MySQL 8 server with an SQL file mounted to seed some data for our tests. We specified a <code>healthcheck</code> that uses <code>mysqladmin</code> so that the service connects to it only once MySQL is ready for connections.</li></ul><p>We can now start our services locally and in any other environment by running <code>docker-compose up</code>.</p><p>Time to add our integration tests. We also want these tests to be able to run in any host without requiring that host to have dependencies installed (other than the ability to run containers of course). For this reason we start writing a <code>Dockerfile</code> inside our tests folder:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> golang:1.21-alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> main.go main.go<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> go run main.go -endpoint <span class=nv>$ENDPOINT</span><span class=err>
</span></span></span></code></pre></div><p>Quite simple: we want Go and we want to execute our tests. We don&rsquo;t care about publishing this image so no need to optimize it with multi-stage builds.</p><p>With this new dockerfile and our docker-compose we can now execute our tests. However, since everything is dockerized we need to run the container for our tests in the same network as the service is running so that it can access its endpoint. We also need to wait a bit until the service is running before triggering our tests:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ docker-compose up -d
</span></span><span class=line><span class=cl><span class=c1># You should wait for the service to be up and running</span>
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> tests <span class=o>&amp;&amp;</span> docker build -t tests .
</span></span><span class=line><span class=cl>$ docker run --network dagger-developer-perspective_service -e <span class=s2>&#34;ENDPOINT=service:80&#34;</span> --rm --name tests tests
</span></span><span class=line><span class=cl>2023/11/19 14:22:37 running validation <span class=k>for</span>: open
</span></span><span class=line><span class=cl>2023/11/19 14:22:37 running validation <span class=k>for</span>: open paid
</span></span><span class=line><span class=cl>2023/11/19 14:22:37 running validation <span class=k>for</span>: open pending
</span></span><span class=line><span class=cl>2023/11/19 14:22:37 running validation <span class=k>for</span>: open paid unpacked
</span></span><span class=line><span class=cl>2023/11/19 14:22:37 running validation <span class=k>for</span>: open paid unpacked shippingMethod:table
</span></span><span class=line><span class=cl>2023/11/19 14:22:37 running validation <span class=k>for</span>: open paid unpacked completedAtFrom completedAtTo
</span></span><span class=line><span class=cl>2023/11/19 14:22:37 running validation <span class=k>for</span>: open paid and pending
</span></span></code></pre></div><p>We are now ready to build our Github workflow that re-uses what we built here.</p><h3 id=building-our-ci-workflow>Building our CI workflow<a hidden class=anchor aria-hidden=true href=#building-our-ci-workflow>#</a></h3><p>I won&rsquo;t go over too much detail here on the syntax for Github workflows. We want our workflow to run only on pull requests that are made against our main branch and we want it to:</p><ul><li>Run unit tests</li><li>Build the service</li><li>Run integration tests</li></ul><p>As we saw previously, building the sevice already happens when we do a <code>docker-compose up</code> so we only need to take care of the other two:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;pull request&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>pull_request</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>build-and-test</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Build the base image</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>docker build -t gradle-service-base --target base . </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Run unit tests</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>docker run gradle-service-base ./gradlew clean test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Start services</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>docker-compose up -d</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Check service health</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>./tests/check_health.sh</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Run integration tests</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>working-directory</span><span class=p>:</span><span class=w> </span><span class=l>tests</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>docker build -t tests . &amp;&amp; docker run --network dagger-developer-perspective_service -e &#34;ENDPOINT=service:80&#34; --rm --name tests tests</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Tear down</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>docker-compose down</span><span class=w>
</span></span></span></code></pre></div><p>In this CI workflow we are:</p><ol><li>Building the <code>base</code> image that we can then use to run our tests</li><li>Using the <code>base</code> image to run our tests</li><li>Starting the service and database with docker-compose</li><li>Running a script that checks the health of the service so that we run our integration tests once the service is up</li><li>Building the container image for our tests and running them in the same network as the service</li><li>Tearing down our service and database</li></ol><p>You can see that we added a new step that previously was done manually: service healthcheck. This is so that the integration tests only run once the service is ready:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nv>max_attempts</span><span class=o>=</span><span class=m>5</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=o>((</span> <span class=nv>i</span><span class=o>=</span>1<span class=p>;</span> i&lt;<span class=o>=</span>max_attempts<span class=p>;</span> i++ <span class=o>))</span>
</span></span><span class=line><span class=cl><span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nv>response</span><span class=o>=</span><span class=k>$(</span>curl -o /dev/null -s -w <span class=s2>&#34;%{http_code}\n&#34;</span> http://localhost:8080/health<span class=k>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$response</span><span class=s2>&#34;</span> -eq <span class=m>200</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=nb>echo</span> <span class=s2>&#34;Server is up and running.&#34;</span>
</span></span><span class=line><span class=cl>        <span class=nb>exit</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=nb>echo</span> <span class=s2>&#34;Attempt </span><span class=nv>$i</span><span class=s2>: Server not responding, retrying in 5 seconds...&#34;</span>
</span></span><span class=line><span class=cl>        sleep <span class=m>5</span>
</span></span><span class=line><span class=cl>    <span class=k>fi</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;All attempts failed, exiting with code 1.&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>exit</span> <span class=m>1</span>
</span></span></code></pre></div><p>Now we can push our branch, create a pull request and see that our CI workflow is running successfully:
<img loading=lazy src=/images/gradle-github-workflow.png alt="a screenshot of the Github website showing that the workflow run successfully in a total of 5m10s"></p><h3 id=thoughts>Thoughts<a hidden class=anchor aria-hidden=true href=#thoughts>#</a></h3><p>There were quite a few things we had to build in order to make this happen, and they were all a bit scattered:</p><ul><li>A <code>Dockerfile</code> for the service</li><li>A <code>Dockerfile</code> for the integration tests</li><li>A <code>docker-compose.yaml</code> to run the services in a reproducible way</li><li>A <code>check_health.sh</code> to check the health of the service before running our integration tests</li><li>The <code>.github/workflows/pr.yaml</code> that glues everything together.</li></ul><p><img loading=lazy src=/images/docker-compose-overview.png alt="image showing the contents of the files that were written in this blog post"></p><p>Developing this wasn&rsquo;t as &ldquo;smooth&rdquo; as I wrote it here. There were many mistakes I made in the middle that forced me to iterate a bit on how things would run locally and how they would run in the CI, for example the <code>check_health.sh</code> was only necessary in the CI. Having to define 3 stages in order to be able to run the tests in a dockerized way is also something that I haven&rsquo;t seen people often do, they just rely on their CI runtime to also install dependencies and pray it does not break. I also had to play around with how to connect containers together so that our integraion tests can actually access the service. My developer experience here, in my opinion, wasn&rsquo;t great. Probably no developer in the team will do a <code>docker build && docker run</code> locally to run their tests, it requires more effort and steps than simply using their tool of choice (in this case gradle). If the CI ever breaks, it will probably go ignored until someone decides to be unhappy for a bit and fix it.</p><h2 id=using-dagger-modules>Using Dagger modules<a hidden class=anchor aria-hidden=true href=#using-dagger-modules>#</a></h2><p>Can Dagger provide a better experience for building this? Let&rsquo;s give it a try!</p><p>Quick intro: Dagger allows you to define the entire lifecycle of your application (building, testing, packaging, etc) using code with one of the supported languages. Instead of having to write Dockerfiles and docker-compose files, you write everything in a Dagger module with your programming language of choice. Internally, Dagger leverages BuildKit and containers to make sure that the code you are writing runs anywhere in the exact the same way.</p><p>So, what do we do first? We initialize a Dagger module in our repository that will hold all the code required to build what we built before. Lets start by creating a <code>ci</code> folder and create a new Dagger module that will use Go:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>mkdir ci <span class=o>&amp;&amp;</span> <span class=nb>cd</span> ci
</span></span><span class=line><span class=cl>dagger module init --name gradle-service --sdk go
</span></span></code></pre></div><p>Quickly inspecting the contents of the program that dagger generated we can see that it is using an object called <code>dag</code> to create containers and perform actions on them:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>GradleService</span> <span class=kd>struct</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// example usage: &#34;dagger call container-echo --string-arg yo&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>GradleService</span><span class=p>)</span> <span class=nf>ContainerEcho</span><span class=p>(</span><span class=nx>stringArg</span> <span class=kt>string</span><span class=p>)</span> <span class=o>*</span><span class=nx>Container</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>dag</span><span class=p>.</span><span class=nf>Container</span><span class=p>().</span><span class=nf>From</span><span class=p>(</span><span class=s>&#34;alpine:latest&#34;</span><span class=p>).</span><span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;echo&#34;</span><span class=p>,</span> <span class=nx>stringArg</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// example usage: &#34;dagger call grep-dir --directory-arg . --pattern GrepDir&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>GradleService</span><span class=p>)</span> <span class=nf>GrepDir</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>directoryArg</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>,</span> <span class=nx>pattern</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>dag</span><span class=p>.</span><span class=nf>Container</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>From</span><span class=p>(</span><span class=s>&#34;alpine:latest&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithMountedDirectory</span><span class=p>(</span><span class=s>&#34;/mnt&#34;</span><span class=p>,</span> <span class=nx>directoryArg</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithWorkdir</span><span class=p>(</span><span class=s>&#34;/mnt&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;grep&#34;</span><span class=p>,</span> <span class=s>&#34;-R&#34;</span><span class=p>,</span> <span class=nx>pattern</span><span class=p>,</span> <span class=s>&#34;.&#34;</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can leverage dagger&rsquo;s CLI to explore what the <code>module</code> can actually do, from the root of the repository we can run <code>dagger -m ./ci functions</code> and then try some of the already provided examples:</p><p><img loading=lazy src=/images/dagger-basic-usage-screenshot.png alt="screenshot of a terminal showing the usage of dagger "></p><p>Let&rsquo;s start re-writing our module to build and test our service.Now, the interesting thing about Dagger is that modules can be published and re-used by others no matter what programming language was used to write the module, this means you can use a Go module from within a Python one. At the time of this writing modules are published at the <a href=https://daggerverse.dev>daggerverse</a>. If we look in the Daggerverse we can see that someone already developed a module to running <code>gradle</code> commands:
<img loading=lazy src=/images/gradle-module.png alt="screenshot of the daggerverse showing a module for running gradle commands"></p><p>We can leverage this module to execute the build and test commands. To use it we simply have to import it by running <code>dagger mod use github.com/matipan/daggerverse/gradle</code>. If you inspect the module with <code>dagger -m github.com/matipan/daggerverse/gradle functions</code> you&rsquo;ll see, among other things, that we can define what version of the gradle image to start from. In our case we are using the JDK 21. Let&rsquo;s write our <code>Build</code> and <code>Test</code> functions with this in mind:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>GradleVersion</span> <span class=p>=</span> <span class=s>&#34;jdk21-alpine&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>GradleService</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Source</span> <span class=o>*</span><span class=nx>Directory</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>gradle</span> <span class=o>*</span><span class=nx>Gradle</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>GradleService</span><span class=p>)</span> <span class=nf>WithSource</span><span class=p>(</span><span class=nx>src</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>)</span> <span class=o>*</span><span class=nx>GradleService</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>.</span><span class=nx>Source</span> <span class=p>=</span> <span class=nx>src</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>GradleService</span><span class=p>)</span> <span class=nf>Build</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=o>*</span><span class=nx>Container</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span><span class=p>.</span><span class=nf>getGradle</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>Source</span><span class=p>).</span><span class=nf>Build</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>GradleService</span><span class=p>)</span> <span class=nf>Test</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=o>*</span><span class=nx>Container</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span><span class=p>.</span><span class=nf>getGradle</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>Source</span><span class=p>).</span><span class=nf>Test</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>GradleService</span><span class=p>)</span> <span class=nf>getGradle</span><span class=p>(</span><span class=nx>src</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>)</span> <span class=o>*</span><span class=nx>Gradle</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>m</span><span class=p>.</span><span class=nx>gradle</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>m</span><span class=p>.</span><span class=nx>gradle</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>.</span><span class=nx>gradle</span> <span class=p>=</span> <span class=nx>dag</span><span class=p>.</span><span class=nf>Gradle</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>FromVersion</span><span class=p>(</span><span class=nx>GradleVersion</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithDirectory</span><span class=p>(</span><span class=nx>src</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithWrapper</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span><span class=p>.</span><span class=nx>gradle</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Let&rsquo;s go over what we did here:</p><ul><li><code>WithSource</code>: all Dagger calls run inside a sandboxed environment, so we need to explicitly provide things such as folders and env variables to the commands.</li><li><code>getGradle</code>: this function creates a reference to the <code>Gradle</code> module, specifying the version and configuring it to use the gradle wrapper.</li><li><code>Build</code> and <code>Test</code>: in this functions we simply obtain a reference to the Gradle module with our src directory mounted and run the specific operation there.</li></ul><p>We can now try our build function by running <code>dagger -m ./ci call with-source --src "." build</code>:</p><p><img loading=lazy src=/images/gradle-call-build.png alt="screenshot of the terminal showing the output of the command"></p><p>In the <code>Build</code> function we are only executing a <code>./gradlew clean build</code>, we can&rsquo;t really build a final image from the output of this command. With <code>Dockerfile</code>s we created a multi-stage build to separate our runtime from our build. With Dagger we can do the same thing:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>GradleService</span><span class=p>)</span> <span class=nf>BuildRuntime</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=o>*</span><span class=nx>Container</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctr</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>Build</span><span class=p>(</span><span class=nx>ctx</span><span class=p>).</span><span class=nf>Sync</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;build failed: %s&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>dag</span><span class=p>.</span><span class=nf>Container</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>From</span><span class=p>(</span><span class=s>&#34;amazoncorretto:21.0.1-alpine3.18&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;apk&#34;</span><span class=p>,</span> <span class=s>&#34;update&#34;</span><span class=p>,</span> <span class=s>&#34;&amp;&amp;&#34;</span><span class=p>,</span> <span class=s>&#34;apk&#34;</span><span class=p>,</span> <span class=s>&#34;--no-cache&#34;</span><span class=p>,</span> <span class=s>&#34;add&#34;</span><span class=p>,</span> <span class=s>&#34;ca-certificates&#34;</span><span class=p>,</span> <span class=s>&#34;curl&#34;</span><span class=p>,</span> <span class=s>&#34;tcpdump&#34;</span><span class=p>,</span> <span class=s>&#34;procps&#34;</span><span class=p>,</span> <span class=s>&#34;bind-tools&#34;</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithWorkdir</span><span class=p>(</span><span class=s>&#34;/app&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithFile</span><span class=p>(</span><span class=s>&#34;app.jar&#34;</span><span class=p>,</span> <span class=nx>ctr</span><span class=p>.</span><span class=nf>File</span><span class=p>(</span><span class=s>&#34;build/libs/gradle-service-0.0.1-SNAPSHOT.jar&#34;</span><span class=p>)).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithEntrypoint</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;sh&#34;</span><span class=p>,</span> <span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=s>&#34;java $JAVA_OPTS -jar app.jar --server.port=80 --spring.profiles.active=default&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>You can see that from <code>BuildRuntime</code> we are calling the <code>Build</code> function defined previously. We then generate a new container that starts from <code>amazoncorretto:21.0.1-alpine3.18</code> and mounts the application <code>jar</code> found in the container returned by build.</p><p>So far we&rsquo;ve only done <code>Build</code>, <code>BuildRuntime</code> and <code>Test</code>. But we also want to run integration tests and have everything integrated into Dagger. To do this we need a way to run the service and a MySQL server. Well, we are in luck. Dagger has native support for <code>Services</code>. With Dagger, we can define a container as a service and then use the <code>dagger up</code> command to start the service and its dependencies. All we have to do is write functions that return the <code>*Service</code> type:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>GradleService</span><span class=p>)</span> <span class=nf>Service</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sqlInitDB</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=o>*</span><span class=nx>Service</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>runtime</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>BuildRuntime</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>runtime</span><span class=p>.</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithEnvVariable</span><span class=p>(</span><span class=s>&#34;DB_HOST&#34;</span><span class=p>,</span> <span class=s>&#34;mysql&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithEnvVariable</span><span class=p>(</span><span class=s>&#34;DB_PORT&#34;</span><span class=p>,</span> <span class=s>&#34;3306&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithServiceBinding</span><span class=p>(</span><span class=s>&#34;mysql&#34;</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nf>Mysql</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sqlInitDB</span><span class=p>)).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExposedPort</span><span class=p>(</span><span class=mi>80</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;sh&#34;</span><span class=p>,</span> <span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=s>&#34;java $JAVA_OPTS -jar app.jar --server.port=80 --spring.profiles.active=default&#34;</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>AsService</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>GradleService</span><span class=p>)</span> <span class=nf>Mysql</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>sqlInitDB</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=o>*</span><span class=nx>Service</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>dag</span><span class=p>.</span><span class=nf>Container</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>From</span><span class=p>(</span><span class=s>&#34;mysql:8.2.0&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithEnvVariable</span><span class=p>(</span><span class=s>&#34;MYSQL_ROOT_PASSWORD&#34;</span><span class=p>,</span> <span class=s>&#34;password&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithEnvVariable</span><span class=p>(</span><span class=s>&#34;MYSQL_DATABASE&#34;</span><span class=p>,</span> <span class=s>&#34;database&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithFile</span><span class=p>(</span><span class=s>&#34;/docker-entrypoint-initdb.d/db.sql&#34;</span><span class=p>,</span> <span class=nx>sqlInitDB</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExposedPort</span><span class=p>(</span><span class=mi>3306</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>AsService</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Lets break this code down:</p><ul><li>In the <code>Service</code> function we first call the <code>BuildRuntime</code> to generate a container that has our <code>jar</code> ready to be executed.</li><li>We then create a new container that defines a mysql <code>ServiceBinding</code> to whatever <code>Service</code> the <code>Mysql</code> function returns.</li><li>The <code>Mysql</code> function returns MySQL 8 container with our seed file ready to populate the DB when it starts.</li></ul><p>Now we can use the <code>up</code> command to start the service and its dependencies locally <code>dagger -m ./ci up with-source --src "." service --sql-init-db "db/db.sql"</code>:</p><p><img loading=lazy src=/images/dagger-up-service.png alt="output of running the dagger up command"></p><p>Dagger makes sure that the services are healthy before they connect to each other. All this runs in containers isolated in their own environments. This means that we can run this same command in other machines and expect it will work correctly.</p><p>To run the integration tests we can create a function that leverages the concept of services and the fact that the entire definition of the containers are in this same codebase. We can create a container from a specific go version and create a service binding to the service itself:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>GradleService</span><span class=p>)</span> <span class=nf>IntegrationTests</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>tests</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>,</span> <span class=nx>sqlInitDB</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>dag</span><span class=p>.</span><span class=nf>Go</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>FromVersion</span><span class=p>(</span><span class=s>&#34;1.21-alpine&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithSource</span><span class=p>(</span><span class=nx>tests</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>Container</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithServiceBinding</span><span class=p>(</span><span class=s>&#34;service&#34;</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nf>Service</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>sqlInitDB</span><span class=p>)).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;go&#34;</span><span class=p>,</span> <span class=s>&#34;run&#34;</span><span class=p>,</span> <span class=s>&#34;main.go&#34;</span><span class=p>,</span> <span class=s>&#34;--endpoint&#34;</span><span class=p>,</span> <span class=s>&#34;service:80&#34;</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In this function we expect to receive the directory that holds the tests, the database file used to seed the db and we return the output that the command generates. We can now use dagger&rsquo;s CLI to call this function and run the integration tests, all containerized and defined within a single codebase:</p><p><img loading=lazy src=/images/integration-tests-cmd.png alt="output of dagger showing the tests succeeded"></p><h3 id=building-our-ci-workflow-1>Building our CI workflow<a hidden class=anchor aria-hidden=true href=#building-our-ci-workflow-1>#</a></h3><p>Let&rsquo;s put all of this together in our CI workflow. This is where Dagger shines in my opinion. We don&rsquo;t have to do anything special to make sure this works in our CI environment. We just need to install the dagger CLI and run the exact same command developers run locally:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;pull request&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>pull_request</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>master</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>develop</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>build-and-test</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install Dagger CLI</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>cd /usr/local &amp;&amp; { curl -L https://dl.dagger.io/dagger/install.sh | sh; cd -; }</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>dagger -m ./ci call with-source --src &#34;.&#34; test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Integration test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>dagger -m ./ci call with-source --src &#34;.&#34; integration-tests --tests &#34;./tests&#34; --sql-init-db &#34;./db/db.sql&#34;</span><span class=w>
</span></span></span></code></pre></div><p>And we are done! Less YAML and no surprises. Here is the pipeline working as we expected:</p><p><img loading=lazy src=/images/dagger-gradle-github-workflow.png alt="a screenshot of the Github website showing that the workflow run successfully in a total of 4m18s"></p><h3 id=thoughts-1>Thoughts<a hidden class=anchor aria-hidden=true href=#thoughts-1>#</a></h3><p>Through the use of code and Dagger&rsquo;s capabilities for running containerized services and commands we were able to build our entire CI workflow in a programmatic way inside a single Go file. Here is an overview of what we needed to write in order to make this work:</p><p><img loading=lazy src=/images/gradle-dagger-module-overview.png alt="screenshot showing the entire dagger module and github workflow"></p><p>Notice how we wrote all the important bits directly in code, no need for YAML and config files like <code>Dockerfile</code>s. Even though there are a few rough edges in Dagger (mainly due to how new it is) I personally believe this is a much better experience than what we had before. We wrote the entire definition of our CI using code and we were able to validate every single part of it locally. If we compare to how we could run the tests before, we now have an DX that developers can definitely use: <code>dagger -m ./ci call with-source --src "." test</code>.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In this blog post we compared the experience of using traditional tools like docker-compose with Dagger for building a CI workflow that builds and tests a Java-Gradle service. We saw how with docker and docker-compose we had to write a lot of configuration files and YAML to glue things together in a way that was not easily reproducible. Meaning that developers would run things locally in a way that would be different to how the CI would work. However, with Dagger we saw that it was no longer necessary to write this config and YAMl files. Instead, we built everything using Go code, we leveraged Dagger&rsquo;s native support for running services and we glued everything together in a programmatic but still declarative way. We were then able to run this code in the CI in the exact same way that we run it locally.</p><p>I personally believe there is still a bit of a learning curve to Dagger. It requires a mindset shift in order to stop thinking that this processes should be written and defined with configuration &ldquo;languages&rdquo; such as YAML and dockerfile. However, I think Dagger provides a lot of power with it&rsquo;s code-first approach and its ecosystem that will only get bigger and better. It&rsquo;s interesting how easily it integrates with existing CI systems and gives a developer experience that allows us to treat pipelines as software and write them using our editors and IDEs.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.matiaspan.dev/tags/go/>go</a></li><li><a href=https://blog.matiaspan.dev/tags/dagger/>dagger</a></li><li><a href=https://blog.matiaspan.dev/tags/ci/cd/>ci/cd</a></li><li><a href=https://blog.matiaspan.dev/tags/exploring-dagger/>exploring-dagger</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Exploring Dagger: Streamlining CI/CD Pipelines with Code ‚Äì A Developer's Guide on x" href="https://x.com/intent/tweet/?text=Exploring%20Dagger%3a%20Streamlining%20CI%2fCD%20Pipelines%20with%20Code%20%e2%80%93%20A%20Developer%27s%20Guide&amp;url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fexploring-dagger-streamlining-ci-cd-pipelines-with-code%2f&amp;hashtags=go%2cdagger%2cci%2fcd%2cexploring-dagger"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Exploring Dagger: Streamlining CI/CD Pipelines with Code ‚Äì A Developer's Guide on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fexploring-dagger-streamlining-ci-cd-pipelines-with-code%2f&title=Exploring%20Dagger%3a%20Streamlining%20CI%2fCD%20Pipelines%20with%20Code%20%e2%80%93%20A%20Developer%27s%20Guide"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Exploring Dagger: Streamlining CI/CD Pipelines with Code ‚Äì A Developer's Guide on ycombinator" href="https://news.ycombinator.com/submitlink?t=Exploring%20Dagger%3a%20Streamlining%20CI%2fCD%20Pipelines%20with%20Code%20%e2%80%93%20A%20Developer%27s%20Guide&u=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fexploring-dagger-streamlining-ci-cd-pipelines-with-code%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.matiaspan.dev/>Matias Pan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>