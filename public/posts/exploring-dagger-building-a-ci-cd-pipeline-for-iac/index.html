<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Exploring Dagger: Building a CI/CD pipeline for IaC | Matias Pan's blog</title>
<meta name=keywords content="pulumi,go,aws,dagger,ci/cd,exploring-dagger"><meta name=description content="Dagger is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the supported SDKs. I&rsquo;m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me with would be useful. This is the first post in a series of blog posts that look at Dagger from different perspectives."><meta name=author content="matipan"><link rel=canonical href=https://blog.matiaspan.dev/posts/exploring-dagger-building-a-ci-cd-pipeline-for-iac/><link crossorigin=anonymous href=/assets/css/stylesheet.a801c217e3c96db9c9df36cb1d2216a9bc5d9fa77b72e2afcdf47fb847f8f015.css integrity="sha256-qAHCF+PJbbnJ3zbLHSIWqbxdn6d7cuKvzfR/uEf48BU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Exploring Dagger: Building a CI/CD pipeline for IaC"><meta property="og:description" content="Dagger is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the supported SDKs. I&rsquo;m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me with would be useful. This is the first post in a series of blog posts that look at Dagger from different perspectives."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.matiaspan.dev/posts/exploring-dagger-building-a-ci-cd-pipeline-for-iac/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-13T00:00:00-03:00"><meta property="article:modified_time" content="2023-11-13T00:00:00-03:00"><meta property="og:site_name" content="Matias Pan's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Exploring Dagger: Building a CI/CD pipeline for IaC"><meta name=twitter:description content="Dagger is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the supported SDKs. I&rsquo;m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me with would be useful. This is the first post in a series of blog posts that look at Dagger from different perspectives."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.matiaspan.dev/posts/"},{"@type":"ListItem","position":2,"name":"Exploring Dagger: Building a CI/CD pipeline for IaC","item":"https://blog.matiaspan.dev/posts/exploring-dagger-building-a-ci-cd-pipeline-for-iac/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Exploring Dagger: Building a CI/CD pipeline for IaC","name":"Exploring Dagger: Building a CI\/CD pipeline for IaC","description":"Dagger is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the supported SDKs. I\u0026rsquo;m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me with would be useful. This is the first post in a series of blog posts that look at Dagger from different perspectives.","keywords":["pulumi","go","aws","dagger","ci/cd","exploring-dagger"],"articleBody":"Dagger is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the supported SDKs. I’m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me with would be useful. This is the first post in a series of blog posts that look at Dagger from different perspectives. In this post I do a deep dive on how to build a pipeline for an IaC repository. I explore building this using “native” Github actions, the Dagger client and the newer approach of Dagger modules.\nNOTE: Dagger is in very active development so by the time you read this blog post some things might have changed.\nBackground We have a repository that holds all of our infrastructure in a declarative way using Pulumi’s Go SDK. Every time we want to provision, change or delete some infrastructure we need to:\nCreate a pull request with the necessary changes Wait for CI to show what changes will be applied by posting a comment to the PR Merge it Wait for CI on the main branch to apply those changes to the given environment This process will utilize two operations pulumi provides:\npulumi preview: show a diff of the changes that would be applied. pulumi up: apply the requested changes. We are going to build this workflow using Github actions first to understand how the current “status quo” works when it comes to building these types of pipelines. Then, we will build this same solution using Dagger. There is currently two ways of building this with Dagger and we will explore both: i) using the “traditional” dagger client; and ii) using the newer concept of Dagger modules.\nUsing Github actions Intro When you build pipelines with Github actions you have to write a YAML file on .github/workflows that contains the definition of your workflow, where each step can:\nRun specific commands such as curl. Refer to existing Actions that are a part of Github’s marketplace. These actions usually either install dependencies on the runner or perform specific actions. Refer to a custom action defined within the repository (or an external repo if you are paying for Github). For example, if we want to run go build on a Go project we would re-use the actions/setup-go function that installs Go in the runner where our command executes and simply call go build:\nname: Build on: - pull_request jobs: build: name: Build runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: actions/setup-go@v3 with: go-version: 'stable' - name: Go build run: go build In this case we used the already provided setup-go action. If our tool would not have already been supported, we would have had to build the action ourselve. Refer to this blog post to learn how you would build one.\nBuilding our CI Our CI process has two separate workflows for:\nPreviewing changes: used when a PR is created against main to execute pulumi preview and show the diff as a comment on the pull request. Applying changes: used when a commit is pushed to main to run pulumi up and apply the desired changes. In both workflows we will to run a specific pulumi command. To do this we could create a workflow that has a step that installs Pulumi’s CLI and another that calls the command. However, if we browse the Github marketplace we will see that the team behind Pulumi has already built a custom action that allows us to do just that. Our Workflow that reuses this action looks like this:\nname: Preview infrastructure changes on Pull Requests on: - pull_request jobs: preview: name: Preview runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: actions/setup-go@v3 with: go-version: 'stable' - name: Configure AWS Credentials uses: aws-actions/configure-aws-credentials@v1 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-region: ${{ secrets.AWS_REGION }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} - run: go mod download - uses: pulumi/actions@v3 with: command: preview stack-name: org-name/stack-name comment-on-pr: true github-token: ${{ secrets.GITHUB_TOKEN }} env: PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }} In this workflow we are: i) setting up Go since pulumi requires Go to be installed; ii) setting up AWS’s credentials required by Pulumi; iii) use Pulumi’s action to run the command. As you can see, using Pulumi’s action allowed us to solve two problems at once:\nRun the pulumi preview command by setting command: preview and post a PR Comment with the diff the preview generated. The up workflow would be very similar to this one with the small change of removing comment-on-pr.\nThoughts Given the simplicity of this workflow I don’t have much to complain about. The two things I personally did not like where:\nDeveloping it: seems like a shallow complaint, but I personally do not like the “development experience” that YAML gives you. Understanding which parameters the action accepted required me to look at a README on the action’s repo and one trial and error. Testing: it is not easy to validate this workflows locally. You could use a custom tool such as act but it does not offer a good DX and it is often quite heavy. It is true that as the CI process evolves and gets more complicated this two things become more problematic. But for this simple use case it was not too bad.\nUsing the Dagger client Intro To build a CI process using Dagger’s client you first have to choose from one of the available SDKs. We’ll use Go since our Pulumi infra is using it already. The first thing we’ll do is create a folder called ci and write a little main.go file that uses Dagger’s SDK to communicate with the Dagger engine to print a hello world:\npackage main import ( \"context\" \"log\" \"dagger.io/dagger\" ) func main() { ctx := context.Background() client, err := dagger.Connect(ctx) if err != nil { log.Fatal(err) } client.Container(). From(\"alpine:latest\"). WithExec([]string{\"echo\", \"hello world\"}). Stdout(ctx) } We can run this with go run or with Dagger’s CLI that shows us a detailed output of what is happening:\nInternally the Dagger engine is leveraging BuildKit to perform all the operations we ask for. This means that this code we wrote will on any machine and produce the same result. You could use this SDK to replace Dockerfiles entirely but for now we’ll focus on our IaC pipeline.\nBuilding our CI Let’s start by writing the Dagger program. Now, given that we need to support two operations (and both need the same flag) we need this program to manage arguments and execute different code based on those. Let’s rewrite our main.go to support that:\n// ... var stack = flag.Parse(\"stack\", \"prod\", \"pulumi stack to use\") func main() { flag.Parse() // ... if len(os.Args) == 0 { log.Fatal(\"specify an operation. Possible values: preview,up\") } switch os.Args[1] { case \"preview\": // Run `pulumi preview --stack ` case \"up\": // Run `pulumi up --stack ` } } As we saw previously, all we need to do is execute pulumi preview and post the result of it to Github. Since Dagger is containers all the way we can re-use existing images that have the dependencies we need. In this case all we need is pulumi, so we’ll use the official image to build a Container that has the necessary go dependencies, code and secrets to run commands:\nfunc baseContainer(client *dagger.Client) *dagger.Container { pulumiToken := client.SetSecret(\"pulumi_token\", os.Getenv(\"PULUMI_ACCESS_TOKEN\")) awsAccessKey := client.SetSecret(\"aws_access_key\", os.Getenv(\"AWS_ACCESS_KEY_ID\")) awsSecretKey := client.SetSecret(\"aws_secret_key\", os.Getenv(\"AWS_SECRET_ACCESS_KEY\")) return client. Container(). From(\"pulumi/pulumi:latest\"). WithSecretVariable(\"PULUMI_ACCESS_TOKEN\", pulumiToken). WithSecretVariable(\"AWS_ACCESS_KEY_ID\", awsAccessKey). WithSecretVariable(\"AWS_SECRET_ACCESS_KEY\", awsSecretKey). WithMountedDirectory(\"/infra\", client.Host().Directory(\".\")). WithWorkdir(\"/infra\"). WithEntrypoint([]string{\"/bin/bash\"}). WithExec([]string{\"-c\", \"go mod tidy\"}) } In this baseContainer function we are building and returning a container that:\nStarts from pulumi’s oficial image pulumi/pulumi:latest Has the credentials necessary to communicate with Pulumi and AWS obtained from the environment but stored in a secure way using Dagger secrets. Has the infrastructure code mounted in the working directory /infra and has all the go dependencies that our pulumi code requires. This container can now be used to execute pulumi commands:\n// ... func main() { // ... switch os.Args[1] { case \"preview\": out, err := baseContainer(client). WithExec([]string{\"-c\", fmt.Sprintf(\"pulumi preview --stack %s --non-interactive --diff\", *stack)}). Stdout(ctx) if err != nil { log.Fatal(err) } fmt.Println(out) case \"up\": // Run `pulumi up` } } Running this locally using Dagger’s CLI shows a lot of output, so I’ll show here only the relevant pulumi bits:\n┃ @ Previewing update..... ┃ @ Previewing update..... ┃ pulumi:pulumi:Stack: (same) ┃ [urn=urn:pulumi:prod::networking::pulumi:pulumi:Stack::networking-prod] ┃ ~ aws:ecs/service:Service: (update) ┃ [id=arn:aws:ecs:us-west-2:831445021348:service/services-0187c44/ninjas] ┃ [urn=urn:pulumi:prod::networking::awsx:ecs:FargateService$aws:ecs/service:Service::ninjas] ┃ [provider=urn:pulumi:prod::networking::pulumi:providers:aws::default_5_35_0::321a9293-c7af-42be-a9fd-061afc82e317] ┃ ~ networkConfiguration: { ┃ ~ securityGroups: [ ┃ ~ [0]: \"sg-0b2ee5e5403c1ca86\" =\u003e \"sg-0cf0cbf24b1e39535\" ┃ ] ┃ } ┃ - aws:ec2/securityGroup:SecurityGroup: (delete) ┃ [id=sg-0b2ee5e5403c1ca86] ┃ [urn=urn:pulumi:prod::networking::aws:ec2/securityGroup:SecurityGroup::svc-sg] ┃ description : \"Allow TCP traffic on port 8080 from the VPC\" ┃ egress : [ ┃ [0]: { ┃ cidrBlocks: [ ┃ [0]: \"0.0.0.0/0\" ┃ ] ┃ fromPort : 0 ┃ protocol : \"-1\" ┃ self : false ┃ toPort : 0 ┃ } ┃ ] ┃ ingress : [ ┃ [0]: { ┃ cidrBlocks : [ ┃ [0]: \"10.1.0.0/16\" ┃ ] ┃ description: \"allow TCP traffic on 8080 from the VPC\" ┃ fromPort : 8080 ┃ protocol : \"tcp\" ┃ self : false ┃ toPort : 8080 ┃ } ┃ ] ┃ name : \"svc-sg-6648e89\" ┃ revokeRulesOnDelete: false ┃ vpcId : \"vpc-0ec0d8d2118fc95c5\" ┃ Resources: ┃ ~ 1 to update ┃ - 1 to delete ┃ 2 changes. 59 unchanged You probably already saw a big difference in how CI gets built with Dagger. We first developed the code that performs the operations we want and tested it locally instead of writing a YAML and pushing it to the repo to test it. To run this in Github’s CI environment we, unfortunately, have to write some YAML (maybe Dagger cloud will fix that some day? 👀):\nname: preview on: pull_request: branches: - main jobs: dagger: runs-on: ubuntu-latest permissions: write-all steps: - name: Checkout uses: actions/checkout@v3 - name: Setup Go uses: actions/setup-go@v4 with: go-version: '\u003e=1.21' - name: Install Dagger CLI run: cd /usr/local \u0026\u0026 { curl -L https://dl.dagger.io/dagger/install.sh | sh; cd -; } - name: Preview infrastructure changes env: PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }} AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY }} AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }} AWS_REGION: \"us-west-2\" run: dagger run go run ./ci preview -stack= In this pipeline you can see that we first have to setup the tools we need (Go and Dagger, although Dagger is not strictly necessary) and then we call to our go program using Dagger’s CLI and specifying that we want to perform the preview operation on a specific stack.\nThis pipeline is missing the capability of posting a comment with the diff that preview generated. Since we are writing Go code for our CI, we can extend our program to use Github’s Go SDK and post the comment with the output of the command:\n// ... switch os.Args[1] { case \"preview\": out, err := baseContainer(client). WithExec([]string{\"-c\", fmt.Sprintf(\"pulumi preview --stack %s --non-interactive --diff\", *stack)}). Stdout(ctx) if err != nil { log.Fatal(err) } // if the token is not specified we won't post anything token := os.Getenv(\"GITHUB_TOKEN\") if token == \"\" { return } // GITHUB_REPOSITORY is in the format: `:owner/:repo` repo := strings.Split(os.Getenv(\"GITHUB_REPOSITORY\"), \"/\") // On pull requests GITHUB_REF has the format: `refs/pull/:prNumber/merge` ref, err := strconv.Atoi(strings.Split(os.Getenv(\"GITHUB_REF\"), \"/\")[2]) if err != nil { log.Fatal(err) } return postComment(ctx, out, token, repo[0], repo[1], ref) } func postComment(ctx context.Context, content, githubToken, owner, repo string, pr int) error { body := fmt.Sprintf(\"```\\n%s\\n```\", content) client := github.NewClient(nil).WithAuthToken(githubToken) _, _, err := client.Issues.CreateComment(ctx, owner, repo, pr, \u0026github.IssueComment{ Body: \u0026body, }) return err } This can still be tested locally. All we have to do is specify the GITHUB_TOKEN environment variable so that our program can communicate with Github’s API.\nHere is a sample of this working at my repository:\nImplementing the up command would be very similar to the preview but without calling the postComment function.\nThoughts You can probably see how much code we had to write in order to implement the same functionality that a few lines of YAML gave us. In the case of Github actions, all we had to do was reuse Pulumi’s action and specify an option of comment-on-pr to get everything we wanted. With the Dagger SDK we had to first build the container that had the dependencies we needed and then use Github’s SDK to post the comment we wanted. If Pulumi’s action was not already provided and we had to build it ourselves then I do believe that the approach of using Dagger, where we can run it locally and “tap” into the ecosystem of the language we are using, would have been much more superior.\nWhile this example in particular is rather simple, imagine how this process get more complicated when you want to run integration tests that require multiple containers running. I’m doing some exploration on this part that I hope to post soon, but in the meantime you can refer to this YouTube video to see an example of a more complicated CI process being implemented with Dagger.\nUsing Dagger modules Intro Dagger modules is, at the time of this writing, a brand new concept the Dagger team implemented to address some of the problems we mentioned previously. The two that we will focus on here are:\nRe-usability: with the Dagger SDK we built a program that can run pulumi commands, but it is not re-usable by myself or any other person that might need to do this same thing. Declarative Interface: our Go program is very “raw” when it comes to declaring its API. If you want to understand what is the “API” of this CLI, you have to look at the code, see the switch statement and notice that we support up and preview as valid values. When it comes to re-usability the first thing we need to understand is: how can we make what we built available to the world? Similar to how the Github marketplace allows us to browse all available actions, the Daggerverse (still in very early stages) allows us to browse all modules that were developed and published by someone. For example, here is a module that someone (👀) built to run gradle tasks:\nTo understand the API that this module has we can use Dagger’s CLI and run dagger -m github.com/matipan/daggerverse/gradle functions:\nThe most interesting bit for me is that you can call other Dagger modules from your own no matter the programming language they are using. For example, the gradle module was built using Go but we can call the gradle.Build function from another Dagger module built with Python:\nimport dagger from dagger.mod import function @function def build() -\u003e dagger.Container: return dagger.gradle().build() When we call this function on our module and we can see that it indeeds uses the Gradle module to perform a build (it failed because, fortunately, we are not writing Java):\nBuilding our CI Since Dagger modules can be reused and we can find all modules in the Daggerverse lets see if someone already built a Pulumi module:\nNo luck 😕. Well, at the time of this writing the Daggerverse was announced less than a week ago so it makes sense that it is not as “crowded” as the Github marketplace. But this is great for us. We get to build a pulumi module ourselves, publish it and contribute to this brand new environment that has a lot of promise. Then we’ll build our CI process using it.\nBuilding the Pulumi module We want to build a module that has an interface similar to Pulumi’s Github action where we can run any of the supported pulumi commands. But since we are going to be building it with code we can make it a bit more expressive. We start by initializing our module and specifying that we want to use Go:\ndagger mod init --name pulumi --sdk go This command will generate Go code that we will use to interface with Dagger’s SDK as well as a dagger.json file that contains the definition of our module and its dependencies (in this case we won’t have any). The sample main.go file that it generated gives us some idea on how to start writing our module:\npackage main import ( \"context\" ) type Pulumi struct {} // example usage: \"dagger call container-echo --string-arg yo\" func (m *Pulumi) ContainerEcho(stringArg string) *Container { return dag.Container().From(\"alpine:latest\").WithExec([]string{\"echo\", stringArg}) } // example usage: \"dagger call grep-dir --directory-arg . --pattern GrepDir\" func (m *Pulumi) GrepDir(ctx context.Context, directoryArg *Directory, pattern string) (string, error) { return dag.Container(). From(\"alpine:latest\"). WithMountedDirectory(\"/mnt\", directoryArg). WithWorkdir(\"/mnt\"). WithExec([]string{\"grep\", \"-R\", pattern, \".\"}). Stdout(ctx) } We want to start by implementing the 4 operations that the Pulumi CLI github action supports: up, refresh, destroy and preview. We want each of these operations to be its own function so that when we call dagger functions we can see each operation and users can refer to any one of them separately. Pulumi’s main role is to perform operations against our cloud provider so we need to solve the problem of specifying credentials. When we built the Github workflow we had to run the configure-aws-credentials step that left the environment ready for pulumi to communicate with AWS. We can do something similar here but “natively” within the module. For each cloud provider we want to support we will add a function called WithCredentials that sets the credentials in a secure way for that specific cloud provider using Dagger’s native support for Secrets. We’ll do the same thing for specifying pulumi’s access token. I’ll show here a portion of the code that implements the Up operation to keep it brief, you can see the entire code base of the module on Github:\ntype Pulumi struct { AwsAccessKey *Secret AwsSecretKey *Secret PulumiToken *Secret Version string } // FromVersion is an optional function that users can use to specify // the version of pulumi's docker image to use as base. func (m *Pulumi) FromVersion(version string) *Pulumi { m.Version = version return m } // WithAwsCredentials sets the AWS credentials to be used by Pulumi. // Call this function if you want pulumi to point your changes to AWS. func (m *Pulumi) WithAwsCredentials(awsAccessKey, awsSecretKey *Secret) *Pulumi { m.AwsAccessKey = awsAccessKey m.AwsSecretKey = awsSecretKey return m } // WithPulumiToken sets the Pulumi token to be used by Pulumi. func (m *Pulumi) WithPulumiToken(pulumiToken *Secret) *Pulumi { m.PulumiToken = pulumiToken return m } // Up runs the `pulumi up` command for the given stack and directory. // NOTE: This command will perform changes in your cloud. func (m *Pulumi) Up(ctx context.Context, src *Directory, stack string) (string, error) { return m.commandOutput(ctx, src, fmt.Sprintf(\"pulumi up --stack %s --yes --non-interactive\", stack)) } // ... // commandOutput runs the given command in the pulumi container and returns its output. func (m *Pulumi) commandOutput(ctx context.Context, src *Directory, command string) (string, error) { ct, err := m.authenticatedContainer(src) if err != nil { return \"\", err } return ct. WithExec([]string{\"-c\", command}). Stdout(ctx) } // authenticatedContainer returns a pulumi container with the required credentials. // Users have to set credentials for their cloud provider by using the `WithCredentials` // function. func (m *Pulumi) authenticatedContainer(src *Directory) (*Container, error) { if m.PulumiToken == nil { return nil, errors.New(\"pulumi token is required. Use `with-pulumi-token` to set it\") } ct := container(src, m.PulumiToken, m.Version) switch { case m.AwsAccessKey != nil \u0026\u0026 m.AwsSecretKey != nil: ct = ct.WithSecretVariable(\"AWS_ACCESS_KEY_ID\", m.AwsAccessKey). WithSecretVariable(\"AWS_SECRET_ACCESS_KEY\", m.AwsSecretKey) default: return nil, errors.New(\"no cloud provider credentails was provided\") } return ct, nil } // container obtains a base container with pulumi's CLI installed. func container(src *Directory, pulumiToken *Secret, version string) *Container { if version == \"\" { version = \"latest\" } return dag. Container(). From(fmt.Sprintf(\"pulumi/pulumi:%s\", version)). WithSecretVariable(\"PULUMI_ACCESS_TOKEN\", pulumiToken). WithMountedDirectory(\"/infra\", src). WithWorkdir(\"/infra\"). WithEntrypoint([]string{\"/bin/bash\"}). WithExec([]string{\"-c\", \"go mod tidy\"}) } Since we are writing Go, any variable or function that starts with an Uppercase letter will be part of the interface of this module and developers will see it when calling dagger functions. A few things worth pointing out of this code:\nThere are 2 public functions (WithAwsCredentials and WithPulumiToken) that set the credentials for what we want to do and need to be called before our operation. See how they return a reference to the module itself, in Dagger-lang this means that in order for something to happen they require a subcommand (like up). If you want support for your cloud provider you are welcome to make a PR 🚀. The Up function returns a string and an error, indicating the output of the pulumi command and an error if there was any. The authenticatedContainer function is where the magic happens. This function is private and is used to create a container that has the required credentials and dependencies. Users of the module can point to a specific version of pulumi using FromVersion and if they don’t we default to latest. We can test this module locally with my IaC repository. For example the Preview operation:\ndagger -m github.com/matipan/daggerverse/pulumi call with-aws-credentials --aws-access-key \"\" --aws-secret-key \"\" with-pulumi-token --pulumi-token \"\" preview --src \".\" --stack \"\" And the output:\nYou can see all the operations this module supports by running dagger -m github.com/matipan/daggerverse/pulumi functions or browsing the homepage of the module in the Daggerverse.\nBuilding our CI re-using modules When now can see in the Daggerverse that there is a pulumi module we can leverage:\nThis module takes care of the IaC part but for the case of pull requests we wanted to post a comment showing the diff that was generated. Luckily, someone (thanks @aweris) already built a Dagger module that allows developers to run any command of the gh CLI. This means we could run gh pr comment --body '' from our Dagger code and pass the output that the Pulumi module gave us.\nTo get started writing our CI we will create a new “module” that has the operations our workflow requires. For simplicity we will call them preview and up as well. We’ll use Go since we kind of love it here (but remember that with Dagger it does not matter in what language a given module was built):\ndagger mod init --name iac --sdk go Now we can add the dependencies for the two modules we’ll use:\ndagger mod use github.com/matipan/daggerverse/pulumi dagger mod use github.com/aweris/daggerverse/gh And quickly build our module with the Preview function that uses these dependencies:\ntype Iac struct { AwsAccessKey *Secret AwsSecretKey *Secret PulumiToken *Secret } func (m *Iac) WithCredentials(pulumiToken, awsAccessKey, awsSecretKey *Secret) { m.PulumiToken = pulumiToken m.AwsAccessKey = awsAccessKey m.AwsSecretKey = awsSecretKey } func (m *Iac) Preview(ctx context.Context, src *Directory, stack string, githubToken *Secret, githubRef string) error { diff, err := dag.Pulumi(). WithAwsCredentials(m.AwsAccessKey, m.AwsSecretKey). WithPulumiToken(m.PulumiToken). Preview(ctx, src, stack) if err != nil { return err } // On pull requests GITHUB_REF has the format: `refs/pull/:prNumber/merge` pr, err := strconv.Atoi(strings.Split(githubRef, \"/\")[2]) if err != nil { return fmt.Errorf(\"githubRef did not have the correct format, expected: refs/pull/:prNumber/merge. Got: %s\", githubRef) } _, err = dag.Gh().Run(ctx, githubToken, fmt.Sprintf(\"pr comment %d --body '%s'\", pr, diff)) return err } You can see that we are calling the Pulumi module Preview operation and then sending the output of it to the gh module so that it posts the comment on Github. Our Github workflow will now call our module instead:\nname: 'preview' on: pull_request: branches: - main jobs: dagger: runs-on: ubuntu-latest permissions: write-all steps: - name: Checkout uses: actions/checkout@v3 - name: Setup Go uses: actions/setup-go@v4 with: go-version: '\u003e=1.21' - name: Install Dagger CLI run: cd /usr/local \u0026\u0026 { curl -L https://dl.dagger.io/dagger/install.sh | sh; cd -; } - name: Preview infrastructure changes env: PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }} AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY }} AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }} AWS_REGION: \"us-west-2\" GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} run: dagger -m ./ci call with-credentials --pulumi-token $PULUMI_ACCESS_TOKEN --aws-access-key $AWS_ACCESS_KEY_ID --aws-secret-key $AWS_SECRET_ACCESS_KEY preview --src \".\" --stack \"ninjastructure/prod\" --github-token $GITHUB_TOKEN --github-ref $GITHUB_REF The dagger command that was specified in the last step can be run locally which allows us to test things before pushing them.\nThoughts As you can see at the time of this writing the Daggerverse is quite new and does not have many modules already provided. This required us to build the module to interact with Pulumi. However, we were able to find a module that provided us with the capacity to post a comment on the PR that was open. Once we had these dependencies ready to go it was just a matter of referencing them and piping things together, all with code using the programming language I preferred. With the wiring of those modules taken care of it was just a matter of using Dagger’s CLI to call our module and perform the operations we wanted. The same command we run locally to test that everything worked correctly was then added to the CI process to finish the entire workflow. If we ever were to migrate from Github actions to say, CircleCI, then it would be a matter of referencing this same command from our CircleCI workflow and that’s it.\nThe main problem I see with this approach today has to do with caching. Every single operation can potentially be cached and save us from having to recreate the entire environment every time. To achieve this with Dagger we would have to either: i) use the paid offering that provides this caching called Dagger cloud; ii) deploying a dagger engine with caching in your own infrastructure and point your CI runners to use that version of the engine. That approach is not too bad for simpler use cases, but as soon as you need to scale you’ll require multiple instances running.\nAs a side note, when we wanted to create our pipeline we had to create a new “module” that was the entrypoint for our CI. This is because the only way to use other modules today is from within another module. I found this a bit confusing. In programming languages such as Go you can create either libraries or executables. When I hear the word “module” I think of a library that requires an executable to call it and do something. Maybe it’s just a naming thing or maybe I get easily confused.\nComparison When comparing the approach of Github actions and Dagger modules I find two main differences. First of all, Github actions does not give us a process that can be easily testable and extensible. When it comes to extending we would either have to build custom actions or do some setup magic and run custom scripts on top of this yaml. Again, this is a simple process, but CI/CD often gets more complicated as time goes on. And while right now this may not seem like an obvious problem, it always ends up becoming that critical yaml file that nobody wants to touch. The second difference is more “conceptual”, but it’s important to point it out because it requires a mindset shift when it comes to building CI. In the traditional pipeline we can see a “stateful” approach where each of the steps that are being executed are doing explicit things on the host (i.e the runner) that the subsequent action then reuses:\nCheckout the code of the repository Install the latest stable version of Go Configure AWS’s credentials (technically not needed, we could use env variables directly…) Download go dependencies that pulumi’s code uses. Run pulumi preview Every single one of those actions changed the underlying host in some way and left a state that the subsequent action would then use. This means that when you build a workflow you always operate directly on the host instead of “chaining” inputs/outputs like you do when building a dag, for example an Airflow dag. I don’t particularly like this approach, it is one of the main things that makes this processed hard to test and more importantly very hard to understand.\nWith dagger modules we saw a different approach. When we were calling a module we had to explicitly provide all the required resources to perform the specific operation. This is because dagger functions run in a sandboxed environment that can potentially be executed on a different host. This, in my opinion, opens up interesting possibilities for building CI pipelines using reusable APIs that are deployed once and used everywhere. There might be occasions where this stateless approach falls short but I still need to do a deep dive in those special cases. If I compare Dagger’s approach with the way the data world works I find a lot of similarities. When you build data pipelines using tools like Airflow, the worker where the operator code gets executed usually only performs HTTP calls. For example, if you build a data pipeline that performs some data transformation using spark on EMR and then ingests that data on a datasource like clickhouse, your Airflow DAG will probably look something like this:\nUse EMR Operator to execute some spark code. Airflow’s worker will call AWS’s API, ask for a given script to be executed and then wait for completion. Use an ECS task or similar to run code that reads the data from S3 and ingest it into clickhouse. Conclusion I believe Dagger offers a compelling alternative to yaml and custom scripts in CI/CD pipelines. By leveraging code, we gain expressiveness, reusability, and the ability to integrate with a wide range of tools and services. As Dagger matures, I’m excited to see how it will continue to evolve and improve CI/CD practices. However, the current state of the art of Dagger requires a big mindset shift and, while it does offer important benefits, for simpler use cases like the one explored in this blog post the learning curve seems to be a bit steep. I think that in this post we found very interesting primitives that will probably allow us to develop a better experience for all use cases.\n","wordCount":"4963","inLanguage":"en","datePublished":"2023-11-13T00:00:00-03:00","dateModified":"2023-11-13T00:00:00-03:00","author":{"@type":"Person","name":"matipan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.matiaspan.dev/posts/exploring-dagger-building-a-ci-cd-pipeline-for-iac/"},"publisher":{"@type":"Organization","name":"Matias Pan's blog","logo":{"@type":"ImageObject","url":"https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.matiaspan.dev/ accesskey=h title="Home (Alt + H)"><img src=https://blog.matiaspan.dev/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.matiaspan.dev/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.matiaspan.dev/search/ title=Search><span>Search</span></a></li><li><a href=https://blog.matiaspan.dev/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.matiaspan.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Exploring Dagger: Building a CI/CD pipeline for IaC</h1><div class=post-meta><span title='2023-11-13 00:00:00 -0300 -03'>November 13, 2023</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;matipan&nbsp;|&nbsp;<a href=https://github.com/matipan/matipan.github.io/tree/main/content/posts/exploring-dagger-building-a-ci-cd-pipeline-for-iac.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#using-github-actions>Using Github actions</a><ul><li><a href=#intro>Intro</a></li><li><a href=#building-our-ci>Building our CI</a></li><li><a href=#thoughts>Thoughts</a></li></ul></li><li><a href=#using-the-dagger-client>Using the Dagger client</a><ul><li><a href=#intro-1>Intro</a></li><li><a href=#building-our-ci-1>Building our CI</a></li><li><a href=#thoughts-1>Thoughts</a></li></ul></li><li><a href=#using-dagger-modules>Using Dagger modules</a><ul><li><a href=#intro-2>Intro</a></li><li><a href=#building-our-ci-2>Building our CI</a></li><li><a href=#thoughts-2>Thoughts</a></li></ul></li><li><a href=#comparison>Comparison</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p><a href=https://dagger.io/>Dagger</a> is a new tool that promises to fix the yaml and custom scripts mess that CI/CD currently is by building pipelines as code with one of the <a href=https://docs.dagger.io/>supported SDKs</a>. I&rsquo;m in the process of learning this tool, understanding where it may fall short and where it shines and I decided that sharing some of the exploration I do and the learnings it leaves me with would be useful. This is the first post in a <a href=https://blog.matiaspan.dev/tags/exploring-dagger/>series of blog posts</a> that look at Dagger from different perspectives. In this post I do a deep dive on how to build a pipeline for an IaC repository. I explore building this using &ldquo;native&rdquo; Github actions, the Dagger client and the newer approach of Dagger modules.</p><p><strong>NOTE</strong>: Dagger is in very active development so by the time you read this blog post some things might have changed.</p><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><p>We have a repository that holds all of our infrastructure in a declarative way using <a href=https://www.pulumi.com/>Pulumi&rsquo;s</a> Go SDK. Every time we want to provision, change or delete some infrastructure we need to:</p><ol><li>Create a pull request with the necessary changes</li><li>Wait for CI to show what changes will be applied by posting a comment to the PR</li><li>Merge it</li><li>Wait for CI on the main branch to apply those changes to the given environment</li></ol><p>This process will utilize two operations pulumi provides:</p><ul><li><code>pulumi preview</code>: show a diff of the changes that <em>would</em> be applied.</li><li><code>pulumi up</code>: apply the requested changes.</li></ul><p>We are going to build this workflow using Github actions first to understand how the current &ldquo;status quo&rdquo; works when it comes to building these types of pipelines. Then, we will build this same solution using Dagger. There is currently two ways of building this with Dagger and we will explore both: i) using the <a href=#using-the-dagger-client>&ldquo;traditional&rdquo; dagger client</a>; and ii) using the newer concept of <a href=#using-dagger-modules>Dagger modules</a>.</p><h2 id=using-github-actions>Using Github actions<a hidden class=anchor aria-hidden=true href=#using-github-actions>#</a></h2><h3 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h3><p>When you build pipelines with Github actions you have to write a YAML file on <code>.github/workflows</code> that contains the definition of your workflow, where each step can:</p><ul><li>Run specific commands such as <code>curl</code>.</li><li>Refer to existing Actions that are a part of Github&rsquo;s marketplace. These actions usually either install dependencies on the runner or perform specific actions.</li><li>Refer to a custom action defined within the repository (or an external repo if you are paying for Github).</li></ul><p>For example, if we want to run <code>go build</code> on a Go project we would re-use the <code>actions/setup-go</code> function that installs Go in the runner where our command executes and simply call <code>go build</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>pull_request</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/setup-go@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>go-version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;stable&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Go build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>go build</span><span class=w>
</span></span></span></code></pre></div><p>In this case we used the already provided <a href=https://github.com/actions/setup-go>setup-go</a> action. If our tool would not have already been supported, we would have had to build the action ourselve. Refer to this <a href=https://resources.github.com/learn/pathways/automation/advanced/building-your-first-custom-github-action/>blog post</a> to learn how you would build one.</p><h3 id=building-our-ci>Building our CI<a hidden class=anchor aria-hidden=true href=#building-our-ci>#</a></h3><p>Our CI process has two separate workflows for:</p><ul><li><strong>Previewing changes</strong>: used when a PR is created against <code>main</code> to execute <code>pulumi preview</code> and show the diff as a comment on the pull request.</li><li><strong>Applying changes</strong>: used when a commit is pushed to <code>main</code> to run <code>pulumi up</code> and apply the desired changes.</li></ul><p>In both workflows we will to run a specific <code>pulumi</code> command. To do this we could create a workflow that has a step that installs Pulumi&rsquo;s CLI and another that calls the command. However, if we browse the <a href="https://github.com/marketplace?type=actions">Github marketplace</a> we will see that the team behind Pulumi has already built a <a href=https://github.com/pulumi/actions>custom action</a> that allows us to do just that. Our Workflow that reuses this action looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Preview infrastructure changes on Pull Requests</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>pull_request</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>preview</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Preview</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/setup-go@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>go-version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;stable&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Configure AWS Credentials</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>aws-actions/configure-aws-credentials@v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>aws-access-key-id</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_ACCESS_KEY_ID }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>aws-region</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_REGION }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>aws-secret-access-key</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_SECRET_ACCESS_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>go mod download</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>pulumi/actions@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=l>preview</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>stack-name</span><span class=p>:</span><span class=w> </span><span class=l>org-name/stack-name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>comment-on-pr</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>github-token</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.GITHUB_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>PULUMI_ACCESS_TOKEN</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.PULUMI_ACCESS_TOKEN }}</span><span class=w>
</span></span></span></code></pre></div><p>In this workflow we are: i) setting up Go since pulumi requires Go to be installed; ii) setting up AWS&rsquo;s credentials required by Pulumi; iii) use Pulumi&rsquo;s action to run the command. As you can see, using Pulumi&rsquo;s action allowed us to solve two problems at once:</p><ul><li>Run the <code>pulumi preview</code> command by setting <code>command: preview</code> and</li><li>post a PR Comment with the diff the preview generated.</li></ul><p>The <code>up</code> workflow would be very similar to this one with the small change of removing <code>comment-on-pr</code>.</p><h3 id=thoughts>Thoughts<a hidden class=anchor aria-hidden=true href=#thoughts>#</a></h3><p>Given the simplicity of this workflow I don&rsquo;t have much to complain about. The two things I personally did not like where:</p><ul><li><em>Developing it</em>: seems like a shallow complaint, but I personally do not like the &ldquo;development experience&rdquo; that YAML gives you. Understanding which parameters the action accepted required me to look at a README on the action&rsquo;s repo and one trial and error.</li><li><em>Testing</em>: it is not easy to validate this workflows locally. You could use a custom tool such as <a href=https://github.com/nektos/act>act</a> but it does not offer a good DX and it is often quite heavy.</li></ul><p>It is true that as the CI process evolves and gets more complicated this two things become more problematic. But for this simple use case it was not too bad.</p><h2 id=using-the-dagger-client>Using the Dagger client<a hidden class=anchor aria-hidden=true href=#using-the-dagger-client>#</a></h2><h3 id=intro-1>Intro<a hidden class=anchor aria-hidden=true href=#intro-1>#</a></h3><p>To build a CI process using Dagger&rsquo;s client you first have to choose from one of the available SDKs. We&rsquo;ll use Go since our Pulumi infra is using it already. The first thing we&rsquo;ll do is create a folder called <code>ci</code> and write a little <code>main.go</code> file that uses Dagger&rsquo;s SDK to communicate with the Dagger engine to print a hello world:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;dagger.io/dagger&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>client</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dagger</span><span class=p>.</span><span class=nf>Connect</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>client</span><span class=p>.</span><span class=nf>Container</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>From</span><span class=p>(</span><span class=s>&#34;alpine:latest&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;echo&#34;</span><span class=p>,</span> <span class=s>&#34;hello world&#34;</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can run this with <code>go run</code> or with Dagger&rsquo;s CLI that shows us a detailed output of what is happening:</p><p><img loading=lazy src=/images/dagger-run-example.png alt="screenshot of a terminal showing a DAG of operations that was performed by the Dagger engine"></p><p>Internally the Dagger engine is leveraging <a href=https://github.com/moby/buildkit>BuildKit</a> to perform all the operations we ask for. This means that this code we wrote will on any machine and produce the same result. You could use this SDK to replace Dockerfiles entirely but for now we&rsquo;ll focus on our IaC pipeline.</p><h3 id=building-our-ci-1>Building our CI<a hidden class=anchor aria-hidden=true href=#building-our-ci-1>#</a></h3><p>Let&rsquo;s start by writing the Dagger program. Now, given that we need to support two operations (and both need the same flag) we need this program to manage arguments and execute different code based on those. Let&rsquo;s rewrite our <code>main.go</code> to support that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>stack</span> <span class=p>=</span> <span class=nx>flag</span><span class=p>.</span><span class=nf>Parse</span><span class=p>(</span><span class=s>&#34;stack&#34;</span><span class=p>,</span> <span class=s>&#34;prod&#34;</span><span class=p>,</span> <span class=s>&#34;pulumi stack to use&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>flag</span><span class=p>.</span><span class=nf>Parse</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=s>&#34;specify an operation. Possible values: preview,up&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;preview&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Run `pulumi preview --stack &lt;stack&gt;`
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>case</span> <span class=s>&#34;up&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Run `pulumi up --stack &lt;stack&gt;`
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As we saw previously, all we need to do is execute <code>pulumi preview</code> and post the result of it to Github. Since Dagger is containers all the way we can re-use existing images that have the dependencies we need. In this case all we need is pulumi, so we&rsquo;ll use the <a href=https://hub.docker.com/r/pulumi/pulumi>official image</a> to build a <code>Container</code> that has the necessary go dependencies, code and secrets to run commands:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>baseContainer</span><span class=p>(</span><span class=nx>client</span> <span class=o>*</span><span class=nx>dagger</span><span class=p>.</span><span class=nx>Client</span><span class=p>)</span> <span class=o>*</span><span class=nx>dagger</span><span class=p>.</span><span class=nx>Container</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>pulumiToken</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>SetSecret</span><span class=p>(</span><span class=s>&#34;pulumi_token&#34;</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;PULUMI_ACCESS_TOKEN&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>awsAccessKey</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>SetSecret</span><span class=p>(</span><span class=s>&#34;aws_access_key&#34;</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;AWS_ACCESS_KEY_ID&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>awsSecretKey</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nf>SetSecret</span><span class=p>(</span><span class=s>&#34;aws_secret_key&#34;</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;AWS_SECRET_ACCESS_KEY&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>client</span><span class=p>.</span>
</span></span><span class=line><span class=cl>		<span class=nf>Container</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>From</span><span class=p>(</span><span class=s>&#34;pulumi/pulumi:latest&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;PULUMI_ACCESS_TOKEN&#34;</span><span class=p>,</span> <span class=nx>pulumiToken</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;AWS_ACCESS_KEY_ID&#34;</span><span class=p>,</span> <span class=nx>awsAccessKey</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;AWS_SECRET_ACCESS_KEY&#34;</span><span class=p>,</span> <span class=nx>awsSecretKey</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithMountedDirectory</span><span class=p>(</span><span class=s>&#34;/infra&#34;</span><span class=p>,</span> <span class=nx>client</span><span class=p>.</span><span class=nf>Host</span><span class=p>().</span><span class=nf>Directory</span><span class=p>(</span><span class=s>&#34;.&#34;</span><span class=p>)).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithWorkdir</span><span class=p>(</span><span class=s>&#34;/infra&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithEntrypoint</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;/bin/bash&#34;</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=s>&#34;go mod tidy&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In this <code>baseContainer</code> function we are building and returning a container that:</p><ul><li>Starts from pulumi&rsquo;s oficial image <a href=https://hub.docker.com/r/pulumi/pulumi>pulumi/pulumi:latest</a></li><li>Has the credentials necessary to communicate with Pulumi and AWS obtained from the environment but stored in a secure way using <a href=https://docs.dagger.io/723462/use-secrets/>Dagger secrets</a>.</li><li>Has the infrastructure code mounted in the working directory <code>/infra</code> and</li><li>has all the go dependencies that our pulumi code requires.</li></ul><p>This container can now be used to execute pulumi commands:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>switch</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;preview&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>out</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>baseContainer</span><span class=p>(</span><span class=nx>client</span><span class=p>).</span>
</span></span><span class=line><span class=cl>			<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;pulumi preview --stack %s --non-interactive --diff&#34;</span><span class=p>,</span> <span class=o>*</span><span class=nx>stack</span><span class=p>)}).</span>
</span></span><span class=line><span class=cl>			<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;up&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Run `pulumi up`
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Running this locally using Dagger&rsquo;s CLI shows a lot of output, so I&rsquo;ll show here only the relevant pulumi bits:</p><pre tabindex=0><code>┃ @ Previewing update.....
┃ @ Previewing update.....
┃   pulumi:pulumi:Stack: (same)
┃     [urn=urn:pulumi:prod::networking::pulumi:pulumi:Stack::networking-prod]
┃         ~ aws:ecs/service:Service: (update)
┃             [id=arn:aws:ecs:us-west-2:831445021348:service/services-0187c44/ninjas]
┃             [urn=urn:pulumi:prod::networking::awsx:ecs:FargateService$aws:ecs/service:Service::ninjas]
┃             [provider=urn:pulumi:prod::networking::pulumi:providers:aws::default_5_35_0::321a9293-c7af-42be-a9fd-061afc82e317]
┃           ~ networkConfiguration: {
┃               ~ securityGroups: [
┃                   ~ [0]: &#34;sg-0b2ee5e5403c1ca86&#34; =&gt; &#34;sg-0cf0cbf24b1e39535&#34;
┃                 ]
┃             }
┃     - aws:ec2/securityGroup:SecurityGroup: (delete)
┃         [id=sg-0b2ee5e5403c1ca86]
┃         [urn=urn:pulumi:prod::networking::aws:ec2/securityGroup:SecurityGroup::svc-sg]
┃         description        : &#34;Allow TCP traffic on port 8080 from the VPC&#34;
┃         egress             : [
┃             [0]: {
┃                 cidrBlocks: [
┃                     [0]: &#34;0.0.0.0/0&#34;
┃                 ]
┃                 fromPort  : 0
┃                 protocol  : &#34;-1&#34;
┃                 self      : false
┃                 toPort    : 0
┃             }
┃         ]
┃         ingress            : [
┃             [0]: {
┃                 cidrBlocks : [
┃                     [0]: &#34;10.1.0.0/16&#34;
┃                 ]
┃                 description: &#34;allow TCP traffic on 8080 from the VPC&#34;
┃                 fromPort   : 8080
┃                 protocol   : &#34;tcp&#34;
┃                 self       : false
┃                 toPort     : 8080
┃             }
┃         ]
┃         name               : &#34;svc-sg-6648e89&#34;
┃         revokeRulesOnDelete: false
┃         vpcId              : &#34;vpc-0ec0d8d2118fc95c5&#34;
┃ Resources:
┃     ~ 1 to update
┃     - 1 to delete
┃     2 changes. 59 unchanged
</code></pre><p>You probably already saw a big difference in how CI gets built with Dagger. We first developed the code that performs the operations we want and tested it locally instead of writing a YAML and pushing it to the repo to test it. To run this in Github&rsquo;s CI environment we, unfortunately, have to write some YAML (maybe <a href=https://dagger.io/cloud>Dagger cloud</a> will fix that some day? 👀):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>preview</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>pull_request</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>dagger</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>permissions</span><span class=p>:</span><span class=w> </span><span class=l>write-all</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Setup Go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/setup-go@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>go-version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;&gt;=1.21&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install Dagger CLI</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>cd /usr/local &amp;&amp; { curl -L https://dl.dagger.io/dagger/install.sh | sh; cd -; }</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Preview infrastructure changes</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>PULUMI_ACCESS_TOKEN</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.PULUMI_ACCESS_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_ACCESS_KEY_ID</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_ACCESS_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_SECRET_ACCESS_KEY</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_SECRET_ACCESS_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_REGION</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;us-west-2&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>dagger run go run ./ci preview -stack=&lt;your stack&gt;</span><span class=w>
</span></span></span></code></pre></div><p>In this pipeline you can see that we first have to setup the tools we need (Go and Dagger, although Dagger is not strictly necessary) and then we call to our go program using Dagger&rsquo;s CLI and specifying that we want to perform the <code>preview</code> operation on a specific stack.</p><p>This pipeline is missing the capability of posting a comment with the diff that <code>preview</code> generated. Since we are writing Go code for our CI, we can extend our program to use Github&rsquo;s Go SDK and post the comment with the output of the command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>switch</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=s>&#34;preview&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>out</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>baseContainer</span><span class=p>(</span><span class=nx>client</span><span class=p>).</span>
</span></span><span class=line><span class=cl>			<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;pulumi preview --stack %s --non-interactive --diff&#34;</span><span class=p>,</span> <span class=o>*</span><span class=nx>stack</span><span class=p>)}).</span>
</span></span><span class=line><span class=cl>			<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// if the token is not specified we won&#39;t post anything
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>token</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;GITHUB_TOKEN&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>token</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// GITHUB_REPOSITORY is in the format: `:owner/:repo`
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>repo</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;GITHUB_REPOSITORY&#34;</span><span class=p>),</span> <span class=s>&#34;/&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1>// On pull requests GITHUB_REF has the format: `refs/pull/:prNumber/merge`
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>ref</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nf>Getenv</span><span class=p>(</span><span class=s>&#34;GITHUB_REF&#34;</span><span class=p>),</span> <span class=s>&#34;/&#34;</span><span class=p>)[</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nf>postComment</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>out</span><span class=p>,</span> <span class=nx>token</span><span class=p>,</span> <span class=nx>repo</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>repo</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nx>ref</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>postComment</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>content</span><span class=p>,</span> <span class=nx>githubToken</span><span class=p>,</span> <span class=nx>owner</span><span class=p>,</span> <span class=nx>repo</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>pr</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>body</span> <span class=o>:=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;```\n%s\n```&#34;</span><span class=p>,</span> <span class=nx>content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>client</span> <span class=o>:=</span> <span class=nx>github</span><span class=p>.</span><span class=nf>NewClient</span><span class=p>(</span><span class=kc>nil</span><span class=p>).</span><span class=nf>WithAuthToken</span><span class=p>(</span><span class=nx>githubToken</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nx>Issues</span><span class=p>.</span><span class=nf>CreateComment</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>owner</span><span class=p>,</span> <span class=nx>repo</span><span class=p>,</span> <span class=nx>pr</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>github</span><span class=p>.</span><span class=nx>IssueComment</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Body</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>body</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This can still be tested locally. All we have to do is specify the <code>GITHUB_TOKEN</code> environment variable so that our program can communicate with Github&rsquo;s API.</p><p>Here is a sample of this working at my repository:</p><p><img loading=lazy src=/images/dagger-pr-comment.png alt="image that shows a comment in a Github PR containing a Pulumi diff that explains the infrastructure changes that want to be applied"></p><p>Implementing the <code>up</code> command would be very similar to the preview but without calling the <code>postComment</code> function.</p><h3 id=thoughts-1>Thoughts<a hidden class=anchor aria-hidden=true href=#thoughts-1>#</a></h3><p>You can probably see how much code we had to write in order to implement the same functionality that a few lines of YAML gave us. In the case of Github actions, all we had to do was reuse Pulumi&rsquo;s action and specify an option of <code>comment-on-pr</code> to get everything we wanted. With the Dagger SDK we had to first build the container that had the dependencies we needed and then use Github&rsquo;s SDK to post the comment we wanted. If Pulumi&rsquo;s action was not already provided and we had to build it ourselves then I do believe that the approach of using Dagger, where we can run it locally and &ldquo;tap&rdquo; into the ecosystem of the language we are using, would have been much more superior.</p><p>While this example in particular is rather simple, imagine how this process get more complicated when you want to run integration tests that require multiple containers running. I&rsquo;m doing some exploration on this part that I hope to post soon, but in the meantime you can refer to <a href="https://www.youtube.com/watch?v=NjABt0owEeI">this YouTube video</a> to see an example of a more complicated CI process being implemented with Dagger.</p><h2 id=using-dagger-modules>Using Dagger modules<a hidden class=anchor aria-hidden=true href=#using-dagger-modules>#</a></h2><h3 id=intro-2>Intro<a hidden class=anchor aria-hidden=true href=#intro-2>#</a></h3><p>Dagger modules is, at the time of this writing, a brand new concept the Dagger team implemented to address some of the problems we mentioned previously. The two that we will focus on here are:</p><ul><li><em>Re-usability</em>: with the Dagger SDK we built a program that can run pulumi commands, but it is not re-usable by myself or any other person that might need to do this same thing.</li><li><em>Declarative Interface</em>: our Go program is very &ldquo;raw&rdquo; when it comes to declaring its API. If you want to understand what is the &ldquo;API&rdquo; of this CLI, you have to look at the code, see the <code>switch</code> statement and notice that we support <code>up</code> and <code>preview</code> as valid values.</li></ul><p>When it comes to re-usability the first thing we need to understand is: how can we make what we built available to the world? Similar to how the Github marketplace allows us to browse all available actions, the <a href=http://daggerverse.dev/>Daggerverse</a> (still in very early stages) allows us to browse all modules that were developed and published by someone. For example, here is a module that someone (👀) built to run <code>gradle</code> tasks:</p><p><img loading=lazy src=/images/gradle-module.png alt="a webpage of the Daggerverse showing the documentation of a module for running gradle tasks"></p><p>To understand the API that this module has we can use Dagger&rsquo;s CLI and run <code>dagger -m github.com/matipan/daggerverse/gradle functions</code>:</p><p><img loading=lazy src=/images/dagger-functions.png alt="a terminal showing all the operations and their arguments that the Gradle module supports"></p><p>The most interesting bit for me is that you can call other Dagger modules from your own no matter the programming language they are using. For example, the <code>gradle</code> module was built using Go but we can call the <code>gradle.Build</code> function from another Dagger module built with Python:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>dagger</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>dagger.mod</span> <span class=kn>import</span> <span class=n>function</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@function</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>build</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=n>dagger</span><span class=o>.</span><span class=n>Container</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dagger</span><span class=o>.</span><span class=n>gradle</span><span class=p>()</span><span class=o>.</span><span class=n>build</span><span class=p>()</span>
</span></span></code></pre></div><p>When we call this function on our module and we can see that it indeeds uses the Gradle module to perform a build (it failed because, fortunately, we are not writing Java):</p><p><img loading=lazy src=/images/gradle-build.png alt="the output of the dagger call build command that failed to build a Gradle service"></p><h3 id=building-our-ci-2>Building our CI<a hidden class=anchor aria-hidden=true href=#building-our-ci-2>#</a></h3><p>Since Dagger modules can be reused and we can find all modules in the Daggerverse lets see if someone already built a Pulumi module:</p><p><img loading=lazy src=/images/pulumi-not-found.png alt="the Daggerverse website showing that there is no module for pulumi"></p><p>No luck 😕. Well, at the time of this writing the Daggerverse was announced less than a week ago so it makes sense that it is not as &ldquo;crowded&rdquo; as the Github marketplace. But this is great for us. We get to build a pulumi module ourselves, publish it and contribute to this brand new environment that has a lot of promise. Then we&rsquo;ll build our CI process using it.</p><h4 id=building-the-pulumi-module>Building the Pulumi module<a hidden class=anchor aria-hidden=true href=#building-the-pulumi-module>#</a></h4><p>We want to build a module that has an interface similar to Pulumi&rsquo;s Github action where we can run any of the supported pulumi commands. But since we are going to be building it with code we can make it a bit more expressive. We start by initializing our module and specifying that we want to use Go:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>dagger mod init --name pulumi --sdk go
</span></span></code></pre></div><p>This command will generate Go code that we will use to interface with Dagger&rsquo;s SDK as well as a <code>dagger.json</code> file that contains the definition of our module and its dependencies (in this case we won&rsquo;t have any). The sample <code>main.go</code> file that it generated gives us some idea on how to start writing our module:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Pulumi</span> <span class=kd>struct</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// example usage: &#34;dagger call container-echo --string-arg yo&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Pulumi</span><span class=p>)</span> <span class=nf>ContainerEcho</span><span class=p>(</span><span class=nx>stringArg</span> <span class=kt>string</span><span class=p>)</span> <span class=o>*</span><span class=nx>Container</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>dag</span><span class=p>.</span><span class=nf>Container</span><span class=p>().</span><span class=nf>From</span><span class=p>(</span><span class=s>&#34;alpine:latest&#34;</span><span class=p>).</span><span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;echo&#34;</span><span class=p>,</span> <span class=nx>stringArg</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// example usage: &#34;dagger call grep-dir --directory-arg . --pattern GrepDir&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Pulumi</span><span class=p>)</span> <span class=nf>GrepDir</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>directoryArg</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>,</span> <span class=nx>pattern</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>dag</span><span class=p>.</span><span class=nf>Container</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>From</span><span class=p>(</span><span class=s>&#34;alpine:latest&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithMountedDirectory</span><span class=p>(</span><span class=s>&#34;/mnt&#34;</span><span class=p>,</span> <span class=nx>directoryArg</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithWorkdir</span><span class=p>(</span><span class=s>&#34;/mnt&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;grep&#34;</span><span class=p>,</span> <span class=s>&#34;-R&#34;</span><span class=p>,</span> <span class=nx>pattern</span><span class=p>,</span> <span class=s>&#34;.&#34;</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We want to start by implementing the 4 operations that the <a href=https://github.com/marketplace/actions/pulumi-cli-action>Pulumi CLI github action</a> supports: <code>up</code>, <code>refresh</code>, <code>destroy</code> and <code>preview</code>. We want each of these operations to be its own function so that when we call <code>dagger functions</code> we can see each operation and users can refer to any one of them separately. Pulumi&rsquo;s main role is to perform operations against our cloud provider so we need to solve the problem of specifying credentials. When we built the Github workflow we had to run the <code>configure-aws-credentials</code> step that left the environment ready for pulumi to communicate with AWS. We can do something similar here but &ldquo;natively&rdquo; within the module. For each cloud provider we want to support we will add a function called <code>With&lt;Provider>Credentials</code> that sets the credentials in a secure way for that specific cloud provider using Dagger&rsquo;s native support for Secrets. We&rsquo;ll do the same thing for specifying pulumi&rsquo;s access token. I&rsquo;ll show here a portion of the code that implements the <code>Up</code> operation to keep it brief, you can see the entire code base of the module on <a href=https://github.com/matipan/daggerverse/tree/main/pulumi>Github</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Pulumi</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>AwsAccessKey</span> <span class=o>*</span><span class=nx>Secret</span>
</span></span><span class=line><span class=cl>	<span class=nx>AwsSecretKey</span> <span class=o>*</span><span class=nx>Secret</span>
</span></span><span class=line><span class=cl>	<span class=nx>PulumiToken</span>  <span class=o>*</span><span class=nx>Secret</span>
</span></span><span class=line><span class=cl>	<span class=nx>Version</span>      <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// FromVersion is an optional function that users can use to specify
</span></span></span><span class=line><span class=cl><span class=c1>// the version of pulumi&#39;s docker image to use as base.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Pulumi</span><span class=p>)</span> <span class=nf>FromVersion</span><span class=p>(</span><span class=nx>version</span> <span class=kt>string</span><span class=p>)</span> <span class=o>*</span><span class=nx>Pulumi</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>.</span><span class=nx>Version</span> <span class=p>=</span> <span class=nx>version</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// WithAwsCredentials sets the AWS credentials to be used by Pulumi.
</span></span></span><span class=line><span class=cl><span class=c1>// Call this function if you want pulumi to point your changes to AWS.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Pulumi</span><span class=p>)</span> <span class=nf>WithAwsCredentials</span><span class=p>(</span><span class=nx>awsAccessKey</span><span class=p>,</span> <span class=nx>awsSecretKey</span> <span class=o>*</span><span class=nx>Secret</span><span class=p>)</span> <span class=o>*</span><span class=nx>Pulumi</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>.</span><span class=nx>AwsAccessKey</span> <span class=p>=</span> <span class=nx>awsAccessKey</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>.</span><span class=nx>AwsSecretKey</span> <span class=p>=</span> <span class=nx>awsSecretKey</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// WithPulumiToken sets the Pulumi token to be used by Pulumi.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Pulumi</span><span class=p>)</span> <span class=nf>WithPulumiToken</span><span class=p>(</span><span class=nx>pulumiToken</span> <span class=o>*</span><span class=nx>Secret</span><span class=p>)</span> <span class=o>*</span><span class=nx>Pulumi</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>.</span><span class=nx>PulumiToken</span> <span class=p>=</span> <span class=nx>pulumiToken</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Up runs the `pulumi up` command for the given stack and directory.
</span></span></span><span class=line><span class=cl><span class=c1>// NOTE: This command will perform changes in your cloud.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Pulumi</span><span class=p>)</span> <span class=nf>Up</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>src</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>,</span> <span class=nx>stack</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>m</span><span class=p>.</span><span class=nf>commandOutput</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>src</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;pulumi up --stack %s --yes --non-interactive&#34;</span><span class=p>,</span> <span class=nx>stack</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// commandOutput runs the given command in the pulumi container and returns its output.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Pulumi</span><span class=p>)</span> <span class=nf>commandOutput</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>src</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>,</span> <span class=nx>command</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ct</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>authenticatedContainer</span><span class=p>(</span><span class=nx>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>ct</span><span class=p>.</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=nx>command</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>Stdout</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// authenticatedContainer returns a pulumi container with the required credentials.
</span></span></span><span class=line><span class=cl><span class=c1>// Users have to set credentials for their cloud provider by using the `With&lt;Provider&gt;Credentials`
</span></span></span><span class=line><span class=cl><span class=c1>// function.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Pulumi</span><span class=p>)</span> <span class=nf>authenticatedContainer</span><span class=p>(</span><span class=nx>src</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>Container</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>m</span><span class=p>.</span><span class=nx>PulumiToken</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;pulumi token is required. Use `with-pulumi-token` to set it&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>ct</span> <span class=o>:=</span> <span class=nf>container</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>PulumiToken</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>Version</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>m</span><span class=p>.</span><span class=nx>AwsAccessKey</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>m</span><span class=p>.</span><span class=nx>AwsSecretKey</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>ct</span> <span class=p>=</span> <span class=nx>ct</span><span class=p>.</span><span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;AWS_ACCESS_KEY_ID&#34;</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>AwsAccessKey</span><span class=p>).</span>
</span></span><span class=line><span class=cl>			<span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;AWS_SECRET_ACCESS_KEY&#34;</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>AwsSecretKey</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;no cloud provider credentails was provided&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>ct</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// container obtains a base container with pulumi&#39;s CLI installed.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>container</span><span class=p>(</span><span class=nx>src</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>,</span> <span class=nx>pulumiToken</span> <span class=o>*</span><span class=nx>Secret</span><span class=p>,</span> <span class=nx>version</span> <span class=kt>string</span><span class=p>)</span> <span class=o>*</span><span class=nx>Container</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>version</span> <span class=o>==</span> <span class=s>&#34;&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>version</span> <span class=p>=</span> <span class=s>&#34;latest&#34;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>dag</span><span class=p>.</span>
</span></span><span class=line><span class=cl>		<span class=nf>Container</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>From</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;pulumi/pulumi:%s&#34;</span><span class=p>,</span> <span class=nx>version</span><span class=p>)).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithSecretVariable</span><span class=p>(</span><span class=s>&#34;PULUMI_ACCESS_TOKEN&#34;</span><span class=p>,</span> <span class=nx>pulumiToken</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithMountedDirectory</span><span class=p>(</span><span class=s>&#34;/infra&#34;</span><span class=p>,</span> <span class=nx>src</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithWorkdir</span><span class=p>(</span><span class=s>&#34;/infra&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithEntrypoint</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;/bin/bash&#34;</span><span class=p>}).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithExec</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;-c&#34;</span><span class=p>,</span> <span class=s>&#34;go mod tidy&#34;</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Since we are writing Go, any variable or function that starts with an Uppercase letter will be part of the interface of this module and developers will see it when calling <code>dagger functions</code>. A few things worth pointing out of this code:</p><ul><li>There are 2 public functions (<code>WithAwsCredentials</code> and <code>WithPulumiToken</code>) that set the credentials for what we want to do and need to be called before our operation. See how they return a reference to the module itself, in Dagger-lang this means that in order for something to happen they require a subcommand (like <code>up</code>). If you want support for your cloud provider you are welcome to make a <a href=https://github.com/matipan/daggerverse>PR</a> 🚀.</li><li>The <code>Up</code> function returns a string and an error, indicating the output of the pulumi command and an error if there was any.</li><li>The <code>authenticatedContainer</code> function is where the magic happens. This function is private and is used to create a container that has the required credentials and dependencies.</li><li>Users of the module can point to a specific version of pulumi using <code>FromVersion</code> and if they don&rsquo;t we default to <code>latest</code>.</li></ul><p>We can test this module locally with my IaC repository. For example the <code>Preview</code> operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>dagger -m github.com/matipan/daggerverse/pulumi call with-aws-credentials --aws-access-key <span class=s2>&#34;&lt;AWS_ACCESS_KEY_ID&gt;&#34;</span> --aws-secret-key <span class=s2>&#34;&lt;AWS_SECRET_ACCESS_KEY&gt;&#34;</span> with-pulumi-token --pulumi-token <span class=s2>&#34;&lt;PULUMI_ACCESS_TOKEN&gt;&#34;</span> preview --src <span class=s2>&#34;.&#34;</span> --stack <span class=s2>&#34;&lt;PULUMI_STACK&gt;&#34;</span>
</span></span></code></pre></div><p>And the output:</p><p><img loading=lazy src=/images/pulumi-preview-module.png alt="pulumi preview output that shows infrastructure changes"></p><p>You can see all the operations this module supports by running <code>dagger -m github.com/matipan/daggerverse/pulumi functions</code> or browsing the homepage of the module in the <a href=https://daggerverse.dev/mod/github.com/matipan/daggerverse/pulumi>Daggerverse</a>.</p><h4 id=building-our-ci-re-using-modules>Building our CI re-using modules<a hidden class=anchor aria-hidden=true href=#building-our-ci-re-using-modules>#</a></h4><p>When now can see in the Daggerverse that there is a <code>pulumi</code> module we can leverage:</p><p><img loading=lazy src=/images/pulumi-module-found.png alt="the Daggerverse website showing the <code>pulumi</code> in the search box and one result"></p><p>This module takes care of the IaC part but for the case of pull requests we wanted to post a comment showing the diff that was generated. Luckily, someone (thanks <a href=https://github.com/aweris>@aweris</a>) already built a <a href=https://daggerverse.dev/mod/github.com/aweris/daggerverse/gh@1c14645e0139a4ca73969bc9314069d8e6d3b18b>Dagger module</a> that allows developers to run any command of the <code>gh</code> CLI. This means we could run <code>gh pr comment &lt;PR> --body '&lt;contents>'</code> from our Dagger code and pass the output that the Pulumi module gave us.</p><p>To get started writing our CI we will create a new &ldquo;module&rdquo; that has the operations our workflow requires. For simplicity we will call them <code>preview</code> and <code>up</code> as well. We&rsquo;ll use Go since we kind of love it here (but remember that with Dagger it does not matter in what language a given module was built):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>dagger mod init --name iac --sdk go
</span></span></code></pre></div><p>Now we can add the dependencies for the two modules we&rsquo;ll use:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>dagger mod use github.com/matipan/daggerverse/pulumi
</span></span><span class=line><span class=cl>dagger mod use github.com/aweris/daggerverse/gh
</span></span></code></pre></div><p>And quickly build our module with the <code>Preview</code> function that uses these dependencies:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Iac</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>AwsAccessKey</span> <span class=o>*</span><span class=nx>Secret</span>
</span></span><span class=line><span class=cl>	<span class=nx>AwsSecretKey</span> <span class=o>*</span><span class=nx>Secret</span>
</span></span><span class=line><span class=cl>	<span class=nx>PulumiToken</span>  <span class=o>*</span><span class=nx>Secret</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Iac</span><span class=p>)</span> <span class=nf>WithCredentials</span><span class=p>(</span><span class=nx>pulumiToken</span><span class=p>,</span> <span class=nx>awsAccessKey</span><span class=p>,</span> <span class=nx>awsSecretKey</span> <span class=o>*</span><span class=nx>Secret</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>.</span><span class=nx>PulumiToken</span> <span class=p>=</span> <span class=nx>pulumiToken</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>.</span><span class=nx>AwsAccessKey</span> <span class=p>=</span> <span class=nx>awsAccessKey</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>.</span><span class=nx>AwsSecretKey</span> <span class=p>=</span> <span class=nx>awsSecretKey</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>m</span> <span class=o>*</span><span class=nx>Iac</span><span class=p>)</span> <span class=nf>Preview</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>src</span> <span class=o>*</span><span class=nx>Directory</span><span class=p>,</span> <span class=nx>stack</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>githubToken</span> <span class=o>*</span><span class=nx>Secret</span><span class=p>,</span> <span class=nx>githubRef</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>diff</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dag</span><span class=p>.</span><span class=nf>Pulumi</span><span class=p>().</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithAwsCredentials</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>AwsAccessKey</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>AwsSecretKey</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>WithPulumiToken</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>PulumiToken</span><span class=p>).</span>
</span></span><span class=line><span class=cl>		<span class=nf>Preview</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>src</span><span class=p>,</span> <span class=nx>stack</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// On pull requests GITHUB_REF has the format: `refs/pull/:prNumber/merge`
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>pr</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>Split</span><span class=p>(</span><span class=nx>githubRef</span><span class=p>,</span> <span class=s>&#34;/&#34;</span><span class=p>)[</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;githubRef did not have the correct format, expected: refs/pull/:prNumber/merge. Got: %s&#34;</span><span class=p>,</span> <span class=nx>githubRef</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>dag</span><span class=p>.</span><span class=nf>Gh</span><span class=p>().</span><span class=nf>Run</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>githubToken</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;pr comment %d --body &#39;%s&#39;&#34;</span><span class=p>,</span> <span class=nx>pr</span><span class=p>,</span> <span class=nx>diff</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>You can see that we are calling the <code>Pulumi</code> module Preview operation and then sending the output of it to the <code>gh</code> module so that it posts the comment on Github. Our Github workflow will now call our module instead:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;preview&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>pull_request</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>dagger</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>permissions</span><span class=p>:</span><span class=w> </span><span class=l>write-all</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Setup Go</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/setup-go@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>go-version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;&gt;=1.21&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Install Dagger CLI</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>cd /usr/local &amp;&amp; { curl -L https://dl.dagger.io/dagger/install.sh | sh; cd -; }</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Preview infrastructure changes</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>PULUMI_ACCESS_TOKEN</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.PULUMI_ACCESS_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_ACCESS_KEY_ID</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_ACCESS_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_SECRET_ACCESS_KEY</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_SECRET_ACCESS_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>AWS_REGION</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;us-west-2&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>GITHUB_TOKEN</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.GITHUB_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>dagger -m ./ci call with-credentials --pulumi-token $PULUMI_ACCESS_TOKEN --aws-access-key $AWS_ACCESS_KEY_ID --aws-secret-key $AWS_SECRET_ACCESS_KEY preview --src &#34;.&#34; --stack &#34;ninjastructure/prod&#34; --github-token $GITHUB_TOKEN --github-ref $GITHUB_REF</span><span class=w>
</span></span></span></code></pre></div><p>The dagger command that was specified in the last step can be run locally which allows us to test things before pushing them.</p><h3 id=thoughts-2>Thoughts<a hidden class=anchor aria-hidden=true href=#thoughts-2>#</a></h3><p>As you can see at the time of this writing the Daggerverse is quite new and does not have many modules already provided. This required us to build the module to interact with Pulumi. However, we were able to find a module that provided us with the capacity to post a comment on the PR that was open. Once we had these dependencies ready to go it was just a matter of referencing them and piping things together, all with code using the programming language I preferred. With the wiring of those modules taken care of it was just a matter of using Dagger&rsquo;s CLI to call our module and perform the operations we wanted. The same command we run locally to test that everything worked correctly was then added to the CI process to finish the entire workflow. If we ever were to migrate from Github actions to say, CircleCI, then it would be a matter of referencing this same command from our CircleCI workflow and that&rsquo;s it.</p><p>The main problem I see with this approach today has to do with caching. Every single operation can potentially be cached and save us from having to recreate the entire environment every time. To achieve this with Dagger we would have to either: i) use the paid offering that provides this caching called <a href=https://dagger.io/cloud>Dagger cloud</a>; ii) deploying a dagger engine with caching in your own infrastructure and point your CI runners to use that version of the engine. That approach is not too bad for simpler use cases, but as soon as you need to scale you&rsquo;ll require multiple instances running.</p><p>As a side note, when we wanted to create our pipeline we had to create a new &ldquo;module&rdquo; that was the entrypoint for our CI. This is because the only way to use other modules today is from within another module. I found this a bit confusing. In programming languages such as Go you can create either libraries or executables. When I hear the word &ldquo;module&rdquo; I think of a library that requires an executable to call it and do something. Maybe it&rsquo;s just a naming thing or maybe I get easily confused.</p><h2 id=comparison>Comparison<a hidden class=anchor aria-hidden=true href=#comparison>#</a></h2><p>When comparing the approach of Github actions and Dagger modules I find two main differences. First of all, Github actions does not give us a process that can be easily testable and extensible. When it comes to extending we would either have to build custom actions or do some setup magic and run custom scripts on top of this yaml. Again, this is a simple process, but CI/CD often gets more complicated as time goes on. And while right now this may not seem like an obvious problem, it always ends up becoming that critical yaml file that nobody wants to touch. The second difference is more &ldquo;conceptual&rdquo;, but it&rsquo;s important to point it out because it requires a mindset shift when it comes to building CI. In the traditional pipeline we can see a &ldquo;stateful&rdquo; approach where each of the steps that are being executed are doing explicit things on the host (i.e the runner) that the subsequent action then reuses:</p><ol><li>Checkout the code of the repository</li><li>Install the latest stable version of Go</li><li>Configure AWS&rsquo;s credentials (technically not needed, we could use env variables directly&mldr;)</li><li>Download go dependencies that pulumi&rsquo;s code uses.</li><li>Run pulumi preview</li></ol><p>Every single one of those actions changed the underlying host in some way and left a state that the subsequent action would then use. This means that when you build a workflow you always operate directly on the host instead of &ldquo;chaining&rdquo; inputs/outputs like you do when building a dag, for example an Airflow dag. I don&rsquo;t particularly like this approach, it is one of the main things that makes this processed hard to test and more importantly very hard to understand.</p><p>With dagger modules we saw a different approach. When we were calling a module we had to explicitly provide all the required resources to perform the specific operation. This is because dagger functions run in a sandboxed environment that can potentially be executed on a different host. This, in my opinion, opens up interesting possibilities for building CI pipelines using reusable APIs that are deployed once and used everywhere. There might be occasions where this stateless approach falls short but I still need to do a deep dive in those special cases. If I compare Dagger&rsquo;s approach with the way the data world works I find a lot of similarities. When you build data pipelines using tools like Airflow, the worker where the operator code gets executed usually only performs HTTP calls. For example, if you build a data pipeline that performs some data transformation using spark on EMR and then ingests that data on a datasource like clickhouse, your Airflow DAG will probably look something like this:</p><ol><li>Use EMR Operator to execute some spark code. Airflow&rsquo;s worker will call AWS&rsquo;s API, ask for a given script to be executed and then wait for completion.</li><li>Use an ECS task or similar to run code that reads the data from S3 and ingest it into clickhouse.</li></ol><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I believe Dagger offers a compelling alternative to yaml and custom scripts in CI/CD pipelines. By leveraging code, we gain expressiveness, reusability, and the ability to integrate with a wide range of tools and services. As Dagger matures, I&rsquo;m excited to see how it will continue to evolve and improve CI/CD practices. However, the current state of the art of Dagger requires a big mindset shift and, while it does offer important benefits, for simpler use cases like the one explored in this blog post the learning curve seems to be a bit steep. I think that in this post we found very interesting primitives that will probably allow us to develop a better experience for all use cases.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.matiaspan.dev/tags/pulumi/>pulumi</a></li><li><a href=https://blog.matiaspan.dev/tags/go/>go</a></li><li><a href=https://blog.matiaspan.dev/tags/aws/>aws</a></li><li><a href=https://blog.matiaspan.dev/tags/dagger/>dagger</a></li><li><a href=https://blog.matiaspan.dev/tags/ci/cd/>ci/cd</a></li><li><a href=https://blog.matiaspan.dev/tags/exploring-dagger/>exploring-dagger</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Exploring Dagger: Building a CI/CD pipeline for IaC on x" href="https://x.com/intent/tweet/?text=Exploring%20Dagger%3a%20Building%20a%20CI%2fCD%20pipeline%20for%20IaC&amp;url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fexploring-dagger-building-a-ci-cd-pipeline-for-iac%2f&amp;hashtags=pulumi%2cgo%2caws%2cdagger%2cci%2fcd%2cexploring-dagger"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Exploring Dagger: Building a CI/CD pipeline for IaC on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fexploring-dagger-building-a-ci-cd-pipeline-for-iac%2f&title=Exploring%20Dagger%3a%20Building%20a%20CI%2fCD%20pipeline%20for%20IaC"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Exploring Dagger: Building a CI/CD pipeline for IaC on ycombinator" href="https://news.ycombinator.com/submitlink?t=Exploring%20Dagger%3a%20Building%20a%20CI%2fCD%20pipeline%20for%20IaC&u=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fexploring-dagger-building-a-ci-cd-pipeline-for-iac%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.matiaspan.dev/>Matias Pan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>