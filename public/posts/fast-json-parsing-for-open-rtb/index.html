<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Fast JSON parsing in Go for OpenRTB | Matias Pan's blog</title>
<meta name=keywords content="go,json"><meta name=description content="The code used for this test can be found here.
TL;DR: when looking into overall performance and usability, json-iter is the clear winner. It gives roughly a 4x improvement over encoding/json and 1.2x over the second most performant option. It is also extremely easy to use. You simply need to import it, define a global variable (that you can call json to make it even easier) and then use it like you would use encoding/json."><meta name=author content="matipan"><link rel=canonical href=https://blog.matiaspan.dev/posts/fast-json-parsing-for-open-rtb/><link crossorigin=anonymous href=/assets/css/stylesheet.a801c217e3c96db9c9df36cb1d2216a9bc5d9fa77b72e2afcdf47fb847f8f015.css integrity="sha256-qAHCF+PJbbnJ3zbLHSIWqbxdn6d7cuKvzfR/uEf48BU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Fast JSON parsing in Go for OpenRTB"><meta property="og:description" content="The code used for this test can be found here.
TL;DR: when looking into overall performance and usability, json-iter is the clear winner. It gives roughly a 4x improvement over encoding/json and 1.2x over the second most performant option. It is also extremely easy to use. You simply need to import it, define a global variable (that you can call json to make it even easier) and then use it like you would use encoding/json."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.matiaspan.dev/posts/fast-json-parsing-for-open-rtb/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-22T00:00:00-03:00"><meta property="article:modified_time" content="2020-11-22T00:00:00-03:00"><meta property="og:site_name" content="Matias Pan's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Fast JSON parsing in Go for OpenRTB"><meta name=twitter:description content="The code used for this test can be found here.
TL;DR: when looking into overall performance and usability, json-iter is the clear winner. It gives roughly a 4x improvement over encoding/json and 1.2x over the second most performant option. It is also extremely easy to use. You simply need to import it, define a global variable (that you can call json to make it even easier) and then use it like you would use encoding/json."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.matiaspan.dev/posts/"},{"@type":"ListItem","position":2,"name":"Fast JSON parsing in Go for OpenRTB","item":"https://blog.matiaspan.dev/posts/fast-json-parsing-for-open-rtb/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Fast JSON parsing in Go for OpenRTB","name":"Fast JSON parsing in Go for OpenRTB","description":"The code used for this test can be found here.\nTL;DR: when looking into overall performance and usability, json-iter is the clear winner. It gives roughly a 4x improvement over encoding/json and 1.2x over the second most performant option. It is also extremely easy to use. You simply need to import it, define a global variable (that you can call json to make it even easier) and then use it like you would use encoding/json.","keywords":["go","json"],"articleBody":"The code used for this test can be found here.\nTL;DR: when looking into overall performance and usability, json-iter is the clear winner. It gives roughly a 4x improvement over encoding/json and 1.2x over the second most performant option. It is also extremely easy to use. You simply need to import it, define a global variable (that you can call json to make it even easier) and then use it like you would use encoding/json.\nServices that serve OpenRTB requests are typically under heavy load and have very strict latency constraints. In this scenario a fast json parser is highly desirable. In the Go ecosystem there are many json parsing libraries that claim to have better performance than encoding/json. The following list are the libraries that I will consider for this test:\neasyjson jsonparser simdjson-go json-iter encoding/json Performance Lets go directly to the performance results. Unmarshaling a standard OpenRTB request with a single imp object yields the following numbers:\ngoos: darwin goarch: amd64 pkg: github.com/matipan/openrtb BenchmarkRequest_UnmarshalJSON/json-iter-12 255331\t4730 ns/op\t1328 B/op\t50 allocs/op BenchmarkRequest_UnmarshalJSON/easyjson-12 197110\t5695 ns/op\t1432 B/op\t28 allocs/op BenchmarkRequest_UnmarshalJSON/jsonparser-12 128836\t9360 ns/op\t5528 B/op\t94 allocs/op BenchmarkRequest_UnmarshalJSON/encoding/json-12 70920\t17180 ns/op\t1752 B/op\t49 allocs/op BenchmarkRequest_UnmarshalJSON/simdjson-go-12 46688\t26658 ns/op\t115388 B/op\t48 allocs/op PASS ok github.com/matipan/openrtb\t7.176s This shows that the fastest option of all is json-iter. It is 1.2x compared to the second, easyjson, 2x compared to jsonparser and about 4x compared to encoding/json. Surprisingly, simdjson is falling way behind being 6x slower than json-iter. I have not done an in depth analysis of why simdjson is this slow. If I do, I will post the results here.\nPerformance-wise json-iter is the clear winner.\nUsability In terms of usability each library requires something different compared to encoding/json:\neasyjson: requires code generation. I’m ok with this to be honest, but it adds yet another command that all developers need to be aware of when modifying your structures. jsonparser: requires a lot of manual parsing to get something working. simdjson-go: requires even more manual parsing than jsonparser. json-iter: requires importing a new library and, if you want to use the fastest option, adding a global variable that has to be used for every unmarshal/marshal call. encoding/json: the familiar encode/decode and marshal/unmarshal API. Below you can see an in depth explanation of how to use each of the libraries shown above. But in my opinion usability-wise json-iter wins again.\nUsing json-iter To use json-iter you can simply import the library and define a global variable using the fastest option:\nimport jsoniter \"github.com/json-iterator/go\" var json = jsoniter.ConfigFastest Once you’ve done that you can use the familiar Marshal/Unmarshal and Encode/Decode API.\nUsing easyjson To use easyjson you need to first install the CLI they provide:\ngo get -u github.com/mailru/easyjson/... With this CLI you can generate code that parses JSON into and out of the structure. First, add the following directive to your structure:\n//easyjson:json type Request struct { ... } With that you can run this command that will generate functions that match the signature of encoding/json.Marshaler and encoding/json.Unmarshaler:\neasyjson -byte -pkg Using jsonparser There are many ways to parse a JSON using the jsonparser library. I went with an approach that has a lot of code but most of it is boiler plate, which means that adding new fields is relatively straight forward and does not require a lot of modifications. We start by defining all the fields that the OpenRTB request will have and mapping their IDs to the path were it can be found:\ntype fieldIdx iota const ( fieldDevice fieldIdx = iota fieldImp fieldApp fieldId fieldAt fieldBcat fieldBadv fieldBapp fieldRegs ) type rtbFieldDef struct { idx fieldIdx path []string } var ( reqFields = []rtbFieldDef{ {fieldDevice, []string{\"device\"}}, {fieldImp, []string{\"imp\"}}, {fieldApp, []string{\"app\"}}, {fieldId, []string{\"id\"}}, {fieldAt, []string{\"at\"}}, {fieldBcat, []string{\"bcat\"}}, {fieldBadv, []string{\"badv\"}}, {fieldBapp, []string{\"bapp\"}}, {fieldRegs, []string{\"regs\"}}, } reqPaths = rtbBuildPaths(reqFields) ) func rtbBuildPaths(fields []rtbFieldDef) [][]string { ret := make([][]string, 0, 10) for _, f := range fields { ret = append(ret, f.path) } return ret } Once we’ve defined the fields for this top level object we can write the parsing function. This function basically iterates over the JSON one key at a time. For each key it finds it tries to map it to one of the keys we defined in the reqPaths variable. If it finds a match then it sets the value to the corresponding fields on the structure:\nfunc (r *Request) UnmarshalJSONReq(b []byte) error { jsonparser.EachKey(b, func(idx int, value []byte, vt jsonparser.ValueType, err error) { r.setField(idx, value, vt, err) }, reqPaths...) return nil } func (data *Request) setField(idx int, value []byte, _ jsonparser.ValueType, _ error) { switch fieldIdx(idx) { case fieldDevice: data.Device = \u0026Device{} data.Device.UnmarshalJSONReq(value) case fieldImp: data.Imps = []*Imp{} jsonparser.ArrayEach(value, func(arrdata []byte, dataType jsonparser.ValueType, offset int, err error) { imp := \u0026Imp{} if err := imp.UnmarshalJSONReq(value); err != nil { return } data.Imps = append(data.Imps, imp) }) case fieldApp: data.App = \u0026App{} data.App.UnmarshalJSONReq(value) case fieldId: data.ID = string(value) case fieldAt: data.At, _ = strconv.ParseInt(string(value), 10, 64) case fieldBcat: data.BCat = []string{} jsonparser.ArrayEach(value, func(arrdata []byte, dataType jsonparser.ValueType, offset int, err error) { data.BCat = append(data.BCat, string(value)) }) case fieldBadv: data.BAdv = []string{} jsonparser.ArrayEach(value, func(arrdata []byte, dataType jsonparser.ValueType, offset int, err error) { data.BAdv = append(data.BAdv, string(value)) }) case fieldBapp: data.BApp = []string{} jsonparser.ArrayEach(value, func(arrdata []byte, dataType jsonparser.ValueType, offset int, err error) { data.BApp = append(data.BApp, string(value)) }) case fieldRegs: data.Regs = \u0026Regs{} data.Regs.UnmarshalJSONReq(value) } } With this you can start parsing the top level object. However, if you look at the fieldApp key for example you can see that we are calling an UnmarshalJSONReq function of the App object. This structure essentially does the same thing than the top level one. It first defines the list of fields that we care about and their corresponding paths and then implements the function that iterates over each key setting the corresponding values:\nconst ( fieldAppName fieldIdx = iota fieldAppPubId fieldAppBundle fieldAppLanguage fieldAppId fieldExtDevUserId ) var ( appFields = []rtbFieldDef{ {fieldAppName, []string{\"name\"}}, {fieldAppPubId, []string{\"publisher\", \"id\"}}, {fieldAppBundle, []string{\"bundle\"}}, {fieldAppLanguage, []string{\"content\", \"language\"}}, {fieldAppId, []string{\"id\"}}, {fieldExtDevUserId, []string{\"ext\", \"devuserid\"}}, } appPaths = rtbBuildPaths(appFields) ) func (a *App) setField(idx int, value []byte, _ jsonparser.ValueType, _ error) { switch fieldIdx(idx) { case fieldAppName: a.Name = string(value) case fieldAppPubId: a.Publisher.ID = string(value) case fieldAppBundle: a.Bundle = string(value) case fieldAppLanguage: a.Content.Language = string(value) case fieldAppId: a.ID = string(value) case fieldExtDevUserId: a.Ext.Devuserid = string(value) } } func (a *App) UnmarshalJSONReq(b []byte) error { a.Publisher = \u0026Publisher{} a.Content = \u0026AppContent{} a.Ext = \u0026AppExt{} jsonparser.EachKey(b, func(idx int, value []byte, vt jsonparser.ValueType, err error) { a.setField(idx, value, vt, err) }, appPaths...) return nil } If you want to add a new object to the structure you need to implement all this boiler plate. However, if you just want to add a new field to an existing object the change is relatively straight forward. This is why jsonparser in terms of usability is worst than json-iter but still better than simdjson-go.\nUsing simdjson-go There is a lot of code involved when parsing JSON with simdjson-go. Here I went with an approach that basically requires you to add more parsing code every time you add a new field. We could implement this with reflection like encoding/json does but that would hurt the performance even more.\nImplementing a parser for simdjson requires one to start iterating over the tape that the library generated and map each field according to its type. We start by parsing the top level object and identifying it as a simdjson.TypeObject:\nfunc (r *Request) UnmarshalJSONSimd(b []byte) error { parsed, err := simdjson.Parse(b, nil) if err != nil { return err } var ( iter = parsed.Iter() obj = \u0026simdjson.Object{} tmp = \u0026simdjson.Iter{} ) for { typ := iter.Advance() switch typ { case simdjson.TypeRoot: if typ, tmp, err = iter.Root(tmp); err != nil { return err } switch typ { case simdjson.TypeObject: if obj, err = tmp.Object(obj); err != nil { return err } return r.parse(tmp, obj) } default: return nil } } } Within the simdjson.TypeObject switch we can start parsing the OpenRTB request, but the request has many internal objects and each of them can have a different type. This means that for every one of those types we need to parse it separately. To keep this example brief we will only parse two types, Object and Array:\nfunc (r *Request) parse(tmp *simdjson.Iter, obj *simdjson.Object) error { arr := \u0026simdjson.Array{} for { name, t, err := obj.NextElementBytes(tmp) if err != nil { return err } if t == simdjson.TypeNone { break } switch t { case simdjson.TypeObject: if err := r.parseObject(name, tmp); err != nil { return err } case simdjson.TypeArray: if _, err := tmp.Array(arr); err != nil { return err } if err := r.parseArray(name, tmp, arr); err != nil { return err } } } return nil } Lets double click on the parsing of an Object. Within an OpenRTB request we have many different objects, like device and app. Each object will require its own parsing function that will map each available key to the corresponding value of the structure. For example, parsing the device object would look something like this:\nfunc (d *Device) parse(iter *simdjson.Iter, obj *simdjson.Object) error { for { name, t, err := obj.NextElementBytes(iter) if err != nil { return err } if t == simdjson.TypeNone { return nil } switch t { case simdjson.TypeInt: n, err := iter.Int() if err != nil { return err } switch { case bytes.Compare(name, hKey) == 0: d.H = n case bytes.Compare(name, wKey) == 0: d.W = n case bytes.Compare(name, dtKey) == 0: d.DeviceType = n case bytes.Compare(name, ctKey) == 0: d.ConnectionType = n } case simdjson.TypeString: b, err := iter.StringBytes() if err != nil { return err } switch { case bytes.Compare(name, ipKey) == 0: d.IP = string(b) case bytes.Compare(name, uaKey) == 0: d.UA = string(b) case bytes.Compare(name, osKey) == 0: d.OS = string(b) case bytes.Compare(name, osvKey) == 0: d.OSV = string(b) case bytes.Compare(name, ifaKey) == 0: d.IFA = string(b) case bytes.Compare(name, hwvKey) == 0: d.HWV = string(b) case bytes.Compare(name, modelKey) == 0: d.Model = string(b) case bytes.Compare(name, dntKey) == 0: d.DNT = string(b) case bytes.Compare(name, langKey) == 0: d.Language = string(b) } } } } In this example you can see how tedious it would be to add a new field or top level object. Which is why from a usability point of view, simdjson-go is way behind.\nConclusion When looking into overall performance and usability, json-iter is the clear winner. It gives roughly a 4x improvement over encoding/json and 1.2x over the second most performant option. It is also extremely easy to use. You simply need to import it, define a global variable (that you can call json to make it even easier) and then use it like you would use encoding/json. On top of that, the community around json-iter seems to be really active. And this library is supported on many different languages.\n","wordCount":"1811","inLanguage":"en","datePublished":"2020-11-22T00:00:00-03:00","dateModified":"2020-11-22T00:00:00-03:00","author":{"@type":"Person","name":"matipan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.matiaspan.dev/posts/fast-json-parsing-for-open-rtb/"},"publisher":{"@type":"Organization","name":"Matias Pan's blog","logo":{"@type":"ImageObject","url":"https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.matiaspan.dev/ accesskey=h title="Home (Alt + H)"><img src=https://blog.matiaspan.dev/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.matiaspan.dev/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.matiaspan.dev/search/ title=Search><span>Search</span></a></li><li><a href=https://blog.matiaspan.dev/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.matiaspan.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Fast JSON parsing in Go for OpenRTB</h1><div class=post-meta><span title='2020-11-22 00:00:00 -0300 -03'>November 22, 2020</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;matipan&nbsp;|&nbsp;<a href=https://github.com/matipan/matipan.github.io/tree/main/content/posts/fast-json-parsing-for-open-rtb.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#performance>Performance</a></li><li><a href=#usability>Usability</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>The code used for this test can be found <a href=https://github.com/matipan/openrtb>here</a>.</p><p><strong>TL;DR</strong>: when looking into overall performance and usability, <code>json-iter</code> is the clear winner. It gives roughly a 4x improvement over <code>encoding/json</code> and 1.2x over the second most performant option. It is also extremely easy to use. You simply need to import it, define a global variable (that you can call <code>json</code> to make it even easier) and then use it like you would use <code>encoding/json</code>.</p><p>Services that serve OpenRTB requests are typically under heavy load and have very strict latency constraints. In this scenario a fast json parser is highly desirable. In the Go ecosystem there are many json parsing libraries that claim to have better performance than <code>encoding/json</code>. The following list are the libraries that I will consider for this test:</p><ul><li><a href=https://github.com/mailru/easyjson>easyjson</a></li><li><a href=https://github.com/buger/jsonparser>jsonparser</a></li><li><a href=https://github.com/simdjson/simdjson>simdjson-go</a></li><li><a href=https://github.com/json-iter/go>json-iter</a></li><li><a href=https://pkg.go.dev/encoding/json>encoding/json</a></li></ul><h3 id=performance>Performance<a hidden class=anchor aria-hidden=true href=#performance>#</a></h3><p>Lets go directly to the performance results. Unmarshaling a standard OpenRTB request with a single <code>imp</code> object yields the following numbers:</p><pre tabindex=0><code>goos: darwin
goarch: amd64
pkg: github.com/matipan/openrtb
BenchmarkRequest_UnmarshalJSON/json-iter-12        	  255331	      4730 ns/op	    1328 B/op	      50 allocs/op
BenchmarkRequest_UnmarshalJSON/easyjson-12         	  197110	      5695 ns/op	    1432 B/op	      28 allocs/op
BenchmarkRequest_UnmarshalJSON/jsonparser-12       	  128836	      9360 ns/op	    5528 B/op	      94 allocs/op
BenchmarkRequest_UnmarshalJSON/encoding/json-12    	   70920	     17180 ns/op	    1752 B/op	      49 allocs/op
BenchmarkRequest_UnmarshalJSON/simdjson-go-12      	   46688	     26658 ns/op	  115388 B/op	      48 allocs/op
PASS
ok  	github.com/matipan/openrtb	7.176s
</code></pre><p>This shows that the fastest option of all is <code>json-iter</code>. It is 1.2x compared to the second, <code>easyjson</code>, 2x compared to <code>jsonparser</code> and about 4x compared to <code>encoding/json</code>. Surprisingly, <code>simdjson</code> is falling way behind being 6x slower than <code>json-iter</code>. I have not done an in depth analysis of why simdjson is this slow. If I do, I will post the results here.</p><p>Performance-wise <code>json-iter</code> is the clear winner.</p><h3 id=usability>Usability<a hidden class=anchor aria-hidden=true href=#usability>#</a></h3><p>In terms of usability each library requires something different compared to <code>encoding/json</code>:</p><ul><li><a href=https://github.com/mailru/easyjson>easyjson</a>: requires code generation. I&rsquo;m ok with this to be honest, but it adds yet another command that all developers need to be aware of when modifying your structures.</li><li><a href=https://github.com/buger/jsonparser>jsonparser</a>: requires a lot of manual parsing to get something working.</li><li><a href=https://github.com/simdjson/simdjson>simdjson-go</a>: requires even more manual parsing than jsonparser.</li><li><a href=https://github.com/json-iter/go>json-iter</a>: requires importing a new library and, if you want to use the fastest option, adding a global variable that has to be used for every unmarshal/marshal call.</li><li><a href=https://pkg.go.dev/encoding/json>encoding/json</a>: the familiar encode/decode and marshal/unmarshal API.</li></ul><p>Below you can see an in depth explanation of how to use each of the libraries shown above. But in my opinion usability-wise <code>json-iter</code> wins again.</p><h4 id=using-json-iter>Using json-iter<a hidden class=anchor aria-hidden=true href=#using-json-iter>#</a></h4><p>To use json-iter you can simply import the library and define a global variable using the fastest option:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=nx>jsoniter</span> <span class=s>&#34;github.com/json-iterator/go&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>json</span> <span class=p>=</span> <span class=nx>jsoniter</span><span class=p>.</span><span class=nx>ConfigFastest</span>
</span></span></code></pre></div><p>Once you&rsquo;ve done that you can use the familiar Marshal/Unmarshal and Encode/Decode API.</p><h4 id=using-easyjson>Using easyjson<a hidden class=anchor aria-hidden=true href=#using-easyjson>#</a></h4><p>To use <code>easyjson</code> you need to first install the CLI they provide:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>go get -u github.com/mailru/easyjson/...
</span></span></code></pre></div><p>With this CLI you can generate code that parses JSON into and out of the structure. First, add the following directive to your structure:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//easyjson:json
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Request</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>With that you can run this command that will generate functions that match the signature of <code>encoding/json.Marshaler</code> and <code>encoding/json.Unmarshaler</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>easyjson -byte -pkg
</span></span></code></pre></div><h4 id=using-jsonparser>Using jsonparser<a hidden class=anchor aria-hidden=true href=#using-jsonparser>#</a></h4><p>There are many ways to parse a JSON using the <code>jsonparser</code> library. I went with an approach that has a lot of code but most of it is boiler plate, which means that adding new fields is relatively straight forward and does not require a lot of modifications. We start by defining all the fields that the OpenRTB request will have and mapping their IDs to the path were it can be found:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>fieldIdx</span> <span class=kc>iota</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldDevice</span> <span class=nx>fieldIdx</span> <span class=p>=</span> <span class=kc>iota</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldImp</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldApp</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldId</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldAt</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldBcat</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldBadv</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldBapp</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldRegs</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>rtbFieldDef</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>idx</span>  <span class=nx>fieldIdx</span>
</span></span><span class=line><span class=cl>	<span class=nx>path</span> <span class=p>[]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>reqFields</span> <span class=p>=</span> <span class=p>[]</span><span class=nx>rtbFieldDef</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldDevice</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;device&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldImp</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;imp&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldApp</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;app&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldId</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;id&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldAt</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;at&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldBcat</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;bcat&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldBadv</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;badv&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldBapp</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;bapp&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldRegs</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;regs&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>reqPaths</span> <span class=p>=</span> <span class=nf>rtbBuildPaths</span><span class=p>(</span><span class=nx>reqFields</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>rtbBuildPaths</span><span class=p>(</span><span class=nx>fields</span> <span class=p>[]</span><span class=nx>rtbFieldDef</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ret</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([][]</span><span class=kt>string</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>f</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>fields</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>ret</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>ret</span><span class=p>,</span> <span class=nx>f</span><span class=p>.</span><span class=nx>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>ret</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Once we&rsquo;ve defined the fields for this top level object we can write the parsing function. This function basically iterates over the JSON one key at a time. For each key it finds it tries to map it to one of the keys we defined in the <code>reqPaths</code> variable. If it finds a match then it sets the value to the corresponding fields on the structure:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Request</span><span class=p>)</span> <span class=nf>UnmarshalJSONReq</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>jsonparser</span><span class=p>.</span><span class=nf>EachKey</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>value</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>vt</span> <span class=nx>jsonparser</span><span class=p>.</span><span class=nx>ValueType</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span><span class=p>.</span><span class=nf>setField</span><span class=p>(</span><span class=nx>idx</span><span class=p>,</span> <span class=nx>value</span><span class=p>,</span> <span class=nx>vt</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>},</span> <span class=nx>reqPaths</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>data</span> <span class=o>*</span><span class=nx>Request</span><span class=p>)</span> <span class=nf>setField</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>value</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>_</span> <span class=nx>jsonparser</span><span class=p>.</span><span class=nx>ValueType</span><span class=p>,</span> <span class=nx>_</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=nf>fieldIdx</span><span class=p>(</span><span class=nx>idx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldDevice</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>Device</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Device</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>Device</span><span class=p>.</span><span class=nf>UnmarshalJSONReq</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldImp</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>Imps</span> <span class=p>=</span> <span class=p>[]</span><span class=o>*</span><span class=nx>Imp</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>jsonparser</span><span class=p>.</span><span class=nf>ArrayEach</span><span class=p>(</span><span class=nx>value</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>arrdata</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>dataType</span> <span class=nx>jsonparser</span><span class=p>.</span><span class=nx>ValueType</span><span class=p>,</span> <span class=nx>offset</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>imp</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>Imp</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>imp</span><span class=p>.</span><span class=nf>UnmarshalJSONReq</span><span class=p>(</span><span class=nx>value</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=nx>data</span><span class=p>.</span><span class=nx>Imps</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>Imps</span><span class=p>,</span> <span class=nx>imp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldApp</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>App</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>App</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>App</span><span class=p>.</span><span class=nf>UnmarshalJSONReq</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldId</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>ID</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldAt</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>At</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>ParseInt</span><span class=p>(</span><span class=nb>string</span><span class=p>(</span><span class=nx>value</span><span class=p>),</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldBcat</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>BCat</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>jsonparser</span><span class=p>.</span><span class=nf>ArrayEach</span><span class=p>(</span><span class=nx>value</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>arrdata</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>dataType</span> <span class=nx>jsonparser</span><span class=p>.</span><span class=nx>ValueType</span><span class=p>,</span> <span class=nx>offset</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>data</span><span class=p>.</span><span class=nx>BCat</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>BCat</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>value</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldBadv</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>BAdv</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>jsonparser</span><span class=p>.</span><span class=nf>ArrayEach</span><span class=p>(</span><span class=nx>value</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>arrdata</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>dataType</span> <span class=nx>jsonparser</span><span class=p>.</span><span class=nx>ValueType</span><span class=p>,</span> <span class=nx>offset</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>data</span><span class=p>.</span><span class=nx>BAdv</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>BAdv</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>value</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldBapp</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>BApp</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>jsonparser</span><span class=p>.</span><span class=nf>ArrayEach</span><span class=p>(</span><span class=nx>value</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>arrdata</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>dataType</span> <span class=nx>jsonparser</span><span class=p>.</span><span class=nx>ValueType</span><span class=p>,</span> <span class=nx>offset</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>data</span><span class=p>.</span><span class=nx>BApp</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>BApp</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>value</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldRegs</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>Regs</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Regs</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>data</span><span class=p>.</span><span class=nx>Regs</span><span class=p>.</span><span class=nf>UnmarshalJSONReq</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>With this you can start parsing the top level object. However, if you look at the <code>fieldApp</code> key for example you can see that we are calling an <code>UnmarshalJSONReq</code> function of the <code>App</code> object. This structure essentially does the same thing than the top level one. It first defines the list of fields that we care about and their corresponding paths and then implements the function that iterates over each key setting the corresponding values:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldAppName</span> <span class=nx>fieldIdx</span> <span class=p>=</span> <span class=kc>iota</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldAppPubId</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldAppBundle</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldAppLanguage</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldAppId</span>
</span></span><span class=line><span class=cl>	<span class=nx>fieldExtDevUserId</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>appFields</span> <span class=p>=</span> <span class=p>[]</span><span class=nx>rtbFieldDef</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldAppName</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;name&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldAppPubId</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;publisher&#34;</span><span class=p>,</span> <span class=s>&#34;id&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldAppBundle</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;bundle&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldAppLanguage</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;content&#34;</span><span class=p>,</span> <span class=s>&#34;language&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldAppId</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;id&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span><span class=nx>fieldExtDevUserId</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;ext&#34;</span><span class=p>,</span> <span class=s>&#34;devuserid&#34;</span><span class=p>}},</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>appPaths</span> <span class=p>=</span> <span class=nf>rtbBuildPaths</span><span class=p>(</span><span class=nx>appFields</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>a</span> <span class=o>*</span><span class=nx>App</span><span class=p>)</span> <span class=nf>setField</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>value</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>_</span> <span class=nx>jsonparser</span><span class=p>.</span><span class=nx>ValueType</span><span class=p>,</span> <span class=nx>_</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=nf>fieldIdx</span><span class=p>(</span><span class=nx>idx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldAppName</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>a</span><span class=p>.</span><span class=nx>Name</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldAppPubId</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>a</span><span class=p>.</span><span class=nx>Publisher</span><span class=p>.</span><span class=nx>ID</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldAppBundle</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>a</span><span class=p>.</span><span class=nx>Bundle</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldAppLanguage</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>a</span><span class=p>.</span><span class=nx>Content</span><span class=p>.</span><span class=nx>Language</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldAppId</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>a</span><span class=p>.</span><span class=nx>ID</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>fieldExtDevUserId</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>a</span><span class=p>.</span><span class=nx>Ext</span><span class=p>.</span><span class=nx>Devuserid</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>a</span> <span class=o>*</span><span class=nx>App</span><span class=p>)</span> <span class=nf>UnmarshalJSONReq</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span><span class=p>.</span><span class=nx>Publisher</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Publisher</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span><span class=p>.</span><span class=nx>Content</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>AppContent</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span><span class=p>.</span><span class=nx>Ext</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>AppExt</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>jsonparser</span><span class=p>.</span><span class=nf>EachKey</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>idx</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>value</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>vt</span> <span class=nx>jsonparser</span><span class=p>.</span><span class=nx>ValueType</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>a</span><span class=p>.</span><span class=nf>setField</span><span class=p>(</span><span class=nx>idx</span><span class=p>,</span> <span class=nx>value</span><span class=p>,</span> <span class=nx>vt</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>},</span> <span class=nx>appPaths</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If you want to add a new object to the structure you need to implement all this boiler plate. However, if you just want to add a new field to an existing object the change is relatively straight forward. This is why <code>jsonparser</code> in terms of usability is worst than <code>json-iter</code> but still better than <code>simdjson-go</code>.</p><h4 id=using-simdjson-go>Using simdjson-go<a hidden class=anchor aria-hidden=true href=#using-simdjson-go>#</a></h4><p>There is a lot of code involved when parsing JSON with simdjson-go. Here I went with an approach that basically requires you to add more parsing code every time you add a new field. We could implement this with reflection like <code>encoding/json</code> does but that would hurt the performance even more.</p><p>Implementing a parser for <code>simdjson</code> requires one to start iterating over the tape that the library generated and map each field according to its type. We start by parsing the top level object and identifying it as a <code>simdjson.TypeObject</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Request</span><span class=p>)</span> <span class=nf>UnmarshalJSONSimd</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>parsed</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>simdjson</span><span class=p>.</span><span class=nf>Parse</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>iter</span> <span class=p>=</span> <span class=nx>parsed</span><span class=p>.</span><span class=nf>Iter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>obj</span>  <span class=p>=</span> <span class=o>&amp;</span><span class=nx>simdjson</span><span class=p>.</span><span class=nx>Object</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>		<span class=nx>tmp</span>  <span class=p>=</span> <span class=o>&amp;</span><span class=nx>simdjson</span><span class=p>.</span><span class=nx>Iter</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>typ</span> <span class=o>:=</span> <span class=nx>iter</span><span class=p>.</span><span class=nf>Advance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>switch</span> <span class=nx>typ</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>simdjson</span><span class=p>.</span><span class=nx>TypeRoot</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>typ</span><span class=p>,</span> <span class=nx>tmp</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>iter</span><span class=p>.</span><span class=nf>Root</span><span class=p>(</span><span class=nx>tmp</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>switch</span> <span class=nx>typ</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>simdjson</span><span class=p>.</span><span class=nx>TypeObject</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>obj</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>tmp</span><span class=p>.</span><span class=nf>Object</span><span class=p>(</span><span class=nx>obj</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>r</span><span class=p>.</span><span class=nf>parse</span><span class=p>(</span><span class=nx>tmp</span><span class=p>,</span> <span class=nx>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Within the <code>simdjson.TypeObject</code> switch we can start parsing the OpenRTB request, but the request has many internal objects and each of them can have a different type. This means that for every one of those types we need to parse it separately. To keep this example brief we will only parse two types, <code>Object</code> and <code>Array</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>Request</span><span class=p>)</span> <span class=nf>parse</span><span class=p>(</span><span class=nx>tmp</span> <span class=o>*</span><span class=nx>simdjson</span><span class=p>.</span><span class=nx>Iter</span><span class=p>,</span> <span class=nx>obj</span> <span class=o>*</span><span class=nx>simdjson</span><span class=p>.</span><span class=nx>Object</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>arr</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>simdjson</span><span class=p>.</span><span class=nx>Array</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>name</span><span class=p>,</span> <span class=nx>t</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.</span><span class=nf>NextElementBytes</span><span class=p>(</span><span class=nx>tmp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>t</span> <span class=o>==</span> <span class=nx>simdjson</span><span class=p>.</span><span class=nx>TypeNone</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>switch</span> <span class=nx>t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>simdjson</span><span class=p>.</span><span class=nx>TypeObject</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>parseObject</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>tmp</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>simdjson</span><span class=p>.</span><span class=nx>TypeArray</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>tmp</span><span class=p>.</span><span class=nf>Array</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>parseArray</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>tmp</span><span class=p>,</span> <span class=nx>arr</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Lets double click on the parsing of an <code>Object</code>. Within an OpenRTB request we have many different objects, like <code>device</code> and <code>app</code>. Each object will require its own parsing function that will map each available key to the corresponding value of the structure. For example, parsing the <code>device</code> object would look something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>Device</span><span class=p>)</span> <span class=nf>parse</span><span class=p>(</span><span class=nx>iter</span> <span class=o>*</span><span class=nx>simdjson</span><span class=p>.</span><span class=nx>Iter</span><span class=p>,</span> <span class=nx>obj</span> <span class=o>*</span><span class=nx>simdjson</span><span class=p>.</span><span class=nx>Object</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>name</span><span class=p>,</span> <span class=nx>t</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.</span><span class=nf>NextElementBytes</span><span class=p>(</span><span class=nx>iter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>t</span> <span class=o>==</span> <span class=nx>simdjson</span><span class=p>.</span><span class=nx>TypeNone</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>switch</span> <span class=nx>t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>simdjson</span><span class=p>.</span><span class=nx>TypeInt</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>n</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>iter</span><span class=p>.</span><span class=nf>Int</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>switch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>hKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>H</span> <span class=p>=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>wKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>W</span> <span class=p>=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>dtKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>DeviceType</span> <span class=p>=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>ctKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>ConnectionType</span> <span class=p>=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>simdjson</span><span class=p>.</span><span class=nx>TypeString</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>b</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>iter</span><span class=p>.</span><span class=nf>StringBytes</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>switch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>ipKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>IP</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>uaKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>UA</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>osKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>OS</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>osvKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>OSV</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>ifaKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>IFA</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>hwvKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>HWV</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>modelKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>Model</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>dntKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>DNT</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>case</span> <span class=nx>bytes</span><span class=p>.</span><span class=nf>Compare</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>langKey</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=nx>d</span><span class=p>.</span><span class=nx>Language</span> <span class=p>=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In this example you can see how tedious it would be to add a new field or top level object. Which is why from a usability point of view, <code>simdjson-go</code> is way behind.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>When looking into overall performance and usability, <code>json-iter</code> is the clear winner. It gives roughly a 4x improvement over <code>encoding/json</code> and 1.2x over the second most performant option. It is also extremely easy to use. You simply need to import it, define a global variable (that you can call <code>json</code> to make it even easier) and then use it like you would use <code>encoding/json</code>. On top of that, the community around <code>json-iter</code> seems to be really active. And this library is supported on many different languages.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.matiaspan.dev/tags/go/>go</a></li><li><a href=https://blog.matiaspan.dev/tags/json/>json</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Fast JSON parsing in Go for OpenRTB on x" href="https://x.com/intent/tweet/?text=Fast%20JSON%20parsing%20in%20Go%20for%20OpenRTB&amp;url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2ffast-json-parsing-for-open-rtb%2f&amp;hashtags=go%2cjson"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Fast JSON parsing in Go for OpenRTB on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2ffast-json-parsing-for-open-rtb%2f&title=Fast%20JSON%20parsing%20in%20Go%20for%20OpenRTB"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Fast JSON parsing in Go for OpenRTB on ycombinator" href="https://news.ycombinator.com/submitlink?t=Fast%20JSON%20parsing%20in%20Go%20for%20OpenRTB&u=https%3a%2f%2fblog.matiaspan.dev%2fposts%2ffast-json-parsing-for-open-rtb%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.matiaspan.dev/>Matias Pan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>