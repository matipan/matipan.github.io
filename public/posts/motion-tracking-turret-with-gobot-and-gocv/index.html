<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Motion tracking turret with Gobot and GoCV - Part 1 | Matias Pan's blog</title>
<meta name=keywords content="go"><meta name=description content="The title says it, motion tracking turret using only Go, ready to have some func?
This blog post will be divided into three main parts: Motion detection with GoCV, Controlling servo motors with Gobot and Putting it all together. In the first part, we build a lightweight motion detection algorithm that can run on low-power devices such as the RPi. In the second part we will show how to control servo motors with Gobot from the Raspberry Pi and in the last part we&rsquo;ll explain how to go from detecting an object on an image to telling exactly the angles in which the servos need to move in order to track it."><meta name=author content="matipan"><link rel=canonical href=https://blog.matiaspan.dev/posts/motion-tracking-turret-with-gobot-and-gocv/><link crossorigin=anonymous href=/assets/css/stylesheet.a801c217e3c96db9c9df36cb1d2216a9bc5d9fa77b72e2afcdf47fb847f8f015.css integrity="sha256-qAHCF+PJbbnJ3zbLHSIWqbxdn6d7cuKvzfR/uEf48BU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Motion tracking turret with Gobot and GoCV - Part 1"><meta property="og:description" content="The title says it, motion tracking turret using only Go, ready to have some func?
This blog post will be divided into three main parts: Motion detection with GoCV, Controlling servo motors with Gobot and Putting it all together. In the first part, we build a lightweight motion detection algorithm that can run on low-power devices such as the RPi. In the second part we will show how to control servo motors with Gobot from the Raspberry Pi and in the last part we&rsquo;ll explain how to go from detecting an object on an image to telling exactly the angles in which the servos need to move in order to track it."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.matiaspan.dev/posts/motion-tracking-turret-with-gobot-and-gocv/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-10-18T00:00:00-03:00"><meta property="article:modified_time" content="2018-10-18T00:00:00-03:00"><meta property="og:site_name" content="Matias Pan's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Motion tracking turret with Gobot and GoCV - Part 1"><meta name=twitter:description content="The title says it, motion tracking turret using only Go, ready to have some func?
This blog post will be divided into three main parts: Motion detection with GoCV, Controlling servo motors with Gobot and Putting it all together. In the first part, we build a lightweight motion detection algorithm that can run on low-power devices such as the RPi. In the second part we will show how to control servo motors with Gobot from the Raspberry Pi and in the last part we&rsquo;ll explain how to go from detecting an object on an image to telling exactly the angles in which the servos need to move in order to track it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.matiaspan.dev/posts/"},{"@type":"ListItem","position":2,"name":"Motion tracking turret with Gobot and GoCV - Part 1","item":"https://blog.matiaspan.dev/posts/motion-tracking-turret-with-gobot-and-gocv/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Motion tracking turret with Gobot and GoCV - Part 1","name":"Motion tracking turret with Gobot and GoCV - Part 1","description":"The title says it, motion tracking turret using only Go, ready to have some func?\nThis blog post will be divided into three main parts: Motion detection with GoCV, Controlling servo motors with Gobot and Putting it all together. In the first part, we build a lightweight motion detection algorithm that can run on low-power devices such as the RPi. In the second part we will show how to control servo motors with Gobot from the Raspberry Pi and in the last part we\u0026rsquo;ll explain how to go from detecting an object on an image to telling exactly the angles in which the servos need to move in order to track it.","keywords":["go"],"articleBody":"The title says it, motion tracking turret using only Go, ready to have some func?\nThis blog post will be divided into three main parts: Motion detection with GoCV, Controlling servo motors with Gobot and Putting it all together. In the first part, we build a lightweight motion detection algorithm that can run on low-power devices such as the RPi. In the second part we will show how to control servo motors with Gobot from the Raspberry Pi and in the last part we’ll explain how to go from detecting an object on an image to telling exactly the angles in which the servos need to move in order to track it.\nFor this blog post I assume that you already know Go. If you don’t but want to learn, there are lots of resources out there. Anyway, a good and simple place to start is the Go tour.\nThis entire project is hosted on Github.\nBefore we start let me show you what you will get once you are done if you follow this series of blog posts: Just kidding, this is what you will have(for real this time): Looks lethal, right? Lets dive in and see how we can build this sophisticated piece of machinery. Starting of with the list of things you’ll need to follow this tutorial:\nTwo MG90 tower pro micro servos: MercadoLibre - Amazon. One Raspberry Pi 3 B+ with Raspbian installed: MercadoLibre - Amazon. A bunch of cables and a breadboard: MercadoLibre - Amazon. One 5V and 2A power source: MercadoLibre - Amazon. Either a 3D printer or a shop that can print the case(although you could build your own) C270 Logitech web camera is what I used, but any other model should work: MercadoLibre - Amazon. 5V laser(it’s not the best fit but we’ll probably update it in the future): MercadoLibre - Amazon. Bonus: soldering iron if you want to build your own PCB or solder some cables Note: if you want to use different things go ahead, but I don’t guarantee they will work with the same code.\nMotion detection with GoCV You might ask what is this GoCV thing he’s talking about? Well, first lets explain what OpenCV is. OpenCV is a library for computer vision, better yet, is the library for computer vision. It has a whole lot of functions, types and interfaces that allow us to manipulate images by applying already implemented filters and image-manipulation algorithms. It’s a really cool project, you should definitely check it out.\nThe thing is that OpenCV is implemented in C++ and it has interfaces for Java and Python. But don’t be afraid my gopher-friend, the Hybridgroup has got us. Along with other libraries they implemented a Go wrapper for OpenCV. They did this by using CGo to call C code from Go code and that C code calls the corresponding C++ code of OpenCV. It’s really efficient and works pretty well. Lucky for us, this wrapper is really fast and most of the OpenCV functionality is already there.\nInstallation We are going to be running this program on a Raspberry Pi but since Go is nice and lets us do cross-compilation we will only install GoCV and OpenCV on our development machine. So head over to GoCV’s how to install section and follow the steps required for your platform. It’ll take a while so I’ll wait here till you are back.\nExtra: if you want to debug and change the code while testing in the Pi you can install Go and after that install GoCV for Raspbian following this instructions.\nMotion detection algorithm You back? Awesome. Lets explain just a bit about how the motion detection algorithm works so that you understand what it’s going on and can tweak it to your needs.\nSince we are going to run this on the Pi, we are not going to use a fancy already trained neural network with near zero error margin. Instead we will do something relatively simple:\nWhen the program starts we take a picture, convert it to gray and blur it using a Guassian filter. That first frame will be considered our background so try not be there when it starts. Constantly read new frames, perform the same conversion we did before, compute the absolute difference between the first frame and the current frame, apply a threshold to the image so that we create a binary image where the area of movement will look really bright. Finally, dilate the resulting binary image and find the biggest contour. We will consider that contour our area of movement. Once all these filters were applied our image will look something like this: Time to implement this using GoCV.\nFirst, lets write a program that opens the feed of a camera to read images, stores the first frame and starts reading new frames non stop while showing them on a window(error handling for now is out of scope). I’m using device 0, to check which devices you have available you can do ls /dev/video*:\npackage main import ( \"log\" \"gocv.io/x/gocv\" ) var ( firstFrame = gocv.NewMat() frame = gocv.NewMat() ) func main() { window := gocv.NewWindow(\"Motion\") video, _ := gocv.OpenVideoCapture(0) video.Read(\u0026firstFrame) for { video.Read(\u0026frame) window.IMShow(frame) if window.WaitKey(1) == 27 { break } } video.Close() window.Close() firstFrame.Close() frame.Close() } If you run this program you’ll basically be streaming from your camera to the window that just opened. To quit this window you can hit escape, that is what that if window.WaitKey(1) == 27 is doing.\nSince each frame we read(including the first one) needs to be converted to a gray-scale image first and blurred later, we are going to write a function that does this for us:\nfunc convertFrame(src gocv.Mat, dst *gocv.Mat) { gocv.Resize(src, \u0026src, image.Point{X: 500, Y: 500}, 0, 0, gocv.InterpolationLinear) gocv.CvtColor(src, dst, gocv.ColorBGRToGray) gocv.GaussianBlur(*dst, dst, image.Point{X: 21, Y: 21}, 0, 0, gocv.BorderReflect101) } Lets walk through that function. First, we are resizing the image with the Resize function since working with squared images is a lot easier and faster. Then we use the CvtColor function to convert the image to gray-scale and finally, we apply the GaussianBlur to the gray image so that we get the blurred image we wanted.\nNow rewrite your previous program to call this function each time we read a new frame(including the first one). Basically add the line convertFrame(img, \u0026img) after each video.Read, where img is the gocv.Mat you used to read a new frame. If all went well, then the window should display images that look kinda like this: We have the first frame and the current frame already converted to gray scale and blurred, now we need to compute the absolute difference between those two and apply the required threshold and dilation to the resulting difference:\ngocv.AbsDiff(firstFrame, frame, \u0026difference) gocv.Threshold(difference, \u0026difference, 50, 255, gocv.ThresholdBinary) gocv.Dilate(difference, \u0026difference, kernel) The name of this functions are a bit self explanatory. AbsDiff computes the absolute difference between the first frame and the new frame and stores that difference on the difference mat. Threshold converts the gray image to a binary image by applying a fixed-level thresholding to each pixel and finally, Dilate dilates the image by using the specific kernel element, in this case our kernel is empty.\nThe best thing you can do to understand all this better is to read the docs for each function and play around with the values that they receive, for example, what happens when you change those two magic numbers that the Threshold function receives? What about the type of the threshold?\nIf you are curious here, here are most of the different types of thresholds that you can apply to an image: Lets add those filters to our code and we’ll display the difference mat instead of the normal frame mat we’ve been displaying so far:\npackage main import ( \"image\" \"gocv.io/x/gocv\" ) var ( firstFrame = gocv.NewMat() frame = gocv.NewMat() difference = gocv.NewMat() kernel = gocv.NewMat() ) func main() { window := gocv.NewWindow(\"Motion\") video, _ := gocv.OpenVideoCapture(0) video.Read(\u0026firstFrame) convertFrame(firstFrame, \u0026firstFrame) for { video.Read(\u0026frame) convertFrame(frame, \u0026frame) gocv.AbsDiff(firstFrame, frame, \u0026difference) gocv.Threshold(difference, \u0026difference, 50, 255, gocv.ThresholdBinary) gocv.Dilate(difference, \u0026difference, kernel) window.IMShow(difference) if window.WaitKey(1) == 27 { break } } video.Close() window.Close() firstFrame.Close() frame.Close() } func convertFrame(src gocv.Mat, dst *gocv.Mat) { gocv.Resize(src, \u0026src, image.Point{X: 500, Y: 500}, 0, 0, gocv.InterpolationLinear) gocv.CvtColor(src, dst, gocv.ColorBGRToGray) gocv.GaussianBlur(*dst, dst, image.Point{X: 21, Y: 21}, 0, 0, gocv.BorderReflect101) } Try running this program by first having the camera point directly at you when the program first starts. What happens when you move around? Or even better, what happens when you leave the chair? You are going to see yourself all bright, but you aren’t there, are you? What kind of sorcery is this!!??\nWell that’s what it’s supposed to happen. Remember that all the filters we are applying are over the absolute difference of the first frame and the current frame. This means that if you are on the first frame you will be part of the “background” and whenever you leave the image there will be a difference on that area since instead of you sitting there the image will pick up everything that was behind you. This is why you see yourself sitting there even though you are not. It’s either that or magic, who knows.\nTry running this code without you being there for the first frame. Once the program is running pop in front of the camera, you should be looking into an image that resembles this: OK, we have our big bright spot on our image, now is time that we find some contours. I have to admit I thought this was going to be really hard, but thanks to GoCV’s FindContours function all we have to do is call it, iterate over all the contours and pick the contour that has the biggest area. Lets write a function that does exactly that but it also makes sure that the areas are bigger than some minimum:\n// bestContour obtains the biggest contour in the frame provided is bigger // than the minArea. func bestContour(frame gocv.Mat, minArea float64) []image.Point { cnts := gocv.FindContours(frame, gocv.RetrievalExternal, gocv.ChainApproxSimple) var ( bestCnt []image.Point bestArea = minArea ) for _, cnt := range cnts { if area := gocv.ContourArea(cnt); area \u003e bestArea { bestArea = area bestCnt = cnt } } return bestCnt } We will call this function with the difference mat, since that is the one where we applied all the filters. After this function ends, we will either have the biggest contour that was found on the image or nothing at all. We can see whether we have results or not by checking the len of the []image.Point array that was returned. If we have a contour then we will draw a rectangle on the base image to show were was the area of movement found:\npackage main import ( \"image\" \"image/color\" \"gocv.io/x/gocv\" ) var ( firstFrame = gocv.NewMat() frame = gocv.NewMat() gray = gocv.NewMat() difference = gocv.NewMat() kernel = gocv.NewMat() motion = gocv.NewWindow(\"Motion\") threshold = gocv.NewWindow(\"Threshold\") rectColor = color.RGBA{G: 255} textColor = color.RGBA{B: 255} statusPoint = image.Pt(10, 20) ) func main() { video, _ := gocv.OpenVideoCapture(0) motion.ResizeWindow(500, 500) threshold.ResizeWindow(500, 500) motion.MoveWindow(0, 0) threshold.MoveWindow(500, 0) video.Read(\u0026firstFrame) convertFrame(firstFrame, \u0026firstFrame) for { video.Read(\u0026frame) convertFrame(frame, \u0026gray) gocv.AbsDiff(firstFrame, gray, \u0026difference) gocv.Threshold(difference, \u0026difference, 50, 255, gocv.ThresholdBinary) gocv.Dilate(difference, \u0026difference, kernel) cnt := bestContour(difference.Clone(), 5000) if len(cnt) == 0 { if imShow() { break } continue } rect := gocv.BoundingRect(cnt) gocv.Rectangle(\u0026frame, rect, rectColor, 2) gocv.PutText(\u0026frame, \"Motion detected\", statusPoint, gocv.FontHersheyPlain, 1.2, textColor, 2) if imShow() { break } } video.Close() motion.Close() threshold.Close() firstFrame.Close() gray.Close() difference.Close() frame.Close() } func imShow() bool { motion.IMShow(frame) threshold.IMShow(difference) return motion.WaitKey(1) == 27 || threshold.WaitKey(1) == 27 } func convertFrame(src gocv.Mat, dst *gocv.Mat) { gocv.Resize(src, \u0026src, image.Point{X: 500, Y: 500}, 0, 0, gocv.InterpolationLinear) gocv.CvtColor(src, dst, gocv.ColorBGRToGray) gocv.GaussianBlur(*dst, dst, image.Point{X: 21, Y: 21}, 0, 0, gocv.BorderReflect101) } // bestContour obtains the biggest contour in the frame provided is bigger // than the minArea. func bestContour(frame gocv.Mat, minArea float64) []image.Point { cnts := gocv.FindContours(frame, gocv.RetrievalExternal, gocv.ChainApproxSimple) var ( bestCnt []image.Point bestArea = minArea ) for _, cnt := range cnts { if area := gocv.ContourArea(cnt); area \u003e bestArea { bestArea = area bestCnt = cnt } } return bestCnt } We made a lot of changes in that code, lets walk through each of them. First off, we now have two windows instead of one, why? Well, we are going to be displaying two different types of images. In the motion window we will display the normal image with the rectangle drawn on top of the area of motion(if there is any). In the threshold window we will show the difference mat we’ve been showing so far. We also did a few resizes and moved the windows over so that they are displayed side by side.\nSince now we want to preserve the colors of the images we are reading, we can not use the same frame mat when we call convertFrame. This is why we have the new gray mat that we use for the conversion.\nThe most important change of the previous code is right here:\ncnt := bestContour(difference.Clone(), 5000) if len(cnt) == 0 { if imShow() { break } continue } rect := gocv.BoundingRect(cnt) gocv.Rectangle(\u0026frame, rect, rectColor, 2) gocv.PutText(\u0026frame, \"Motion detected\", statusPoint, gocv.FontHersheyPlain, 1.2, textColor, 2) First, we call the bestContour function to obtain the biggest area of movement. If there are no results, we simply call the new imShow image that displays the images without drawing anything on them. But if we have results then we first have to find the rectangle of that area using the BoundingRect function, once we have that we simply draw the rectangle on our image with Rectangle and display the “Motion detected” text on our image.\nIf all went well, when you run this code and pop in front of the camera you should have something similar to this: And voila! You have motion detection! Don’t go out and celebrate with a beer yet. We need to compile this to a binary that can run on the RPi, move that binary there and run it. In order to see this program running on the raspberry pi, you will need to have a display connected to it.\nYou can compile the binary for the RPi with the following command:\nGOOS=linux GOARCH=arm GOARM=5 go build Once you have your binary, you can send it over with scp:\nscp @: Change those parameters accordingly and run the command. SSH into the RPi and run the binary, if you have a video camera connected to the Pi that can be identified with the same ID you’ve been using, then you should see the same image you saw when you ran this program on your development machine.\nCongrats! Now you can go and have some beers!\nConclusion On this blog post you saw how to build a simple and lightweight motion detection program with GoCV and how to compile and run that on the raspberry pi. The idea is to connect two servos and make them follow the area of movement. All that will be explained in Part 2 and Part 3 of this blog post, so stick around for that!\nThank you!\n","wordCount":"2535","inLanguage":"en","datePublished":"2018-10-18T00:00:00-03:00","dateModified":"2018-10-18T00:00:00-03:00","author":{"@type":"Person","name":"matipan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.matiaspan.dev/posts/motion-tracking-turret-with-gobot-and-gocv/"},"publisher":{"@type":"Organization","name":"Matias Pan's blog","logo":{"@type":"ImageObject","url":"https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.matiaspan.dev/ accesskey=h title="Home (Alt + H)"><img src=https://blog.matiaspan.dev/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.matiaspan.dev/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.matiaspan.dev/search/ title=Search><span>Search</span></a></li><li><a href=https://blog.matiaspan.dev/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.matiaspan.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Motion tracking turret with Gobot and GoCV - Part 1</h1><div class=post-meta><span title='2018-10-18 00:00:00 -0300 -03'>October 18, 2018</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;matipan&nbsp;|&nbsp;<a href=https://github.com/matipan/matipan.github.io/tree/main/content/posts/motion-tracking-turret-with-gobot-and-gocv.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#motion-detection-with-gocv>Motion detection with GoCV</a><ul><li></li></ul></li></ul></nav></div></details></div><div class=post-content><p>The title says it, motion tracking turret using only Go, ready to have some <em>func</em>?</p><p>This blog post will be divided into three main parts: <strong>Motion detection with GoCV</strong>, <strong>Controlling servo motors with Gobot</strong> and <strong>Putting it all together</strong>. In the first part, we build a lightweight motion detection algorithm that can run on low-power devices such as the RPi. In the second part we will show how to control servo motors with Gobot from the Raspberry Pi and in the last part we&rsquo;ll explain how to go from detecting an object on an image to telling exactly the angles in which the servos need to move in order to track it.</p><p>For this blog post I assume that you already know <a href=https://golang.org>Go</a>. If you don&rsquo;t but want to learn, there are lots of resources out there. Anyway, a good and simple place to start is the <a href=https://tour.golang.org>Go tour</a>.</p><p>This entire project is hosted on <a href=https://github.com/matipan/dartagnan>Github</a>.</p><p>Before we start let me show you what you will get once you are done if you follow this series of blog posts:
<img loading=lazy src=/images/fake-turret.jpg alt=fake-turret></p><p>Just kidding, this is what you will have(for real this time):
<img loading=lazy src=/images/dart.jpg alt=dart></p><p>Looks lethal, right? Lets dive in and see how we can build this sophisticated piece of machinery. Starting of with the list of things you&rsquo;ll need to follow this tutorial:</p><ul><li>Two MG90 tower pro micro servos: <a href=https://articulo.mercadolibre.com.ar/MLA-705822642-mini-servo-tower-pro-mg90-18kg-metalico-arduino-nubbeo-_JM>MercadoLibre</a> - <a href="https://www.amazon.com/Eztronics-Corp%C2%AE-Metal-Geared-Helicopter/dp/B01I17OAKY/ref=sr_1_4?ie=UTF8&amp;qid=1539878876&amp;sr=8-4&amp;keywords=mg90+servo&amp;dpID=4186kljWqwL&amp;preST=_SY300_QL70_&amp;dpSrc=srch">Amazon</a>.</li><li>One Raspberry Pi 3 B+ with Raspbian installed: <a href=https://articulo.mercadolibre.com.ar/MLA-728426263-raspberry-pi-3-b-plus-rs-uk-kit-base-fuente-25a-_JM>MercadoLibre</a> - <a href="https://www.amazon.com/CanaKit-Raspberry-Starter-Premium-Black/dp/B07BCC8PK7/ref=sr_1_1_sspa?s=pc&amp;ie=UTF8&amp;qid=1539878894&amp;sr=1-1-spons&amp;keywords=raspberry+pi+3+b%2B&amp;psc=1">Amazon</a>.</li><li>A bunch of cables and a breadboard: <a href=https://articulo.mercadolibre.com.ar/MLA-620848979-combo-kit-protoboard-fuente-5v-33v-65-cables-macho-kit06-_JM>MercadoLibre</a> - <a href="https://www.amazon.com/DEYUE-Standard-Jumper-Wires-Shape/dp/B07DMK2SH2/ref=sr_1_3?ie=UTF8&amp;qid=1539879007&amp;sr=8-3&amp;keywords=breadboard">Amazon</a>.</li><li>One 5V and 2A power source: <a href=https://articulo.mercadolibre.com.ar/MLA-692902383-fuente-switching-electronica-5v-2a-2ampers-micro-usb-pronext-_JM>MercadoLibre</a> - <a href="https://www.amazon.com/Outtag-Switching-Multi-Tip-Wireless-Enclosure/dp/B0771LC63X/ref=sr_1_1_sspa?ie=UTF8&amp;qid=1539879074&amp;sr=8-1-spons&amp;keywords=5v+2a+power+source&amp;psc=1">Amazon</a>.</li><li>Either a 3D printer or a shop that can print the case(although you could build your own)</li><li>C270 Logitech web camera is what I used, but any other model should work: <a href=https://articulo.mercadolibre.com.ar/MLA-741143327-camara-web-cam-logitech-c270-720p-hd-twitch-skype-_JM>MercadoLibre</a> - <a href="https://www.amazon.com/Logitech-C270-960-001063-Webcam-Black/dp/B01HVIJH66/ref=sr_1_3?ie=UTF8&amp;qid=1539879095&amp;sr=8-3&amp;keywords=c270+logitech+webcam">Amazon</a>.</li><li>5V laser(it&rsquo;s not the best fit but we&rsquo;ll probably update it in the future): <a href=https://articulo.mercadolibre.com.ar/MLA-644686690-led-diodo-laser-5v-5mw-rojo-con-lente-cables-arduino-_JM>MercadoLibre</a> - <a href="https://www.amazon.com/650nm-Adjustable-Module-Copper-Pointer/dp/B07G5BCQ9G/ref=sr_1_4?ie=UTF8&amp;qid=1539879141&amp;sr=8-4&amp;keywords=5v+laser">Amazon</a>.</li><li>Bonus: soldering iron if you want to build your own PCB or solder some cables</li></ul><p><strong>Note</strong>: if you want to use different things go ahead, but I don&rsquo;t guarantee they will work with the same code.</p><h2 id=motion-detection-with-gocv>Motion detection with GoCV<a hidden class=anchor aria-hidden=true href=#motion-detection-with-gocv>#</a></h2><p>You might ask <em>what is this <a href=https://gocv.io>GoCV</a> thing he&rsquo;s talking about</em>? Well, first lets explain what <a href=https://opencv.org/>OpenCV</a> is. OpenCV is a library for computer vision, better yet, is <strong>the</strong> library for computer vision. It has a whole lot of functions, types and interfaces that allow us to manipulate images by applying already implemented filters and image-manipulation algorithms. It&rsquo;s a really cool project, you should definitely check it out.<br>The thing is that OpenCV is implemented in C++ and it has interfaces for Java and Python. But don&rsquo;t be afraid my gopher-friend, the <a href=http://hybridgroup.com/>Hybridgroup</a> has got us. Along with other libraries they implemented a Go wrapper for OpenCV. They did this by using CGo to call C code from Go code and that C code calls the corresponding C++ code of OpenCV. It&rsquo;s really efficient and works pretty well. Lucky for us, this wrapper is really fast and most of the OpenCV functionality is already there.</p><h4 id=installation>Installation<a hidden class=anchor aria-hidden=true href=#installation>#</a></h4><p>We are going to be running this program on a Raspberry Pi but since Go is nice and lets us do cross-compilation we will only install GoCV and OpenCV on our development machine. So head over to GoCV&rsquo;s <a href=https://github.com/hybridgroup/gocv#how-to-install>how to install</a> section and follow the steps required for your platform. It&rsquo;ll take a while so I&rsquo;ll wait here till you are back.</p><p>Extra: if you want to debug and change the code while testing in the Pi you can install Go and after that install GoCV for Raspbian following <a href=https://github.com/hybridgroup/gocv#raspbian>this instructions</a>.</p><h4 id=motion-detection-algorithm>Motion detection algorithm<a hidden class=anchor aria-hidden=true href=#motion-detection-algorithm>#</a></h4><p>You back? Awesome. Lets explain just a bit about how the motion detection algorithm works so that you understand what it&rsquo;s going on and can tweak it to your needs.</p><p>Since we are going to run this on the Pi, we are not going to use a fancy already trained neural network with near zero error margin. Instead we will do something relatively simple:</p><ul><li>When the program starts we take a picture, convert it to gray and blur it using a <a href=https://en.wikipedia.org/wiki/Gaussian_blur>Guassian filter</a>. That first frame will be considered our background so try not be there when it starts.</li><li>Constantly read new frames, perform the same conversion we did before, compute the absolute difference between the first frame and the current frame, apply a <a href=https://en.wikipedia.org/wiki/Thresholding_(image_processing)>threshold</a> to the image so that we create a binary image where the area of movement will look really bright. Finally, <a href=https://en.wikipedia.org/wiki/Dilation_(morphology)>dilate</a> the resulting binary image and find the biggest contour. We will consider that contour our area of movement.</li></ul><p>Once all these filters were applied our image will look something like this:
<img loading=lazy src=/images/threshold-image.png alt=motion-image></p><p>Time to implement this using GoCV.<br>First, lets write a program that opens the feed of a camera to read images, stores the first frame and starts reading new frames non stop while showing them on a window(error handling for now is out of scope). I&rsquo;m using device 0, to check which devices you have available you can do <code>ls /dev/video*</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;log&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;gocv.io/x/gocv&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>firstFrame</span> <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewMat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>frame</span> <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewMat</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>window</span> <span class=o>:=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewWindow</span><span class=p>(</span><span class=s>&#34;Motion&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>video</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>OpenVideoCapture</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>video</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>firstFrame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>video</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>window</span><span class=p>.</span><span class=nf>IMShow</span><span class=p>(</span><span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>window</span><span class=p>.</span><span class=nf>WaitKey</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=mi>27</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>video</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>window</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>firstFrame</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>frame</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If you run this program you&rsquo;ll basically be streaming from your camera to the window that just opened. To quit this window you can hit <code>escape</code>, that is what that <code>if window.WaitKey(1) == 27</code> is doing.</p><p>Since each frame we read(including the first one) needs to be converted to a gray-scale image first and blurred later, we are going to write a function that does this for us:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>convertFrame</span><span class=p>(</span><span class=nx>src</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>Mat</span><span class=p>,</span> <span class=nx>dst</span> <span class=o>*</span><span class=nx>gocv</span><span class=p>.</span><span class=nx>Mat</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>gocv</span><span class=p>.</span><span class=nf>Resize</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>src</span><span class=p>,</span> <span class=nx>image</span><span class=p>.</span><span class=nx>Point</span><span class=p>{</span><span class=nx>X</span><span class=p>:</span> <span class=mi>500</span><span class=p>,</span> <span class=nx>Y</span><span class=p>:</span> <span class=mi>500</span><span class=p>},</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>InterpolationLinear</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>gocv</span><span class=p>.</span><span class=nf>CvtColor</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=nx>dst</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>ColorBGRToGray</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>gocv</span><span class=p>.</span><span class=nf>GaussianBlur</span><span class=p>(</span><span class=o>*</span><span class=nx>dst</span><span class=p>,</span> <span class=nx>dst</span><span class=p>,</span> <span class=nx>image</span><span class=p>.</span><span class=nx>Point</span><span class=p>{</span><span class=nx>X</span><span class=p>:</span> <span class=mi>21</span><span class=p>,</span> <span class=nx>Y</span><span class=p>:</span> <span class=mi>21</span><span class=p>},</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>BorderReflect101</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Lets walk through that function. First, we are resizing the image with the <a href=https://godoc.org/gocv.io/x/gocv#Resize>Resize</a> function since working with squared images is a lot easier and faster. Then we use the <a href=https://godoc.org/gocv.io/x/gocv#CvtColor>CvtColor</a> function to convert the image to gray-scale and finally, we apply the <a href=https://godoc.org/gocv.io/x/gocv#GaussianBlur>GaussianBlur</a> to the gray image so that we get the blurred image we wanted.</p><p>Now rewrite your previous program to call this function each time we read a new frame(including the first one). Basically add the line <code>convertFrame(img, &amp;img)</code> after each <code>video.Read</code>, where <code>img</code> is the <a href=https://godoc.org/gocv.io/x/gocv#Mat>gocv.Mat</a> you used to read a new frame. If all went well, then the window should display images that look kinda like this:
<img loading=lazy src=/images/gray-image.png alt=gray-image></p><p>We have the first frame and the current frame already converted to gray scale and blurred, now we need to compute the absolute difference between those two and apply the required threshold and dilation to the resulting difference:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>gocv</span><span class=p>.</span><span class=nf>AbsDiff</span><span class=p>(</span><span class=nx>firstFrame</span><span class=p>,</span> <span class=nx>frame</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>difference</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>gocv</span><span class=p>.</span><span class=nf>Threshold</span><span class=p>(</span><span class=nx>difference</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>difference</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>255</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>ThresholdBinary</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>gocv</span><span class=p>.</span><span class=nf>Dilate</span><span class=p>(</span><span class=nx>difference</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>difference</span><span class=p>,</span> <span class=nx>kernel</span><span class=p>)</span>
</span></span></code></pre></div><p>The name of this functions are a bit self explanatory. <a href=https://godoc.org/gocv.io/x/gocv#AbsDiff>AbsDiff</a> computes the absolute difference between the first frame and the new frame and stores that difference on the <code>difference</code> mat. <a href=https://godoc.org/gocv.io/x/gocv#Threshold>Threshold</a> converts the gray image to a binary image by applying a fixed-level thresholding to each pixel and finally, <a href=https://godoc.org/gocv.io/x/gocv#Dilate>Dilate</a> dilates the image by using the specific <code>kernel</code> element, in this case our kernel is empty.<br>The best thing you can do to understand all this better is to read the docs for each function and play around with the values that they receive, for example, what happens when you change those two magic numbers that the <code>Threshold</code> function receives? What about the type of the threshold?<br>If you are curious here, here are most of the different types of thresholds that you can apply to an image:
<img loading=lazy src=/images/thresholds-multiple-image.png alt=thresholds-multiple-image.png></p><p>Lets add those filters to our code and we&rsquo;ll display the <code>difference</code> mat instead of the normal <code>frame</code> mat we&rsquo;ve been displaying so far:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;image&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;gocv.io/x/gocv&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>firstFrame</span> <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewMat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>frame</span>      <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewMat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>difference</span> <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewMat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>kernel</span>     <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewMat</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>window</span> <span class=o>:=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewWindow</span><span class=p>(</span><span class=s>&#34;Motion&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>video</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>OpenVideoCapture</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>video</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>firstFrame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>convertFrame</span><span class=p>(</span><span class=nx>firstFrame</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>firstFrame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>video</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>convertFrame</span><span class=p>(</span><span class=nx>frame</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>gocv</span><span class=p>.</span><span class=nf>AbsDiff</span><span class=p>(</span><span class=nx>firstFrame</span><span class=p>,</span> <span class=nx>frame</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>difference</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>gocv</span><span class=p>.</span><span class=nf>Threshold</span><span class=p>(</span><span class=nx>difference</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>difference</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>255</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>ThresholdBinary</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>gocv</span><span class=p>.</span><span class=nf>Dilate</span><span class=p>(</span><span class=nx>difference</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>difference</span><span class=p>,</span> <span class=nx>kernel</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>window</span><span class=p>.</span><span class=nf>IMShow</span><span class=p>(</span><span class=nx>difference</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>window</span><span class=p>.</span><span class=nf>WaitKey</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=mi>27</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>video</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>window</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>firstFrame</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>frame</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>convertFrame</span><span class=p>(</span><span class=nx>src</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>Mat</span><span class=p>,</span> <span class=nx>dst</span> <span class=o>*</span><span class=nx>gocv</span><span class=p>.</span><span class=nx>Mat</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>gocv</span><span class=p>.</span><span class=nf>Resize</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>src</span><span class=p>,</span> <span class=nx>image</span><span class=p>.</span><span class=nx>Point</span><span class=p>{</span><span class=nx>X</span><span class=p>:</span> <span class=mi>500</span><span class=p>,</span> <span class=nx>Y</span><span class=p>:</span> <span class=mi>500</span><span class=p>},</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>InterpolationLinear</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>gocv</span><span class=p>.</span><span class=nf>CvtColor</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=nx>dst</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>ColorBGRToGray</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>gocv</span><span class=p>.</span><span class=nf>GaussianBlur</span><span class=p>(</span><span class=o>*</span><span class=nx>dst</span><span class=p>,</span> <span class=nx>dst</span><span class=p>,</span> <span class=nx>image</span><span class=p>.</span><span class=nx>Point</span><span class=p>{</span><span class=nx>X</span><span class=p>:</span> <span class=mi>21</span><span class=p>,</span> <span class=nx>Y</span><span class=p>:</span> <span class=mi>21</span><span class=p>},</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>BorderReflect101</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Try running this program by first having the camera point directly at you when the program first starts. What happens when you move around? Or even better, what happens when you leave the chair? You are going to see yourself all bright, but you aren&rsquo;t there, are you? What kind of sorcery is this!!??<br>Well that&rsquo;s what it&rsquo;s supposed to happen. Remember that all the filters we are applying are over the absolute difference of the first frame and the current frame. This means that if you are on the first frame you will be part of the &ldquo;background&rdquo; and whenever you leave the image there will be a difference on that area since instead of you sitting there the image will pick up everything that was behind you. This is why you see yourself sitting there even though you are not. It&rsquo;s either that or magic, who knows.<br>Try running this code without you being there for the first frame. Once the program is running pop in front of the camera, you should be looking into an image that resembles this:
<img loading=lazy src=/images/threshold-image.png alt=threshold-image></p><p>OK, we have our big bright spot on our image, now is time that we find some contours. I have to admit I thought this was going to be <strong>really</strong> hard, but thanks to GoCV&rsquo;s <a href=https://godoc.org/gocv.io/x/gocv#FindContours>FindContours</a> function all we have to do is call it, iterate over all the contours and pick the contour that has the biggest area. Lets write a function that does exactly that but it also makes sure that the areas are bigger than some minimum:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// bestContour obtains the biggest contour in the frame provided is bigger
</span></span></span><span class=line><span class=cl><span class=c1>// than the minArea.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>bestContour</span><span class=p>(</span><span class=nx>frame</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>Mat</span><span class=p>,</span> <span class=nx>minArea</span> <span class=kt>float64</span><span class=p>)</span> <span class=p>[]</span><span class=nx>image</span><span class=p>.</span><span class=nx>Point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>cnts</span> <span class=o>:=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>FindContours</span><span class=p>(</span><span class=nx>frame</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>RetrievalExternal</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>ChainApproxSimple</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>bestCnt</span>  <span class=p>[]</span><span class=nx>image</span><span class=p>.</span><span class=nx>Point</span>
</span></span><span class=line><span class=cl>		<span class=nx>bestArea</span> <span class=p>=</span> <span class=nx>minArea</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>cnt</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>cnts</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>area</span> <span class=o>:=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>ContourArea</span><span class=p>(</span><span class=nx>cnt</span><span class=p>);</span> <span class=nx>area</span> <span class=p>&gt;</span> <span class=nx>bestArea</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>bestArea</span> <span class=p>=</span> <span class=nx>area</span>
</span></span><span class=line><span class=cl>			<span class=nx>bestCnt</span> <span class=p>=</span> <span class=nx>cnt</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>bestCnt</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We will call this function with the <code>difference</code> mat, since that is the one where we applied all the filters. After this function ends, we will either have the biggest contour that was found on the image or nothing at all. We can see whether we have results or not by checking the <code>len</code> of the <code>[]image.Point</code> array that was returned. If we have a contour then we will draw a rectangle on the base image to show were was the area of movement found:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;image&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;image/color&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;gocv.io/x/gocv&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>firstFrame</span> <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewMat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>frame</span>      <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewMat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>gray</span>       <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewMat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>difference</span> <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewMat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>kernel</span>     <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewMat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>motion</span>    <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewWindow</span><span class=p>(</span><span class=s>&#34;Motion&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>threshold</span> <span class=p>=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>NewWindow</span><span class=p>(</span><span class=s>&#34;Threshold&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>rectColor</span> <span class=p>=</span> <span class=nx>color</span><span class=p>.</span><span class=nx>RGBA</span><span class=p>{</span><span class=nx>G</span><span class=p>:</span> <span class=mi>255</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>textColor</span> <span class=p>=</span> <span class=nx>color</span><span class=p>.</span><span class=nx>RGBA</span><span class=p>{</span><span class=nx>B</span><span class=p>:</span> <span class=mi>255</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>statusPoint</span> <span class=p>=</span> <span class=nx>image</span><span class=p>.</span><span class=nf>Pt</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>video</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>OpenVideoCapture</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>motion</span><span class=p>.</span><span class=nf>ResizeWindow</span><span class=p>(</span><span class=mi>500</span><span class=p>,</span> <span class=mi>500</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>threshold</span><span class=p>.</span><span class=nf>ResizeWindow</span><span class=p>(</span><span class=mi>500</span><span class=p>,</span> <span class=mi>500</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>motion</span><span class=p>.</span><span class=nf>MoveWindow</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>threshold</span><span class=p>.</span><span class=nf>MoveWindow</span><span class=p>(</span><span class=mi>500</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>video</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>firstFrame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>convertFrame</span><span class=p>(</span><span class=nx>firstFrame</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>firstFrame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>video</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>convertFrame</span><span class=p>(</span><span class=nx>frame</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>gray</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>gocv</span><span class=p>.</span><span class=nf>AbsDiff</span><span class=p>(</span><span class=nx>firstFrame</span><span class=p>,</span> <span class=nx>gray</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>difference</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>gocv</span><span class=p>.</span><span class=nf>Threshold</span><span class=p>(</span><span class=nx>difference</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>difference</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>255</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>ThresholdBinary</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>gocv</span><span class=p>.</span><span class=nf>Dilate</span><span class=p>(</span><span class=nx>difference</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>difference</span><span class=p>,</span> <span class=nx>kernel</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>cnt</span> <span class=o>:=</span> <span class=nf>bestContour</span><span class=p>(</span><span class=nx>difference</span><span class=p>.</span><span class=nf>Clone</span><span class=p>(),</span> <span class=mi>5000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>cnt</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nf>imShow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>rect</span> <span class=o>:=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>BoundingRect</span><span class=p>(</span><span class=nx>cnt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>gocv</span><span class=p>.</span><span class=nf>Rectangle</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>frame</span><span class=p>,</span> <span class=nx>rect</span><span class=p>,</span> <span class=nx>rectColor</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>gocv</span><span class=p>.</span><span class=nf>PutText</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>frame</span><span class=p>,</span> <span class=s>&#34;Motion detected&#34;</span><span class=p>,</span> <span class=nx>statusPoint</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>FontHersheyPlain</span><span class=p>,</span> <span class=mf>1.2</span><span class=p>,</span> <span class=nx>textColor</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nf>imShow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>video</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>motion</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>threshold</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>firstFrame</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>gray</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>difference</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>frame</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>imShow</span><span class=p>()</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>motion</span><span class=p>.</span><span class=nf>IMShow</span><span class=p>(</span><span class=nx>frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>threshold</span><span class=p>.</span><span class=nf>IMShow</span><span class=p>(</span><span class=nx>difference</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>motion</span><span class=p>.</span><span class=nf>WaitKey</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=mi>27</span> <span class=o>||</span> <span class=nx>threshold</span><span class=p>.</span><span class=nf>WaitKey</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=mi>27</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>convertFrame</span><span class=p>(</span><span class=nx>src</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>Mat</span><span class=p>,</span> <span class=nx>dst</span> <span class=o>*</span><span class=nx>gocv</span><span class=p>.</span><span class=nx>Mat</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>gocv</span><span class=p>.</span><span class=nf>Resize</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>src</span><span class=p>,</span> <span class=nx>image</span><span class=p>.</span><span class=nx>Point</span><span class=p>{</span><span class=nx>X</span><span class=p>:</span> <span class=mi>500</span><span class=p>,</span> <span class=nx>Y</span><span class=p>:</span> <span class=mi>500</span><span class=p>},</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>InterpolationLinear</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>gocv</span><span class=p>.</span><span class=nf>CvtColor</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=nx>dst</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>ColorBGRToGray</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>gocv</span><span class=p>.</span><span class=nf>GaussianBlur</span><span class=p>(</span><span class=o>*</span><span class=nx>dst</span><span class=p>,</span> <span class=nx>dst</span><span class=p>,</span> <span class=nx>image</span><span class=p>.</span><span class=nx>Point</span><span class=p>{</span><span class=nx>X</span><span class=p>:</span> <span class=mi>21</span><span class=p>,</span> <span class=nx>Y</span><span class=p>:</span> <span class=mi>21</span><span class=p>},</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>BorderReflect101</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// bestContour obtains the biggest contour in the frame provided is bigger
</span></span></span><span class=line><span class=cl><span class=c1>// than the minArea.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>bestContour</span><span class=p>(</span><span class=nx>frame</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>Mat</span><span class=p>,</span> <span class=nx>minArea</span> <span class=kt>float64</span><span class=p>)</span> <span class=p>[]</span><span class=nx>image</span><span class=p>.</span><span class=nx>Point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>cnts</span> <span class=o>:=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>FindContours</span><span class=p>(</span><span class=nx>frame</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>RetrievalExternal</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>ChainApproxSimple</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>bestCnt</span>  <span class=p>[]</span><span class=nx>image</span><span class=p>.</span><span class=nx>Point</span>
</span></span><span class=line><span class=cl>		<span class=nx>bestArea</span> <span class=p>=</span> <span class=nx>minArea</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>cnt</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>cnts</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>area</span> <span class=o>:=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>ContourArea</span><span class=p>(</span><span class=nx>cnt</span><span class=p>);</span> <span class=nx>area</span> <span class=p>&gt;</span> <span class=nx>bestArea</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>bestArea</span> <span class=p>=</span> <span class=nx>area</span>
</span></span><span class=line><span class=cl>			<span class=nx>bestCnt</span> <span class=p>=</span> <span class=nx>cnt</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>bestCnt</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We made a <strong>lot</strong> of changes in that code, lets walk through each of them. First off, we now have two windows instead of one, why? Well, we are going to be displaying two different types of images. In the <code>motion</code> window we will display the normal image with the rectangle drawn on top of the area of motion(if there is any). In the <code>threshold</code> window we will show the <code>difference</code> mat we&rsquo;ve been showing so far. We also did a few resizes and moved the windows over so that they are displayed side by side.<br>Since now we want to preserve the colors of the images we are reading, we can not use the same <code>frame</code> mat when we call <code>convertFrame</code>. This is why we have the new <code>gray</code> mat that we use for the conversion.<br>The most important change of the previous code is right here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>cnt</span> <span class=o>:=</span> <span class=nf>bestContour</span><span class=p>(</span><span class=nx>difference</span><span class=p>.</span><span class=nf>Clone</span><span class=p>(),</span> <span class=mi>5000</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>cnt</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>imShow</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>break</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>continue</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>rect</span> <span class=o>:=</span> <span class=nx>gocv</span><span class=p>.</span><span class=nf>BoundingRect</span><span class=p>(</span><span class=nx>cnt</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>gocv</span><span class=p>.</span><span class=nf>Rectangle</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>frame</span><span class=p>,</span> <span class=nx>rect</span><span class=p>,</span> <span class=nx>rectColor</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>gocv</span><span class=p>.</span><span class=nf>PutText</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>frame</span><span class=p>,</span> <span class=s>&#34;Motion detected&#34;</span><span class=p>,</span> <span class=nx>statusPoint</span><span class=p>,</span> <span class=nx>gocv</span><span class=p>.</span><span class=nx>FontHersheyPlain</span><span class=p>,</span> <span class=mf>1.2</span><span class=p>,</span> <span class=nx>textColor</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></div><p>First, we call the <code>bestContour</code> function to obtain the biggest area of movement. If there are no results, we simply call the new <code>imShow</code> image that displays the images without drawing anything on them. But if we have results then we first have to find the <a href=https://godoc.org/image#Rectangle>rectangle</a> of that area using the <a href=https://godoc.org/gocv.io/x/gocv#BoundingRect>BoundingRect</a> function, once we have that we simply draw the rectangle on our image with <a href=https://godoc.org/gocv.io/x/gocv#Rectangle>Rectangle</a> and display the &ldquo;Motion detected&rdquo; text on our image.<br>If all went well, when you run this code and pop in front of the camera you should have something similar to this:
<img loading=lazy src=/images/motion-image.png alt=motion-image></p><p>And voila! You have motion detection! Don&rsquo;t go out and celebrate with a beer <em>yet</em>. We need to compile this to a binary that can run on the RPi, move that binary there and run it. In order to see this program running on the raspberry pi, you will need to have a display connected to it.<br>You can compile the binary for the RPi with the following command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>GOOS</span><span class=o>=</span>linux <span class=nv>GOARCH</span><span class=o>=</span>arm <span class=nv>GOARM</span><span class=o>=</span><span class=m>5</span> go build
</span></span></code></pre></div><p>Once you have your binary, you can send it over with <code>scp</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>scp &lt;USER&gt;@&lt;RASPBERRY IP&gt;:&lt;DIRECTORY ON THE PI&gt; &lt;BINARY-NAME&gt;
</span></span></code></pre></div><p>Change those parameters accordingly and run the command. SSH into the RPi and run the binary, if you have a video camera connected to the Pi that can be identified with the same ID you&rsquo;ve been using, then you should see the same image you saw when you ran this program on your development machine.</p><p>Congrats! Now you can go and have some beers!</p><p><img loading=lazy src=/images/beer.gif alt=beer></p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>On this blog post you saw how to build a simple and lightweight motion detection program with GoCV and how to compile and run that on the raspberry pi. The idea is to connect two servos and make them follow the area of movement. All that will be explained in Part 2 and Part 3 of this blog post, so stick around for that!</p><p>Thank you!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.matiaspan.dev/tags/go/>go</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Motion tracking turret with Gobot and GoCV - Part 1 on x" href="https://x.com/intent/tweet/?text=Motion%20tracking%20turret%20with%20Gobot%20and%20GoCV%20-%20Part%201&amp;url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fmotion-tracking-turret-with-gobot-and-gocv%2f&amp;hashtags=go"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Motion tracking turret with Gobot and GoCV - Part 1 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fmotion-tracking-turret-with-gobot-and-gocv%2f&title=Motion%20tracking%20turret%20with%20Gobot%20and%20GoCV%20-%20Part%201"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Motion tracking turret with Gobot and GoCV - Part 1 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Motion%20tracking%20turret%20with%20Gobot%20and%20GoCV%20-%20Part%201&u=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fmotion-tracking-turret-with-gobot-and-gocv%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.matiaspan.dev/>Matias Pan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>