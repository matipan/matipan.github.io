<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How services are provisioned, deployed and operated at Lemon Cash | Matias Pan's blog</title>
<meta name=keywords content="infrastructure,lemoncash,terraform,go"><meta name=description content="Lemon Cash is a crypto startup based in Argentina that operates digital wallets, card payments and more. In this blog post I describe how we implemented a solution for provisioning, deploying and operating services that empowers developers to ship more quickly. This solution is not a fully fledged platform but it provides similar benefits by standing on top of strongly defined concepts and conventions. What we implemented only makes sense in the context in which the company was in, so I will start by explaining what that context was."><meta name=author content="Me"><link rel=canonical href=https://blog.matiaspan.dev/posts/how-services-are-provisioned-and-deployed-at-lemoncash/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How services are provisioned, deployed and operated at Lemon Cash"><meta property="og:description" content="Lemon Cash is a crypto startup based in Argentina that operates digital wallets, card payments and more. In this blog post I describe how we implemented a solution for provisioning, deploying and operating services that empowers developers to ship more quickly. This solution is not a fully fledged platform but it provides similar benefits by standing on top of strongly defined concepts and conventions. What we implemented only makes sense in the context in which the company was in, so I will start by explaining what that context was."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.matiaspan.dev/posts/how-services-are-provisioned-and-deployed-at-lemoncash/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-02T00:00:00-03:00"><meta property="article:modified_time" content="2022-10-02T00:00:00-03:00"><meta property="og:site_name" content="Matias Pan's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="How services are provisioned, deployed and operated at Lemon Cash"><meta name=twitter:description content="Lemon Cash is a crypto startup based in Argentina that operates digital wallets, card payments and more. In this blog post I describe how we implemented a solution for provisioning, deploying and operating services that empowers developers to ship more quickly. This solution is not a fully fledged platform but it provides similar benefits by standing on top of strongly defined concepts and conventions. What we implemented only makes sense in the context in which the company was in, so I will start by explaining what that context was."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.matiaspan.dev/posts/"},{"@type":"ListItem","position":2,"name":"How services are provisioned, deployed and operated at Lemon Cash","item":"https://blog.matiaspan.dev/posts/how-services-are-provisioned-and-deployed-at-lemoncash/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How services are provisioned, deployed and operated at Lemon Cash","name":"How services are provisioned, deployed and operated at Lemon Cash","description":"Lemon Cash is a crypto startup based in Argentina that operates digital wallets, card payments and more. In this blog post I describe how we implemented a solution for provisioning, deploying and operating services that empowers developers to ship more quickly. This solution is not a fully fledged platform but it provides similar benefits by standing on top of strongly defined concepts and conventions. What we implemented only makes sense in the context in which the company was in, so I will start by explaining what that context was.","keywords":["infrastructure","lemoncash","terraform","go"],"articleBody":"Lemon Cash is a crypto startup based in Argentina that operates digital wallets, card payments and more. In this blog post I describe how we implemented a solution for provisioning, deploying and operating services that empowers developers to ship more quickly. This solution is not a fully fledged platform but it provides similar benefits by standing on top of strongly defined concepts and conventions. What we implemented only makes sense in the context in which the company was in, so I will start by explaining what that context was.\nBackground In April 2022 the company found itself at a stage many startups face, they grew really quickly without dedicated focus to infrastructure and developer experience. This means no explicit cloud networking architecture, a monolithic application deployed on ECS, a few lambdas, an RDS database and a collection of custom scripts and github actions for deploying things.\nAt that point the company decided to build a small team of Infra/SRE and Engineering Effectiveness that will tackle all things infrastructure and other big projects such as Breaking the Monolith. Before actually being able to deploy new services and break the monolith we realized that we needed to implement a ‚Äúproper‚Äù cloud networking architecture along with a standardized way of provisioning, deploying and operating services. I will focus on the latter and leave the details of our networking architecture for a separate post.\nDX First When we set out to solve this problem we wanted to make sure we provided the best Developer Experience possible. We decided to go with a CLI, called lemi üçã, that acts as the interface for all thing services. In the end, we want developers to provision a service by just running:\n$ git checkout -b provision $ lemi service new --service example --cpu 512 --memory 1024 --desired-count 3 --owner infra $ git commit -a -m \"Add service definitions and CI workflows\" $ git push -u origin provision After that we want them to use this same CLI, lemi, to operate on their services and do things such as:\n# exec into the service's container $ lemi service exec -s example # restart their service $ lemi service restart -s example # deploy an image $ lemi service deploy -s example --tag Concepts and conventions FTW Convention over configuration. This is something I internalized while working with Ruby on Rails a few years ago. It is incredible how much work you can not do by relying on strong conventions that do not compromise the functionality you want to provide. Coupling this with clear concepts that separate concerns allowed us to develop something very quickly while keeping a lot of simplicity.\nConcepts We started by separating Static from Dynamic Infrastructure. Static infrastructure are components such as Databases, Caches, VPN/VPCs, Lambdas, S3 buckets, Service Resources and others that require more explicit provisioning and are not changed that frequently. While Dynamic Infrastructure are things that are closer to the service itself and developer teams. They can possibly change with every deployment and should be owned and controlled by the teams themselves. This includes things like: Service versions, Observability, Routing, Access Control and pipelines. We make this distinction because we believe there different needs for each type of infra. For the case of Static Infrastructure we want to make sure that:\nIs always reproducible, All changes made to it are tracked through git and IaaC, Ownership of resources is explicit and clear, Tagging is effectively made to allow for observability and cost ownership. For the case of Dynamic Infrastructure the goal is to have it as close to the developers as possible. This means that they have full control over it and are able to work and iterate on it without the need of the infrastructure team stepping in.\nWith these concepts in mind we landed on something we are comfortable with and gives us a lot of room for improving. We have a central terraform repository that holds all of our Static Infrastructure. This central repo is owned and controlled by the infrastructure team. However, through the use of terraform modules provided by us, developer teams can very easily (and without a lot of terraform) define new infrastructure that accompanies the services they are deploying. For the Dynamic Infrastructure we provide a YAML abstraction that defines what a service is and is owned and developed by the teams themselves. This abstraction exists mainly because at the moment we are using ECS. While the platform is useful in many ways, it does not provide clear APIs that can be easily exposed to developers. We coupled this service spec with the definition of environments and their corresponding variables, secrets and parameters. The important detail is that these files live in the repository of the service itself and are owned and controlled by the developers.\nConventions The conventions that we define below allowed us to remove instead of solve many problems that don‚Äôt really limit the functionality that developers end up having and does not compromise what can be achieved. This conventions, and the problem they solve, are:\nRouting: all services are available internally through a global Application Load Balancer using Host-based routing and the name of the service as a part of our URL: -internal..lemon. Service Discoverability and naming collisions: the name of the service is the name of the repository. Since GitHub can‚Äôt have two repositories named the same way there won‚Äôt be any collision. Coupling this together with what was defined above for routing you can easily find which services exist in our infrastructure today. Transport: services have to expose an HTTP API on port 8080. Observability (metrics, tracing and logs): Services have to expose an endpoint /metrics on their 8080 port that holds OpenMetrics metrics. As for tracing, all services are shipped with a Datadog sidecar that provides logs and traces out of the box and automatically exports the metrics to datadog. Packaging: Docker has to be used to package the service. On Call \u0026 Service Ownership: the owners of the repository are the owners of the service and are in charge of operating it and being on call. Testing: we used JVM-based languages and gradle. To simplify our pipeline services have to implement three commands: ./gradlew test, ./gradlew integrationTest, ./gradlew e2eTest. To simplify the work developers have to do, they only have to implement the convention for Transport and Testing. lemi, our CLI, takes care of all the rest: Routing, Naming, Observability, Packaging and Service Ownership (by relying on GitHub permissions).\nProvisioning, Deploying and Operating a service I already threw a lot of text at you so instead of explaining things further let‚Äôs have some fun by going through a demo of what developers actually do when working with services at Lemon, let‚Äôs add some screenshots too! üì∏.\nProvisioning To simplify the demo we will assume a developer already has a part of the service developed, this means that there already is a GitHub repository that has the branches we use at Lemon: main for production and develop for staging (our testing environment).\nWe start working from main. To start the provisioning process we go back to the first part of this blog post and run:\n# first we checkout a new branch were we will add all the files generated by lemi $ git checkout -b lemi-provision # now we simply create a new service by running the following command $ lemi service new --cpu 512 --memory 1024 --owner infra --service demo-service --desired-count 1 # run git status to see what lemi actually added $ git status On branch lemi-provision Untracked files: (use \"git add ...\" to include in what will be committed) .github/ deploy/ nothing added to commit but untracked files present (use \"git add\" to track) As you can see in the last command, lemi added two new folders: deploy/ and .github/. Inspecting first deploy/ we can see that it created the service.yaml definition we previously mentioned along with two files, prod.yaml and staging.yaml, that hold the environment variables, secrets and parameters for each corresponding environment:\n$ tree deploy/ deploy/ ‚îî‚îÄ‚îÄ demo-service ‚îú‚îÄ‚îÄ environment ‚îÇ ‚îú‚îÄ‚îÄ prod.yaml ‚îÇ ‚îî‚îÄ‚îÄ staging.yaml ‚îî‚îÄ‚îÄ service.yaml 2 directories, 3 files Let‚Äôs take a look at the specification of the service by looking at service.yaml:\nname: demo-service owner: infra spec: desiredCount: 1 image: demo-service resource: cpu: 512 memory: 1024 This is a very simple spec, mainly because the requirements we have are clear and some of the conventions allow us to not provide additional config parameters. We only have to define the service‚Äôs name, owners (used for cost ownership) and the spec that holds the resources the service requires.\nWith that out the way, lets actually try to provision our service. For this all we have to do is commit, push and create a PR on GitHub. With the PR created we will see something interesting happen. There is a link, that was automatically added, pointing to a PR on our central terraform repository:\nIf we follow the link we can see what the PR is actually attempting to provision (this is the static infrastructure):\nmodule \"demo_service_ecs\" { source = \"git@github.com:lemonatio/infra-ecs-module.git\" owner = \"Infra\" name = \"demo-service\" networking = local.networking load_balancers = local.load_balancers } The interesting part here is the ECS module itself we provide. This module abstracts away all the complexity that provisioning an ECS service has and implements some of the conventions we defined previously, the most important one being routing and ingress rules that make this service accessible from within our infrastructure and from the internet. This module is closed source and I cannot share the implementation here unfortunately.\nWith this PR created, developers can add any additional Static Infrastructure that they need. For example, if their application requires an ElastiCache instance it could easily be added here using our modules as well:\nmodule \"demo_service_ecs\" { source = \"git@github.com:lemonatio/infra-ecs-module.git\" owner = \"Infra\" name = \"demo-service\" networking = local.networking load_balancers = local.load_balancers } module \"demo_service_redis\" { source = \"git@github.com:lemonatio/infra-redis-module.git\" name = \"demo-service-redis\" owner = \"Infra\" networking = local.networking service_sg_ids = toset(module.demo_service_ecs.default.network_configuration[0].security_groups) } You may be wondering how did this happen? lemi FTW! If you remember when we run the lemi service new command we showed that lemi added some github workflows within .github. One of those workflows is provision.yaml and takes care of everything we just saw. The important part of it is that the workflow does not do any magic, it only orchestrates functionality that lemi itself provides. The important part of the workflow is this right here:\n- name: Infra provisioning env: GH_AUTH_TOKEN: ${{ secrets.LEMONATIO_BOT_TOKEN }} run: | ./lemi-latest provision --prId ${{ github.event.number }} --repoName ${{ github.event.repository.name }} --currentBranchName ${{ steps.branch-name.outputs.current_branch }} --service demo-service As you can see we are using a command that lemi provides: lemi provision . The rationale for this is that we want to make sure that all of our operations that happen on our CI can be also tested and run locally. If for some reason we stopped using GitHub Workflows, developers could still simply run this command on their local machines and the entire process would continue to work.\nThis PR will be reviewed and approved by the infra team. Once it is merged the corresponding PR on the service repository will be automatically merged and the service will be considered provisioned! Now let‚Äôs move along to doing our first deployment.\nDeploying As was previously mentioned we have two environments at Lemon: production (deployed from the main branch) and staging (deployed from the develop branch). When we executed lemi service new, lemi generated the provisioning workflows along with all of our building, testing and deployment workflows. Let‚Äôs inspect staging‚Äôs deployment workflow to understand how things are deployed:\nname: Deploy to staging on: push: branches: - develop jobs: test: uses: ./.github/workflows/tests.yml build: uses: ./.github/workflows/build.yml needs: test with: image-tag: ${{ github.sha }} ecr-repo: demo-service secrets: region: ${{ secrets.AWS_STAGING_REGION }} access-key-id: ${{ secrets.AWS_STAGING_ACCESS_KEY_ID }} secret-access-key: ${{ secrets.AWS_STAGING_SECRET_ACCESS_KEY }} deploy: uses: ./.github/workflows/deploy.yml needs: build with: image-tag: ${{ github.sha }} service: demo-service environment: staging lemi-bucket: infra-lemi-staging secrets: region: ${{ secrets.AWS_STAGING_REGION }} cluster: lemon-ecs-cluster access-key-id: ${{ secrets.AWS_STAGING_ACCESS_KEY_ID }} secret-access-key: ${{ secrets.AWS_STAGING_SECRET_ACCESS_KEY }} The first important thing is reusability! You can see that each step (build and deploy) is triggering a different workflow and specifying a series of parameters that are specific for this environment. This allows us to have a single workflow that is reused across environments.\nLet‚Äôs now look into the deploy workflow since the build is rather simple (build the dockerfile and publish to ECR). The process itself is quite large, so lets only look into the relevant parts, this are the ones controlled again by lemi:\n- name: Verify service spec and provisioning id: verify-service env: SERVICE: ${{ inputs.service }} CLUSTER: ${{ secrets.cluster }} run: | ./lemi-latest verify -s=$SERVICE --cluster=$CLUSTER --check=spec,provisioned -e=$ENV - name: Compile task definition id: compile-service env: IMAGE_TAG: ${{ inputs.image-tag }} SUFFIX: ${{ inputs.suffix }} SERVICE: ${{ inputs.service }} ENV: ${{ inputs.environment }} run: | ./lemi-latest compile -t=$IMAGE_TAG -s=$SERVICE -e=$ENV cat task-definition.json - name: Deploy service with new task definition id: deploy-service env: SERVICE: ${{ inputs.service }} CLUSTER: ${{ secrets.cluster }} SUFFIX: ${{ inputs.suffix }} run: | ./lemi-latest deploy -s=$SERVICE --cluster=$CLUSTER We have three key steps defined here:\nlemi verify: this command runs a series of validations to make sure that the deployment can indeed be executed. This validation checks the service, secrets and parameters are all provisioned on the corresponding environment and validates that the YAML is correct and has all required parameters. lemi compile: with the service.yaml, the corresponding env file (i.e staging.yaml) and the ECR Image tag we compile it down into an ECS task definition lemi deploy: using the task definition created in the compilation process, we register a new revision and update the service to point to this latest version. As it was shown in the provisioning process previously, all critical operations are done by lemi and GitHub simply orchestrates the execution of it. This means that any developer can run this commands on their local machine if needed.\nWith this workflows in place all commits sent to develop will be automatically deployed to staging and those that go to main will be deployed in production:\nOperating Last but certainly not least, we want to provide a unified way of operating services at the company. This is mainly because we are not a big company and switching between teams that own different services is completely normal. So if a developer goes from team A to team B, they are already familiar with how to operate their services in our environments. This is why we built a series of commands into lemi that developers use. A few operations that developers usually do:\n# restart the service using a graceful deploy of the same image $ lemi service restart -s demo-service -c lemon-ecs-cluster # list all running tasks the service has $ lemi service list-tasks -s demo-service -c lemon-ecs-cluster [\"arn:aws:ecs:us-east-1::task/lemon-ecs-cluster-prod/77c0048e9f3a4e04ae6b35c89270acdd\",\"arn:aws:ecs:us-east-1::task/lemon-ecs-cluster-prod/91a67a2f88b542e4a8c30f2c6290d80e\",\"arn:aws:ecs:us-east-1::task/lemon-ecs-cluster-prod/d02725effb574e96847b4abe21740987\"] # stop a specific task $ lemi service stop-task --task-id arn:aws:ecs:us-east-1::task/lemon-ecs-cluster-prod/77c0048e9f3a4e04ae6b35c89270acdd # exec into the container of the service, useful for when things go wrong and we want to do closer deep dives $ lemi service exec -s demo-service -c lemon-ecs-cluster /bin/bash running /bin/bash on task arn:aws:ecs:us-east-1::task/lemon-ecs-cluster-prod/77c0048e9f3a4e04ae6b35c89270acdd Starting session with SessionId: ecs-execute-command-0730176e68438b66d root@ip-172-19-0-73:/# We have more commands available for inspecting the service, understanding the status of a deployment, etc. As developers need specific operations we can quickly develop them since they are wrappers over AWS‚Äôs API.\nLooking forward We understand that what we built here is rather simple but we believe it solves a big pain we were facing and lays a very strong foundation for future requirements we may have. One of the big discussions that we are going to have in the short term is whether we want to stick with ECS or not. While it certainly has good functionality and is the right tool for many use cases, we are starting to hit some of its limitations and they are starting to hurt. When we started with this idea we had a short conversation on whether we wanted to stick with ECS or not, but since we were (and are) short staffed with a lot of important things to tackle we decided to leave that discussion for the future. While this may change some details of this process we believe that the concepts and conventions will remain.\nWhat are our next steps? For now we are focused on other projects, the biggest one was mentioned previously and is the breaking of the monolith. We are an infrastructure and Engineering Effectiveness team which is why we are the owners of it. We believe that as we have more services we will encounter use cases that will force us to adopt and develop new and exciting things, so we can‚Äôt wait!\nRemarks Thank you for sticking until the end! We have many exciting projects going on and more blog posts may come to this blog. While I‚Äôm the one writing this, I‚Äôm not by any means the only one that should receive credit for this work. I wanted to mention Claudio Martinez and the entire Infra/SRE team at Lemon Cash because without them this blog would not exist üòÅ\n","wordCount":"2863","inLanguage":"en","datePublished":"2022-10-02T00:00:00-03:00","dateModified":"2022-10-02T00:00:00-03:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.matiaspan.dev/posts/how-services-are-provisioned-and-deployed-at-lemoncash/"},"publisher":{"@type":"Organization","name":"Matias Pan's blog","logo":{"@type":"ImageObject","url":"https://blog.matiaspan.dev/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.matiaspan.dev/ accesskey=h title="Home (Alt + H)"><img src=https://blog.matiaspan.dev/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.matiaspan.dev/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.matiaspan.dev/search/ title=Search><span>Search</span></a></li><li><a href=https://blog.matiaspan.dev/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.matiaspan.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>How services are provisioned, deployed and operated at Lemon Cash</h1><div class=post-meta><span title='2022-10-02 00:00:00 -0300 -03'>October 2, 2022</span>&nbsp;¬∑&nbsp;14 min&nbsp;¬∑&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/matipan/matipan.github.io/tree/main/content/posts/how-services-are-provisioned-and-deployed-at-lemoncash.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#dx-first>DX First</a></li><li><a href=#concepts-and-conventions-ftw>Concepts and conventions FTW</a><ul><li><a href=#concepts>Concepts</a></li><li><a href=#conventions>Conventions</a></li></ul></li><li><a href=#provisioning-deploying-and-operating-a-service>Provisioning, Deploying and Operating a service</a><ul><li><a href=#provisioning>Provisioning</a></li><li><a href=#deploying>Deploying</a></li><li><a href=#operating>Operating</a></li></ul></li><li><a href=#looking-forward>Looking forward</a></li><li><a href=#remarks>Remarks</a></li></ul></nav></div></details></div><div class=post-content><p>Lemon Cash is a crypto startup based in Argentina that operates digital wallets, card payments and more. In this blog post I describe how we implemented a solution for provisioning, deploying and operating services that empowers developers to ship more quickly. This solution is not a fully fledged platform but it provides similar benefits by standing on top of strongly defined concepts and conventions. What we implemented only makes sense in the context in which the company was in, so I will start by explaining what that context was.</p><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><p>In April 2022 the company found itself at a stage many startups face, they grew really quickly without dedicated focus to infrastructure and developer experience. This means no explicit cloud networking architecture, a monolithic application deployed on ECS, a few lambdas, an RDS database and a collection of custom scripts and github actions for deploying things.</p><p>At that point the company decided to build a small team of Infra/SRE and <a href=https://gigamonkeys.com/flowers/>Engineering Effectiveness</a> that will tackle all things infrastructure and other big projects such as <em>Breaking the Monolith</em>. Before actually being able to deploy new services and break the monolith we realized that we needed to implement a &ldquo;proper&rdquo; cloud networking architecture along with a standardized way of provisioning, deploying and operating services. I will focus on the latter and leave the details of our networking architecture for a separate post.</p><h2 id=dx-first>DX First<a hidden class=anchor aria-hidden=true href=#dx-first>#</a></h2><p>When we set out to solve this problem we wanted to make sure we provided the best Developer Experience possible. We decided to go with a CLI, called <code>lemi</code> üçã, that acts as the interface for all thing services. In the end, we want developers to provision a service by just running:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ git checkout -b provision
</span></span><span class=line><span class=cl>$ lemi service new --service example --cpu <span class=m>512</span> --memory <span class=m>1024</span> --desired-count <span class=m>3</span> --owner infra
</span></span><span class=line><span class=cl>$ git commit -a -m <span class=s2>&#34;Add service definitions and CI workflows&#34;</span>
</span></span><span class=line><span class=cl>$ git push -u origin provision
</span></span></code></pre></div><p>After that we want them to use this same CLI, <code>lemi</code>, to operate on their services and do things such as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># exec into the service&#39;s container</span>
</span></span><span class=line><span class=cl>$ lemi service <span class=nb>exec</span> -s example
</span></span><span class=line><span class=cl><span class=c1># restart their service</span>
</span></span><span class=line><span class=cl>$ lemi service restart -s example
</span></span><span class=line><span class=cl><span class=c1># deploy an image</span>
</span></span><span class=line><span class=cl>$ lemi service deploy -s example --tag &lt;image-tag&gt;
</span></span></code></pre></div><h2 id=concepts-and-conventions-ftw>Concepts and conventions FTW<a hidden class=anchor aria-hidden=true href=#concepts-and-conventions-ftw>#</a></h2><p><strong>Convention over configuration</strong>. This is something I internalized while working with Ruby on Rails a few years ago. It is incredible how much work you can <em>not do</em> by relying on strong conventions that do not compromise the functionality you want to provide. Coupling this with clear concepts that separate concerns allowed us to develop something very quickly while keeping a lot of simplicity.</p><h3 id=concepts>Concepts<a hidden class=anchor aria-hidden=true href=#concepts>#</a></h3><p>We started by separating <strong>Static</strong> from <strong>Dynamic Infrastructure</strong>. <strong>Static infrastructure</strong> are components such as Databases, Caches, VPN/VPCs, Lambdas, S3 buckets, Service Resources and others that require more explicit provisioning and are not changed that frequently. While <strong>Dynamic Infrastructure</strong> are things that are closer to the service itself and developer teams. They can possibly change with every deployment and should be owned and controlled by the teams themselves. This includes things like: Service versions, Observability, Routing, Access Control and pipelines. We make this distinction because we believe there different needs for each type of infra. For the case of <strong>Static Infrastructure</strong> we want to make sure that:</p><ul><li>Is always reproducible,</li><li>All changes made to it are tracked through git and IaaC,</li><li>Ownership of resources is explicit and clear,</li><li>Tagging is effectively made to allow for observability and cost ownership.</li></ul><p>For the case of <strong>Dynamic Infrastructure</strong> the goal is to have it as close to the developers as possible. This means that they have full control over it and are able to work and iterate on it without the need of the infrastructure team stepping in.</p><p>With these concepts in mind we landed on something we are comfortable with and gives us a lot of room for improving. We have a central terraform repository that holds all of our <strong>Static Infrastructure</strong>. This central repo is owned and controlled by the infrastructure team. However, through the use of terraform modules provided by us, developer teams can very easily (and without a lot of terraform) define new infrastructure that accompanies the services they are deploying. For the <strong>Dynamic Infrastructure</strong> we provide a YAML abstraction that defines what a service is and is owned and developed by the teams themselves. This abstraction exists mainly because at the moment we are using ECS. While the platform is useful in many ways, it does not provide clear APIs that can be easily exposed to developers. We coupled this service spec with the definition of environments and their corresponding variables, secrets and parameters. The important detail is that these files live in the repository of the service itself and are owned and controlled by the developers.</p><h3 id=conventions>Conventions<a hidden class=anchor aria-hidden=true href=#conventions>#</a></h3><p>The conventions that we define below allowed us to remove instead of solve many problems that don&rsquo;t really limit the functionality that developers end up having and does not compromise what can be achieved. This conventions, and the problem they solve, are:</p><ul><li><strong>Routing</strong>: all services are available internally through a global Application Load Balancer using Host-based routing and the name of the service as a part of our URL: <code>&lt;service-name>-internal.&lt;environment>.lemon</code>.</li><li><strong>Service Discoverability and naming collisions</strong>: the name of the service is the name of the repository. Since GitHub can&rsquo;t have two repositories named the same way there won&rsquo;t be any collision. Coupling this together with what was defined above for routing you can easily find which services exist in our infrastructure today.</li><li><strong>Transport</strong>: services <strong>have</strong> to expose an HTTP API on port 8080.</li><li><strong>Observability (metrics, tracing and logs)</strong>: Services <strong>have</strong> to expose an endpoint <code>/metrics</code> on their 8080 port that holds OpenMetrics metrics. As for tracing, all services are shipped with a Datadog sidecar that provides logs and traces out of the box and automatically exports the metrics to datadog.</li><li><strong>Packaging</strong>: Docker <strong>has</strong> to be used to package the service.</li><li><strong>On Call & Service Ownership</strong>: the owners of the repository are the owners of the service and are in charge of operating it and being on call.</li><li><strong>Testing</strong>: we used JVM-based languages and gradle. To simplify our pipeline services have to implement three commands: <code>./gradlew test</code>, <code>./gradlew integrationTest</code>, <code>./gradlew e2eTest</code>.</li></ul><p>To simplify the work developers have to do, they only have to implement the convention for Transport and Testing. <code>lemi</code>, our CLI, takes care of all the rest: Routing, Naming, Observability, Packaging and Service Ownership (by relying on GitHub permissions).</p><h2 id=provisioning-deploying-and-operating-a-service>Provisioning, Deploying and Operating a service<a hidden class=anchor aria-hidden=true href=#provisioning-deploying-and-operating-a-service>#</a></h2><p>I already threw a lot of text at you so instead of explaining things further let&rsquo;s have some fun by going through a demo of what developers actually do when working with services at Lemon, let&rsquo;s add some screenshots too! üì∏.</p><h3 id=provisioning>Provisioning<a hidden class=anchor aria-hidden=true href=#provisioning>#</a></h3><p>To simplify the demo we will assume a developer already has a part of the service developed, this means that there already is a GitHub repository that has the branches we use at Lemon: <code>main</code> for production and <code>develop</code> for staging (our testing environment).</p><p>We start working from <code>main</code>. To start the provisioning process we go back to the first part of this blog post and run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># first we checkout a new branch were we will add all the files generated by lemi</span>
</span></span><span class=line><span class=cl>$ git checkout -b lemi-provision
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># now we simply create a new service by running the following command</span>
</span></span><span class=line><span class=cl>$ lemi service new --cpu <span class=m>512</span> --memory <span class=m>1024</span> --owner infra --service demo-service --desired-count <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># run git status to see what lemi actually added</span>
</span></span><span class=line><span class=cl>$ git status
</span></span><span class=line><span class=cl>On branch lemi-provision
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Untracked files:
</span></span><span class=line><span class=cl>  <span class=o>(</span>use <span class=s2>&#34;git add &lt;file&gt;...&#34;</span> to include in what will be committed<span class=o>)</span>
</span></span><span class=line><span class=cl>        .github/
</span></span><span class=line><span class=cl>        deploy/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>nothing added to commit but untracked files present <span class=o>(</span>use <span class=s2>&#34;git add&#34;</span> to track<span class=o>)</span>
</span></span></code></pre></div><p>As you can see in the last command, lemi added two new folders: <code>deploy/</code> and <code>.github/</code>. Inspecting first <code>deploy/</code> we can see that it created the <code>service.yaml</code> definition we previously mentioned along with two files, <code>prod.yaml</code> and <code>staging.yaml</code>, that hold the environment variables, secrets and parameters for each corresponding environment:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ tree deploy/
</span></span><span class=line><span class=cl>deploy/
</span></span><span class=line><span class=cl>‚îî‚îÄ‚îÄ demo-service
</span></span><span class=line><span class=cl>    ‚îú‚îÄ‚îÄ environment
</span></span><span class=line><span class=cl>    ‚îÇ   ‚îú‚îÄ‚îÄ prod.yaml
</span></span><span class=line><span class=cl>    ‚îÇ   ‚îî‚îÄ‚îÄ staging.yaml
</span></span><span class=line><span class=cl>    ‚îî‚îÄ‚îÄ service.yaml
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>2</span> directories, <span class=m>3</span> files
</span></span></code></pre></div><p>Let&rsquo;s take a look at the specification of the service by looking at <code>service.yaml</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>demo-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>owner</span><span class=p>:</span><span class=w> </span><span class=l>infra</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>desiredCount</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>demo-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resource</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=m>512</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=m>1024</span><span class=w>
</span></span></span></code></pre></div><p>This is a very simple spec, mainly because the requirements we have are clear and some of the conventions allow us to not provide additional config parameters. We only have to define the service&rsquo;s name, owners (used for cost ownership) and the spec that holds the resources the service requires.</p><p>With that out the way, lets actually try to provision our service. For this all we have to do is commit, push and create a PR on GitHub. With the PR created we will see something interesting happen. There is a link, that was automatically added, pointing to a PR on our central terraform repository:</p><p><img loading=lazy src=/images/provision-pr.png alt="Screenshot showing a GitHub Pull Request with a link to another PR"></p><p>If we follow the link we can see what the PR is actually attempting to provision (this is the static infrastructure):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>module</span> <span class=s2>&#34;demo_service_ecs&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  source</span>         <span class=o>=</span> <span class=s2>&#34;git@github.com:lemonatio/infra-ecs-module.git&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  owner</span>          <span class=o>=</span> <span class=s2>&#34;Infra&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  name</span>           <span class=o>=</span> <span class=s2>&#34;demo-service&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  networking</span>     <span class=o>=</span> <span class=k>local</span><span class=p>.</span><span class=k>networking</span>
</span></span><span class=line><span class=cl><span class=n>  load_balancers</span> <span class=o>=</span> <span class=k>local</span><span class=p>.</span><span class=k>load_balancers</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>The interesting part here is the ECS module itself we provide. This module abstracts away all the complexity that provisioning an ECS service has and implements some of the conventions we defined previously, the most important one being routing and ingress rules that make this service accessible from within our infrastructure and from the internet. This module is closed source and I cannot share the implementation here unfortunately.</p><p>With this PR created, developers can add any additional <strong>Static Infrastructure</strong> that they need. For example, if their application requires an ElastiCache instance it could easily be added here using our modules as well:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hcl data-lang=hcl><span class=line><span class=cl><span class=k>module</span> <span class=s2>&#34;demo_service_ecs&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  source</span>         <span class=o>=</span> <span class=s2>&#34;git@github.com:lemonatio/infra-ecs-module.git&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  owner</span>          <span class=o>=</span> <span class=s2>&#34;Infra&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  name</span>           <span class=o>=</span> <span class=s2>&#34;demo-service&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  networking</span>     <span class=o>=</span> <span class=k>local</span><span class=p>.</span><span class=k>networking</span>
</span></span><span class=line><span class=cl><span class=n>  load_balancers</span> <span class=o>=</span> <span class=k>local</span><span class=p>.</span><span class=k>load_balancers</span>
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=s2>&#34;demo_service_redis&#34;</span> {
</span></span><span class=line><span class=cl><span class=n>  source</span>         <span class=o>=</span> <span class=s2>&#34;git@github.com:lemonatio/infra-redis-module.git&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  name</span>           <span class=o>=</span> <span class=s2>&#34;demo-service-redis&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  owner</span>          <span class=o>=</span> <span class=s2>&#34;Infra&#34;</span>
</span></span><span class=line><span class=cl><span class=n>  networking</span>     <span class=o>=</span> <span class=k>local</span><span class=p>.</span><span class=k>networking</span>
</span></span><span class=line><span class=cl><span class=n>  service_sg_ids</span> <span class=o>=</span> <span class=k>toset</span><span class=p>(</span><span class=k>module</span><span class=p>.</span><span class=k>demo_service_ecs</span><span class=p>.</span><span class=k>default</span><span class=p>.</span><span class=k>network_configuration</span><span class=p>[</span><span class=m>0</span><span class=p>].</span><span class=k>security_groups</span><span class=p>)</span>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>You may be wondering how did this happen? <code>lemi</code> FTW! If you remember when we run the <code>lemi service new</code> command we showed that lemi added some github workflows within <code>.github</code>. One of those workflows is <code>provision.yaml</code> and takes care of everything we just saw. The important part of it is that the workflow does not do any magic, it only orchestrates functionality that <code>lemi</code> itself provides. The important part of the workflow is this right here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Infra provisioning</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>GH_AUTH_TOKEN</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.LEMONATIO_BOT_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>  ./lemi-latest provision --prId ${{ github.event.number }} --repoName ${{ github.event.repository.name }} --currentBranchName ${{ steps.branch-name.outputs.current_branch }} --service demo-service</span><span class=w>  
</span></span></span></code></pre></div><p>As you can see we are using a command that lemi provides: <code>lemi provision &lt;flags></code>. The rationale for this is that we want to make sure that all of our operations that happen on our CI can be also tested and run locally. If for some reason we stopped using GitHub Workflows, developers could still simply run this command on their local machines and the entire process would continue to work.</p><p>This PR will be reviewed and approved by the infra team. Once it is merged the corresponding PR on the service repository will be automatically merged and the service will be considered provisioned! <img loading=lazy src=/images/ahhhhhhhhh.gif alt="crazy emoji"></p><p>Now let&rsquo;s move along to doing our first deployment.</p><h3 id=deploying>Deploying<a hidden class=anchor aria-hidden=true href=#deploying>#</a></h3><p>As was previously mentioned we have two environments at Lemon: production (deployed from the <code>main</code> branch) and staging (deployed from the <code>develop</code> branch). When we executed <code>lemi service new</code>, lemi generated the provisioning workflows along with all of our building, testing and deployment workflows. Let&rsquo;s inspect staging&rsquo;s deployment workflow to understand how things are deployed:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Deploy to staging</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>push</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>develop</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>test</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>./.github/workflows/tests.yml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>./.github/workflows/build.yml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>needs</span><span class=p>:</span><span class=w> </span><span class=l>test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>image-tag</span><span class=p>:</span><span class=w> </span><span class=l>${{ github.sha }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>ecr-repo</span><span class=p>:</span><span class=w> </span><span class=l>demo-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>secrets</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>region</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_STAGING_REGION }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>access-key-id</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_STAGING_ACCESS_KEY_ID }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>secret-access-key</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_STAGING_SECRET_ACCESS_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>deploy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>./.github/workflows/deploy.yml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>needs</span><span class=p>:</span><span class=w> </span><span class=l>build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>image-tag</span><span class=p>:</span><span class=w> </span><span class=l>${{ github.sha }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>service</span><span class=p>:</span><span class=w> </span><span class=l>demo-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>environment</span><span class=p>:</span><span class=w> </span><span class=l>staging</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>lemi-bucket</span><span class=p>:</span><span class=w> </span><span class=l>infra-lemi-staging</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>secrets</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>region</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_STAGING_REGION }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>cluster</span><span class=p>:</span><span class=w> </span><span class=l>lemon-ecs-cluster</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>access-key-id</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_STAGING_ACCESS_KEY_ID }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>secret-access-key</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.AWS_STAGING_SECRET_ACCESS_KEY }}</span><span class=w>
</span></span></span></code></pre></div><p>The first important thing is reusability! You can see that each step (build and deploy) is triggering a different workflow and specifying a series of parameters that are specific for this environment. This allows us to have a single workflow that is reused across environments.</p><p>Let&rsquo;s now look into the <code>deploy</code> workflow since the <code>build</code> is rather simple (build the dockerfile and publish to ECR). The process itself is quite large, so lets only look into the relevant parts, this are the ones controlled again by lemi:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Verify service spec and provisioning</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>verify-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>SERVICE</span><span class=p>:</span><span class=w> </span><span class=l>${{ inputs.service }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>CLUSTER</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.cluster }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>  ./lemi-latest verify -s=$SERVICE --cluster=$CLUSTER --check=spec,provisioned -e=$ENV</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Compile task definition</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>compile-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>IMAGE_TAG</span><span class=p>:</span><span class=w> </span><span class=l>${{ inputs.image-tag }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>SUFFIX</span><span class=p>:</span><span class=w> </span><span class=l>${{ inputs.suffix }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>SERVICE</span><span class=p>:</span><span class=w> </span><span class=l>${{ inputs.service }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ENV</span><span class=p>:</span><span class=w> </span><span class=l>${{ inputs.environment }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>    ./lemi-latest compile -t=$IMAGE_TAG -s=$SERVICE -e=$ENV
</span></span></span><span class=line><span class=cl><span class=sd>    cat task-definition.json</span><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Deploy service with new task definition</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>id</span><span class=p>:</span><span class=w> </span><span class=l>deploy-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>SERVICE</span><span class=p>:</span><span class=w> </span><span class=l>${{ inputs.service }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>CLUSTER</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.cluster }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>SUFFIX</span><span class=p>:</span><span class=w> </span><span class=l>${{ inputs.suffix }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>    ./lemi-latest deploy -s=$SERVICE --cluster=$CLUSTER</span><span class=w>    
</span></span></span></code></pre></div><p>We have three key steps defined here:</p><ol><li><code>lemi verify</code>: this command runs a series of validations to make sure that the deployment can indeed be executed. This validation checks the service, secrets and parameters are all provisioned on the corresponding environment and validates that the <code>YAML</code> is correct and has all required parameters.</li><li><code>lemi compile</code>: with the <code>service.yaml</code>, the corresponding env file (i.e <code>staging.yaml</code>) and the ECR Image tag we compile it down into an ECS task definition</li><li><code>lemi deploy</code>: using the task definition created in the compilation process, we register a new revision and update the service to point to this latest version.</li></ol><p>As it was shown in the provisioning process previously, all critical operations are done by lemi and GitHub simply orchestrates the execution of it. This means that any developer can run this commands on their local machine if needed.</p><p>With this workflows in place all commits sent to develop will be automatically deployed to staging and those that go to main will be deployed in production:</p><p><img loading=lazy src=/images/staging-deployment.png alt="Successful GitHub workflow for a staging deployment"></p><h3 id=operating>Operating<a hidden class=anchor aria-hidden=true href=#operating>#</a></h3><p>Last but certainly not least, we want to provide a unified way of operating services at the company. This is mainly because we are not a big company and switching between teams that own different services is completely normal. So if a developer goes from team A to team B, they are already familiar with how to operate their services in our environments. This is why we built a series of commands into lemi that developers use. A few operations that developers usually do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># restart the service using a graceful deploy of the same image</span>
</span></span><span class=line><span class=cl>$ lemi service restart -s demo-service -c lemon-ecs-cluster
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># list all running tasks the service has</span>
</span></span><span class=line><span class=cl>$ lemi service list-tasks -s demo-service -c lemon-ecs-cluster
</span></span><span class=line><span class=cl><span class=o>[</span><span class=s2>&#34;arn:aws:ecs:us-east-1:&lt;AWS_ACCOUNT_ID&gt;:task/lemon-ecs-cluster-prod/77c0048e9f3a4e04ae6b35c89270acdd&#34;</span>,<span class=s2>&#34;arn:aws:ecs:us-east-1:&lt;AWS_ACCOUNT_ID&gt;:task/lemon-ecs-cluster-prod/91a67a2f88b542e4a8c30f2c6290d80e&#34;</span>,<span class=s2>&#34;arn:aws:ecs:us-east-1:&lt;AWS_ACCOUNT_ID&gt;:task/lemon-ecs-cluster-prod/d02725effb574e96847b4abe21740987&#34;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># stop a specific task</span>
</span></span><span class=line><span class=cl>$ lemi service stop-task --task-id arn:aws:ecs:us-east-1:&lt;AWS_ACCOUNT_ID&gt;:task/lemon-ecs-cluster-prod/77c0048e9f3a4e04ae6b35c89270acdd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># exec into the container of the service, useful for when things go wrong and we want to do closer deep dives</span>
</span></span><span class=line><span class=cl>$ lemi service <span class=nb>exec</span> -s demo-service -c lemon-ecs-cluster /bin/bash
</span></span><span class=line><span class=cl>running /bin/bash on task arn:aws:ecs:us-east-1:&lt;AWS_ACCOUNT_ID&gt;:task/lemon-ecs-cluster-prod/77c0048e9f3a4e04ae6b35c89270acdd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Starting session with SessionId: ecs-execute-command-0730176e68438b66d
</span></span><span class=line><span class=cl>root@ip-172-19-0-73:/#
</span></span></code></pre></div><p>We have more commands available for inspecting the service, understanding the status of a deployment, etc. As developers need specific operations we can quickly develop them since they are wrappers over AWS&rsquo;s API.</p><h2 id=looking-forward>Looking forward<a hidden class=anchor aria-hidden=true href=#looking-forward>#</a></h2><p>We understand that what we built here is rather simple but we believe it solves a big pain we were facing and lays a very strong foundation for future requirements we may have. One of the big discussions that we are going to have in the short term is whether we want to stick with ECS or not. While it certainly has good functionality and is the right tool for many use cases, we are starting to hit some of its limitations and they are starting to hurt. When we started with this idea we had a short conversation on whether we wanted to stick with ECS or not, but since we were (and are) short staffed with a lot of important things to tackle we decided to leave that discussion for the future. While this may change some details of this process we believe that the concepts and conventions will remain.</p><p>What are our next steps? For now we are focused on other projects, the biggest one was mentioned previously and is the breaking of the monolith. We are an infrastructure and Engineering Effectiveness team which is why we are the owners of it. We believe that as we have more services we will encounter use cases that will force us to adopt and develop new and exciting things, so we can&rsquo;t wait!</p><h2 id=remarks>Remarks<a hidden class=anchor aria-hidden=true href=#remarks>#</a></h2><p>Thank you for sticking until the end! We have many exciting projects going on and more blog posts may come to this blog. While I&rsquo;m the one writing this, I&rsquo;m not by any means the only one that should receive credit for this work. I wanted to mention Claudio Martinez and the entire Infra/SRE team at Lemon Cash because without them this blog would not exist üòÅ</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.matiaspan.dev/tags/infrastructure/>infrastructure</a></li><li><a href=https://blog.matiaspan.dev/tags/lemoncash/>lemoncash</a></li><li><a href=https://blog.matiaspan.dev/tags/terraform/>terraform</a></li><li><a href=https://blog.matiaspan.dev/tags/go/>go</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share How services are provisioned, deployed and operated at Lemon Cash on x" href="https://x.com/intent/tweet/?text=How%20services%20are%20provisioned%2c%20deployed%20and%20operated%20at%20Lemon%20Cash&amp;url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fhow-services-are-provisioned-and-deployed-at-lemoncash%2f&amp;hashtags=infrastructure%2clemoncash%2cterraform%2cgo"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How services are provisioned, deployed and operated at Lemon Cash on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fhow-services-are-provisioned-and-deployed-at-lemoncash%2f&amp;title=How%20services%20are%20provisioned%2c%20deployed%20and%20operated%20at%20Lemon%20Cash&amp;summary=How%20services%20are%20provisioned%2c%20deployed%20and%20operated%20at%20Lemon%20Cash&amp;source=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fhow-services-are-provisioned-and-deployed-at-lemoncash%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How services are provisioned, deployed and operated at Lemon Cash on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fhow-services-are-provisioned-and-deployed-at-lemoncash%2f&title=How%20services%20are%20provisioned%2c%20deployed%20and%20operated%20at%20Lemon%20Cash"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How services are provisioned, deployed and operated at Lemon Cash on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fhow-services-are-provisioned-and-deployed-at-lemoncash%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How services are provisioned, deployed and operated at Lemon Cash on whatsapp" href="https://api.whatsapp.com/send?text=How%20services%20are%20provisioned%2c%20deployed%20and%20operated%20at%20Lemon%20Cash%20-%20https%3a%2f%2fblog.matiaspan.dev%2fposts%2fhow-services-are-provisioned-and-deployed-at-lemoncash%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How services are provisioned, deployed and operated at Lemon Cash on telegram" href="https://telegram.me/share/url?text=How%20services%20are%20provisioned%2c%20deployed%20and%20operated%20at%20Lemon%20Cash&amp;url=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fhow-services-are-provisioned-and-deployed-at-lemoncash%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How services are provisioned, deployed and operated at Lemon Cash on ycombinator" href="https://news.ycombinator.com/submitlink?t=How%20services%20are%20provisioned%2c%20deployed%20and%20operated%20at%20Lemon%20Cash&u=https%3a%2f%2fblog.matiaspan.dev%2fposts%2fhow-services-are-provisioned-and-deployed-at-lemoncash%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.matiaspan.dev/>Matias Pan's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>